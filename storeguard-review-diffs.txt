==========================================
BRANCH: v2/p0-remove-mock-data
==========================================
diff --git a/insightops/app/routes/api.test-inventory.tsx b/insightops/app/routes/api.test-inventory.tsx
deleted file mode 100644
index e568efd..0000000
--- a/insightops/app/routes/api.test-inventory.tsx
+++ /dev/null
@@ -1,63 +0,0 @@
-import type { LoaderFunctionArgs } from "react-router";
-import db from "../db.server";
-import { queueWebhookJob } from "../services/jobQueue.server";
-import { processPendingJobs } from "../services/jobProcessor.server";
-
-export const loader = async ({ request }: LoaderFunctionArgs) => {
-  // 1. Find a valid session to use
-  const session = await db.session.findFirst();
-
-  if (!session) {
-    return new Response(
-      JSON.stringify({ error: "No session found. Please install the app first." }),
-      { status: 404, headers: { "Content-Type": "application/json" } }
-    );
-  }
-
-  const shop = session.shop;
-  console.log(`[Test] Using shop: ${shop}`);
-
-  // 2. Queue a fake inventory job
-  // specific mock IDs - in a real scenario these would need to match real Shopify IDs
-  // for the API calls in jobProcessor to succeed.
-  // However, even if they fail API calls, it should still log "Inventory updated: Unknown Product"
-
-  const jobId = await queueWebhookJob({
-    shop,
-    topic: "inventory/levels/update",
-    resourceId: "123456789", // Fake inventory item ID
-    payload: {
-      inventory_item_id: 123456789,
-      location_id: 987654321,
-      available: 50 + Math.floor(Math.random() * 10), // Random stock level
-      updated_at: new Date().toISOString(),
-    },
-    delayMs: 0, // No delay for test
-  });
-
-  console.log(`[Test] Queued job ${jobId}`);
-
-  // 3. Process it immediately
-  const result = await processPendingJobs();
-
-  // 4. Check if event was created
-  const recentEvent = await db.eventLog.findFirst({
-    where: {
-      shop,
-      topic: "INVENTORY_LEVELS_UPDATE"
-    },
-    orderBy: { timestamp: "desc" }
-  });
-
-  return new Response(
-    JSON.stringify({
-      message: "Test completed",
-      jobId,
-      processingResult: result,
-      recentEvent,
-    }),
-    { status: 200, headers: { "Content-Type": "application/json" } }
-  );
-};
-
-
diff --git a/insightops/app/routes/app.changes.test.ts b/insightops/app/routes/app.changes.test.ts
new file mode 100644
index 0000000..69dbc6d
--- /dev/null
+++ b/insightops/app/routes/app.changes.test.ts
@@ -0,0 +1,116 @@
+import { describe, it, expect } from "vitest";
+
+/**
+ * Tests for the event display configuration used in app.changes.tsx.
+ * Ensures all supported event types and importance levels have display configs.
+ */
+
+// Mirror the event config from app.changes.tsx to verify completeness
+const eventConfig: Record<string, { label: string; color: string }> = {
+  price_change: { label: "Price Change", color: "#ffa500" },
+  visibility_change: { label: "Visibility", color: "#9b59b6" },
+  inventory_low: { label: "Low Stock", color: "#f97316" },
+  inventory_zero: { label: "Out of Stock", color: "#e74c3c" },
+  theme_publish: { label: "Theme Published", color: "#3498db" },
+};
+
+const importanceConfig: Record<string, { label: string; color: string }> = {
+  high: { label: "High", color: "#e74c3c" },
+  medium: { label: "Medium", color: "#f39c12" },
+  low: { label: "Low", color: "#95a5a6" },
+};
+
+// All event types that the system can produce (from changeDetection.server.ts)
+const ALL_EVENT_TYPES = [
+  "price_change",
+  "visibility_change",
+  "inventory_low",
+  "inventory_zero",
+  "theme_publish",
+];
+
+const ALL_IMPORTANCE_LEVELS = ["high", "medium", "low"];
+
+describe("event display config", () => {
+  it("should have config for every supported event type", () => {
+    for (const eventType of ALL_EVENT_TYPES) {
+      expect(eventConfig[eventType]).toBeDefined();
+      expect(eventConfig[eventType].label).toBeTruthy();
+      expect(eventConfig[eventType].color).toBeTruthy();
+    }
+  });
+
+  it("should have config for every importance level", () => {
+    for (const level of ALL_IMPORTANCE_LEVELS) {
+      expect(importanceConfig[level]).toBeDefined();
+      expect(importanceConfig[level].label).toBeTruthy();
+      expect(importanceConfig[level].color).toBeTruthy();
+    }
+  });
+
+  it("should not have extra event types beyond what the system produces", () => {
+    const configKeys = Object.keys(eventConfig);
+    for (const key of configKeys) {
+      expect(ALL_EVENT_TYPES).toContain(key);
+    }
+  });
+
+  it("should use valid hex color codes", () => {
+    const hexPattern = /^#[0-9a-fA-F]{6}$/;
+
+    for (const config of Object.values(eventConfig)) {
+      expect(config.color).toMatch(hexPattern);
+    }
+    for (const config of Object.values(importanceConfig)) {
+      expect(config.color).toMatch(hexPattern);
+    }
+  });
+});
+
+describe("email validation", () => {
+  // Mirror the validation from app.settings.tsx
+  function isValidEmail(email: string): boolean {
+    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
+  }
+
+  function validateEmails(
+    emailString: string
+  ): { valid: boolean; invalidEmails: string[] } {
+    if (!emailString.trim()) return { valid: true, invalidEmails: [] };
+    const emails = emailString
+      .split(",")
+      .map((e) => e.trim())
+      .filter((e) => e);
+    const invalidEmails = emails.filter((e) => !isValidEmail(e));
+    return { valid: invalidEmails.length === 0, invalidEmails };
+  }
+
+  it("should accept valid emails", () => {
+    expect(isValidEmail("test@example.com")).toBe(true);
+    expect(isValidEmail("user+tag@domain.co")).toBe(true);
+    expect(isValidEmail("name@sub.domain.com")).toBe(true);
+  });
+
+  it("should reject invalid emails", () => {
+    expect(isValidEmail("not-an-email")).toBe(false);
+    expect(isValidEmail("@missing-local.com")).toBe(false);
+    expect(isValidEmail("missing-domain@")).toBe(false);
+    expect(isValidEmail("has spaces@example.com")).toBe(false);
+  });
+
+  it("should validate comma-separated email lists", () => {
+    expect(validateEmails("a@b.com, c@d.com")).toEqual({
+      valid: true,
+      invalidEmails: [],
+    });
+    expect(validateEmails("a@b.com, bad-email")).toEqual({
+      valid: false,
+      invalidEmails: ["bad-email"],
+    });
+  });
+
+  it("should treat empty string as valid", () => {
+    expect(validateEmails("")).toEqual({ valid: true, invalidEmails: [] });
+    expect(validateEmails("   ")).toEqual({ valid: true, invalidEmails: [] });
+  });
+});
diff --git a/insightops/app/routes/app.changes.tsx b/insightops/app/routes/app.changes.tsx
index 26d7faf..ac6c1b3 100644
--- a/insightops/app/routes/app.changes.tsx
+++ b/insightops/app/routes/app.changes.tsx
@@ -62,15 +62,25 @@ export default function RecentChanges() {
       {events.length === 0 ? (
         <div
           style={{
-            background: "#f4f6f8",
-            borderRadius: 8,
-            padding: 32,
+            background: "#fff",
+            border: "1px solid #e1e3e5",
+            borderRadius: 10,
+            padding: "48px 32px",
             textAlign: "center",
-            color: "#637381",
           }}
         >
-          No changes detected yet. Changes will appear here when products are updated, visibility
-          changes, inventory hits zero, or themes are published.
+          <div style={{ marginBottom: 12 }}>
+            <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#8c9196" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
+              <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" />
+            </svg>
+          </div>
+          <h2 style={{ fontSize: 16, fontWeight: 600, color: "#202223", marginBottom: 6 }}>
+            No changes detected yet
+          </h2>
+          <p style={{ color: "#6d7175", fontSize: 14, maxWidth: 360, margin: "0 auto", lineHeight: 1.5 }}>
+            StoreGuard is monitoring your store. Changes will appear here when prices change,
+            products are hidden, inventory runs out, or themes are published.
+          </p>
         </div>
       ) : (
         <div style={{ display: "flex", flexDirection: "column", gap: 12 }}>
diff --git a/insightops/app/utils/inventoryProcessing.test.ts b/insightops/app/utils/inventoryProcessing.test.ts
deleted file mode 100644
index 880eed7..0000000
--- a/insightops/app/utils/inventoryProcessing.test.ts
+++ /dev/null
@@ -1,150 +0,0 @@
-import { describe, it, expect } from "vitest";
-import {
-  generateDisplayName,
-  generateInventoryMessage,
-  isGiftCard,
-  wasInventoryUpdateCausedByOrder,
-  buildInventoryDiff,
-} from "./inventoryProcessing";
-
-describe("generateDisplayName", () => {
-  it("should return product title only when no variant", () => {
-    expect(generateDisplayName("Widget", null)).toBe("Widget");
-  });
-
-  it("should return product title only for Default Title variant", () => {
-    expect(generateDisplayName("Widget", "Default Title")).toBe("Widget");
-  });
-
-  it("should combine product and variant titles", () => {
-    expect(generateDisplayName("Widget", "Large")).toBe("Widget - Large");
-    expect(generateDisplayName("T-Shirt", "Blue / XL")).toBe("T-Shirt - Blue / XL");
-  });
-});
-
-describe("generateInventoryMessage", () => {
-  it("should show increase arrow when stock goes up", () => {
-    const message = generateInventoryMessage("Widget", 10, 15);
-    expect(message).toBe('Stock â†‘ "Widget" (10 â†’ 15)');
-  });
-
-  it("should show decrease arrow when stock goes down", () => {
-    const message = generateInventoryMessage("Widget", 20, 15);
-    expect(message).toBe('Stock â†“ "Widget" (20 â†’ 15)');
-  });
-
-  it("should show simple message when no previous value", () => {
-    const message = generateInventoryMessage("Widget", null, 100);
-    expect(message).toBe('Stock updated: "Widget" (100 units)');
-  });
-
-  it("should show simple message when value unchanged", () => {
-    const message = generateInventoryMessage("Widget", 50, 50);
-    expect(message).toBe('Stock updated: "Widget" (50 units)');
-  });
-
-  it("should handle zero stock", () => {
-    expect(generateInventoryMessage("Widget", 5, 0)).toBe('Stock â†“ "Widget" (5 â†’ 0)');
-    expect(generateInventoryMessage("Widget", 0, 5)).toBe('Stock â†‘ "Widget" (0 â†’ 5)');
-  });
-});
-
-describe("isGiftCard", () => {
-  it("should detect gift card in title", () => {
-    expect(isGiftCard("$50 Gift Card", "")).toBe(true);
-    expect(isGiftCard("Store Gift Card", "product")).toBe(true);
-    expect(isGiftCard("GIFT CARD $100", "")).toBe(true);
-  });
-
-  it("should detect gift_card product type", () => {
-    expect(isGiftCard("Store Credit", "gift_card")).toBe(true);
-    expect(isGiftCard("Store Credit", "GIFT_CARD")).toBe(true);
-  });
-
-  it("should not flag regular products", () => {
-    expect(isGiftCard("Regular Widget", "widget")).toBe(false);
-    expect(isGiftCard("Card Holder", "accessory")).toBe(false);
-    expect(isGiftCard("Gift Box", "packaging")).toBe(false);
-  });
-});
-
-describe("wasInventoryUpdateCausedByOrder", () => {
-  it("should return true when product is in order items", () => {
-    const orderDiff = JSON.stringify({
-      items: [
-        { productId: 123, title: "Widget", quantity: 2 },
-        { productId: 456, title: "Gadget", quantity: 1 },
-      ],
-    });
-
-    expect(wasInventoryUpdateCausedByOrder("123", orderDiff)).toBe(true);
-    expect(wasInventoryUpdateCausedByOrder("456", orderDiff)).toBe(true);
-  });
-
-  it("should return false when product is not in order items", () => {
-    const orderDiff = JSON.stringify({
-      items: [{ productId: 123, title: "Widget", quantity: 2 }],
-    });
-
-    expect(wasInventoryUpdateCausedByOrder("999", orderDiff)).toBe(false);
-  });
-
-  it("should return false for null/empty inputs", () => {
-    expect(wasInventoryUpdateCausedByOrder("123", null)).toBe(false);
-    expect(wasInventoryUpdateCausedByOrder("", '{"items":[]}')).toBe(false);
-  });
-
-  it("should return false for invalid JSON", () => {
-    expect(wasInventoryUpdateCausedByOrder("123", "not json")).toBe(false);
-  });
-
-  it("should return false when items array is missing", () => {
-    const orderDiff = JSON.stringify({ orderId: 1, total: "100" });
-    expect(wasInventoryUpdateCausedByOrder("123", orderDiff)).toBe(false);
-  });
-
-  it("should handle string vs number productId comparison", () => {
-    const orderDiff = JSON.stringify({
-      items: [{ productId: 123456789, title: "Widget" }],
-    });
-
-    // Our function converts to string for comparison
-    expect(wasInventoryUpdateCausedByOrder("123456789", orderDiff)).toBe(true);
-  });
-});
-
-describe("buildInventoryDiff", () => {
-  it("should include inventory change when values differ", () => {
-    const diff = buildInventoryDiff(15, 20, 12345);
-    const parsed = JSON.parse(diff);
-
-    expect(parsed.available).toBe(15);
-    expect(parsed.inventoryChange).toEqual({ old: 20, new: 15 });
-    expect(parsed.locationId).toBe(12345);
-  });
-
-  it("should not include inventory change when no previous value", () => {
-    const diff = buildInventoryDiff(100, null, 12345);
-    const parsed = JSON.parse(diff);
-
-    expect(parsed.available).toBe(100);
-    expect(parsed.inventoryChange).toBeNull();
-    expect(parsed.locationId).toBe(12345);
-  });
-
-  it("should not include inventory change when values are same", () => {
-    const diff = buildInventoryDiff(50, 50, 12345);
-    const parsed = JSON.parse(diff);
-
-    expect(parsed.available).toBe(50);
-    expect(parsed.inventoryChange).toBeNull();
-  });
-
-  it("should handle zero values correctly", () => {
-    const diff = buildInventoryDiff(0, 5, 12345);
-    const parsed = JSON.parse(diff);
-
-    expect(parsed.available).toBe(0);
-    expect(parsed.inventoryChange).toEqual({ old: 5, new: 0 });
-  });
-});
diff --git a/insightops/app/utils/inventoryProcessing.ts b/insightops/app/utils/inventoryProcessing.ts
deleted file mode 100644
index 1f96e78..0000000
--- a/insightops/app/utils/inventoryProcessing.ts
+++ /dev/null
@@ -1,90 +0,0 @@
-/**
- * Inventory Processing Utility Functions
- * Extracted for testing and reuse
- */
-
-export interface InventoryUpdate {
-  available: number;
-  oldAvailable: number | null;
-  productTitle: string;
-  variantTitle: string | null;
-}
-
-/**
- * Generate display name for a product/variant combination
- */
-export function generateDisplayName(
-  productTitle: string,
-  variantTitle: string | null
-): string {
-  if (variantTitle && variantTitle !== "Default Title") {
-    return `${productTitle} - ${variantTitle}`;
-  }
-  return productTitle;
-}
-
-/**
- * Generate inventory update message with directional arrow
- */
-export function generateInventoryMessage(
-  displayName: string,
-  oldAvailable: number | null,
-  newAvailable: number
-): string {
-  if (oldAvailable !== null && oldAvailable !== newAvailable) {
-    const change = newAvailable - oldAvailable;
-    const arrow = change > 0 ? "â†‘" : "â†“";
-    return `Stock ${arrow} "${displayName}" (${oldAvailable} â†’ ${newAvailable})`;
-  }
-  return `Stock updated: "${displayName}" (${newAvailable} units)`;
-}
-
-/**
- * Check if a product is a gift card (should be filtered)
- */
-export function isGiftCard(productTitle: string, productType: string): boolean {
-  return (
-    productTitle.toLowerCase().includes("gift card") ||
-    productType.toLowerCase() === "gift_card"
-  );
-}
-
-/**
- * Check if an inventory update was likely caused by a recent order
- * This is used to filter "symptom" events when we have the "cause" (order)
- */
-export function wasInventoryUpdateCausedByOrder(
-  productId: string,
-  recentOrderDiff: string | null
-): boolean {
-  if (!recentOrderDiff || !productId) return false;
-
-  try {
-    const orderDiff = JSON.parse(recentOrderDiff);
-    const orderProductIds =
-      orderDiff.items?.map((item: { productId: number }) =>
-        String(item.productId)
-      ) || [];
-    return orderProductIds.includes(productId);
-  } catch {
-    return false;
-  }
-}
-
-/**
- * Build inventory diff JSON for storage
- */
-export function buildInventoryDiff(
-  available: number,
-  oldAvailable: number | null,
-  locationId: number
-): string {
-  return JSON.stringify({
-    available,
-    inventoryChange:
-      oldAvailable !== null && oldAvailable !== available
-        ? { old: oldAvailable, new: available }
-        : null,
-    locationId,
-  });
-}
diff --git a/insightops/app/utils/orderProcessing.test.ts b/insightops/app/utils/orderProcessing.test.ts
deleted file mode 100644
index b770713..0000000
--- a/insightops/app/utils/orderProcessing.test.ts
+++ /dev/null
@@ -1,260 +0,0 @@
-import { describe, it, expect } from "vitest";
-import {
-  calculateItemCount,
-  generateItemSummary,
-  formatAmount,
-  generateOrderMessage,
-  buildOrderDiff,
-  processOrderPayload,
-  type LineItem,
-  type OrderPayload,
-} from "./orderProcessing";
-
-describe("calculateItemCount", () => {
-  it("should sum quantities from all line items", () => {
-    const items: LineItem[] = [
-      { title: "Widget", quantity: 2, price: "10.00", variant_title: null, product_id: 1 },
-      { title: "Gadget", quantity: 3, price: "20.00", variant_title: null, product_id: 2 },
-    ];
-    expect(calculateItemCount(items)).toBe(5);
-  });
-
-  it("should return 0 for empty line items", () => {
-    expect(calculateItemCount([])).toBe(0);
-  });
-
-  it("should handle single item", () => {
-    const items: LineItem[] = [
-      { title: "Widget", quantity: 1, price: "10.00", variant_title: null, product_id: 1 },
-    ];
-    expect(calculateItemCount(items)).toBe(1);
-  });
-});
-
-describe("generateItemSummary", () => {
-  it("should return product title for single item order", () => {
-    const items: LineItem[] = [
-      { title: "Cool Widget", quantity: 1, price: "10.00", variant_title: null, product_id: 1 },
-    ];
-    expect(generateItemSummary(items)).toBe("Cool Widget");
-  });
-
-  it("should return count for multiple items", () => {
-    const items: LineItem[] = [
-      { title: "Widget", quantity: 2, price: "10.00", variant_title: null, product_id: 1 },
-      { title: "Gadget", quantity: 3, price: "20.00", variant_title: null, product_id: 2 },
-    ];
-    expect(generateItemSummary(items)).toBe("5 items");
-  });
-
-  it("should return '0 items' for empty order", () => {
-    expect(generateItemSummary([])).toBe("0 items");
-  });
-
-  it("should return count even if single line item has quantity > 1", () => {
-    const items: LineItem[] = [
-      { title: "Widget", quantity: 3, price: "10.00", variant_title: null, product_id: 1 },
-    ];
-    expect(generateItemSummary(items)).toBe("3 items");
-  });
-});
-
-describe("formatAmount", () => {
-  it("should format USD amounts", () => {
-    expect(formatAmount("100.00", "USD")).toBe("$100.00");
-    expect(formatAmount("1234.56", "USD")).toBe("$1,234.56");
-  });
-
-  it("should format EUR amounts", () => {
-    const result = formatAmount("100.00", "EUR");
-    expect(result).toContain("100");
-    expect(result).toContain("â‚¬");
-  });
-
-  it("should format GBP amounts", () => {
-    const result = formatAmount("100.00", "GBP");
-    expect(result).toContain("100");
-    expect(result).toContain("Â£");
-  });
-
-  it("should default to USD for empty currency", () => {
-    expect(formatAmount("50.00", "")).toBe("$50.00");
-  });
-
-  it("should handle decimal precision", () => {
-    expect(formatAmount("99.99", "USD")).toBe("$99.99");
-    expect(formatAmount("100", "USD")).toBe("$100.00");
-  });
-});
-
-describe("generateOrderMessage", () => {
-  it("should create message with order name and amount", () => {
-    expect(generateOrderMessage("#1001", "$100.00")).toBe("ðŸ’° Order #1001 - $100.00");
-  });
-
-  it("should handle large amounts with formatting", () => {
-    expect(generateOrderMessage("#2345", "$1,234.56")).toBe(
-      "ðŸ’° Order #2345 - $1,234.56"
-    );
-  });
-});
-
-describe("buildOrderDiff", () => {
-  it("should create valid JSON with all order details", () => {
-    const order: OrderPayload = {
-      id: 12345,
-      name: "#1001",
-      total_price: "100.00",
-      subtotal_price: "95.00",
-      currency: "USD",
-      financial_status: "paid",
-      created_at: "2024-01-15T10:00:00Z",
-      line_items: [
-        {
-          title: "Widget",
-          quantity: 2,
-          price: "47.50",
-          variant_title: "Large",
-          product_id: 111,
-        },
-      ],
-      discount_codes: [{ code: "SAVE10", amount: "5.00" }],
-    };
-
-    const diff = buildOrderDiff(order, 2, "2 items");
-    const parsed = JSON.parse(diff);
-
-    expect(parsed.orderId).toBe(12345);
-    expect(parsed.orderName).toBe("#1001");
-    expect(parsed.total).toBe("100.00");
-    expect(parsed.subtotal).toBe("95.00");
-    expect(parsed.currency).toBe("USD");
-    expect(parsed.status).toBe("paid");
-    expect(parsed.itemCount).toBe(2);
-    expect(parsed.itemSummary).toBe("2 items");
-    expect(parsed.items).toHaveLength(1);
-    expect(parsed.items[0].title).toBe("Widget");
-    expect(parsed.items[0].variant).toBe("Large");
-    expect(parsed.items[0].productId).toBe(111);
-    expect(parsed.discounts).toHaveLength(1);
-    expect(parsed.discounts[0].code).toBe("SAVE10");
-  });
-
-  it("should handle orders with no discounts", () => {
-    const order: OrderPayload = {
-      id: 1,
-      name: "#1",
-      total_price: "10.00",
-      subtotal_price: "10.00",
-      currency: "USD",
-      financial_status: "paid",
-      created_at: "2024-01-15T10:00:00Z",
-      line_items: [],
-      discount_codes: [],
-    };
-
-    const diff = buildOrderDiff(order, 0, "items");
-    const parsed = JSON.parse(diff);
-
-    expect(parsed.discounts).toEqual([]);
-    expect(parsed.items).toEqual([]);
-  });
-});
-
-describe("processOrderPayload", () => {
-  it("should process a complete order payload", () => {
-    const order: OrderPayload = {
-      id: 98765,
-      name: "#1234",
-      total_price: "299.99",
-      subtotal_price: "279.99",
-      currency: "USD",
-      financial_status: "paid",
-      created_at: "2024-01-15T14:30:00Z",
-      line_items: [
-        {
-          title: "Premium Widget",
-          quantity: 1,
-          price: "199.99",
-          variant_title: "Blue",
-          product_id: 555,
-        },
-        {
-          title: "Widget Case",
-          quantity: 2,
-          price: "40.00",
-          variant_title: null,
-          product_id: 556,
-        },
-      ],
-      discount_codes: [{ code: "BUNDLE20", amount: "20.00" }],
-    };
-
-    const result = processOrderPayload(order);
-
-    expect(result.shopifyId).toBe("98765");
-    expect(result.itemCount).toBe(3);
-    expect(result.itemSummary).toBe("3 items");
-    expect(result.formattedAmount).toBe("$299.99");
-    expect(result.message).toBe("ðŸ’° Order #1234 - $299.99");
-
-    const diffParsed = JSON.parse(result.diff);
-    expect(diffParsed.orderId).toBe(98765);
-    expect(diffParsed.items).toHaveLength(2);
-  });
-
-  it("should handle single item order", () => {
-    const order: OrderPayload = {
-      id: 111,
-      name: "#5",
-      total_price: "25.00",
-      subtotal_price: "25.00",
-      currency: "USD",
-      financial_status: "paid",
-      created_at: "2024-01-15T09:00:00Z",
-      line_items: [
-        {
-          title: "Small Gadget",
-          quantity: 1,
-          price: "25.00",
-          variant_title: null,
-          product_id: 999,
-        },
-      ],
-      discount_codes: [],
-    };
-
-    const result = processOrderPayload(order);
-
-    expect(result.itemCount).toBe(1);
-    expect(result.itemSummary).toBe("Small Gadget");
-    expect(result.message).toBe("ðŸ’° Order #5 - $25.00");
-  });
-
-  it("should handle international currency", () => {
-    const order: OrderPayload = {
-      id: 222,
-      name: "#10",
-      total_price: "50.00",
-      subtotal_price: "50.00",
-      currency: "GBP",
-      financial_status: "paid",
-      created_at: "2024-01-15T12:00:00Z",
-      line_items: [
-        {
-          title: "UK Widget",
-          quantity: 1,
-          price: "50.00",
-          variant_title: null,
-          product_id: 888,
-        },
-      ],
-      discount_codes: [],
-    };
-
-    const result = processOrderPayload(order);
-
-    expect(result.formattedAmount).toContain("Â£");
-    expect(result.formattedAmount).toContain("50");
-  });
-});
diff --git a/insightops/app/utils/orderProcessing.ts b/insightops/app/utils/orderProcessing.ts
deleted file mode 100644
index 8dd43db..0000000
--- a/insightops/app/utils/orderProcessing.ts
+++ /dev/null
@@ -1,111 +0,0 @@
-/**
- * Order Processing Utility Functions
- * Extracted for testing and reuse
- */
-
-export interface LineItem {
-  title: string;
-  quantity: number;
-  price: string;
-  variant_title: string | null;
-  product_id: number | null;
-}
-
-export interface OrderPayload {
-  id: number;
-  name: string;
-  total_price: string;
-  subtotal_price: string;
-  currency: string;
-  financial_status: string;
-  created_at: string;
-  line_items: LineItem[];
-  discount_codes: Array<{ code: string; amount: string }>;
-}
-
-export interface ProcessedOrder {
-  message: string;
-  diff: string;
-  shopifyId: string;
-  itemCount: number;
-  itemSummary: string;
-  formattedAmount: string;
-}
-
-/**
- * Calculate total item count from line items
- */
-export function calculateItemCount(lineItems: LineItem[]): number {
-  return lineItems.reduce((sum, item) => sum + item.quantity, 0);
-}
-
-/**
- * Generate item summary string
- */
-export function generateItemSummary(lineItems: LineItem[]): string {
-  const itemCount = calculateItemCount(lineItems);
-  const firstItem = lineItems[0]?.title || "items";
-  return itemCount === 1 ? firstItem : `${itemCount} items`;
-}
-
-/**
- * Format currency amount
- */
-export function formatAmount(amount: string, currency: string): string {
-  const parsed = parseFloat(amount);
-  return parsed.toLocaleString("en-US", {
-    style: "currency",
-    currency: currency || "USD",
-  });
-}
-
-/**
- * Generate order message for timeline display
- */
-export function generateOrderMessage(orderName: string, formattedAmount: string): string {
-  return `ðŸ’° Order ${orderName} - ${formattedAmount}`;
-}
-
-/**
- * Build order diff JSON for storage
- */
-export function buildOrderDiff(order: OrderPayload, itemCount: number, itemSummary: string): string {
-  return JSON.stringify({
-    orderId: order.id,
-    orderName: order.name,
-    total: order.total_price,
-    subtotal: order.subtotal_price,
-    currency: order.currency,
-    status: order.financial_status,
-    itemCount,
-    itemSummary,
-    items: order.line_items.map((item) => ({
-      title: item.title,
-      variant: item.variant_title,
-      quantity: item.quantity,
-      price: item.price,
-      productId: item.product_id,
-    })),
-    discounts: order.discount_codes,
-  });
-}
-
-/**
- * Process an order payload into structured data for storage
- */
-export function processOrderPayload(order: OrderPayload): ProcessedOrder {
-  const itemCount = calculateItemCount(order.line_items);
-  const itemSummary = generateItemSummary(order.line_items);
-  const formattedAmount = formatAmount(order.total_price, order.currency);
-  const message = generateOrderMessage(order.name, formattedAmount);
-  const diff = buildOrderDiff(order, itemCount, itemSummary);
-
-  return {
-    message,
-    diff,
-    shopifyId: String(order.id),
-    itemCount,
-    itemSummary,
-    formattedAmount,
-  };
-}
diff --git a/insightops/prisma/seed-demo.ts b/insightops/prisma/seed-demo.ts
deleted file mode 100644
index 84480e0..0000000
--- a/insightops/prisma/seed-demo.ts
+++ /dev/null
@@ -1,493 +0,0 @@
-/**
- * Demo Seed Script for Marketing Screenshots & Videos
- *
- * Run with: npx tsx prisma/seed-demo.ts
- *
- * Creates realistic data to showcase InsightOps:
- * - Activity feed with Staff/Bot avatars and detailed diffs
- * - Order events that create a sales chart pattern
- * - A "story" where a price mistake causes a sales dip, then recovery
- *
- * After running, access the app with ?demo=true to use generated chart data:
- *   https://insightops-app.fly.dev/app?demo=true
- *
- * Or run against your local dev store for real data screenshots.
- */
-
-import { PrismaClient } from "@prisma/client";
-
-const db = new PrismaClient();
-
-// Your test store's shop domain
-const SHOP = process.env.DEMO_SHOP || "insight-ops-dev.myshopify.com";
-
-// Realistic staff names for variety
-const STAFF = [
-  "Sarah Chen",
-  "Marcus Johnson",
-  "Emily Rodriguez",
-  "Jake Thompson",
-];
-
-// Bot/App names
-const BOTS = [
-  "System/App",
-  "Shopify Flow",
-  "Inventory Sync",
-];
-
-// Realistic products for a lifestyle/apparel store
-const PRODUCTS = [
-  { id: "8001", name: "Premium Wireless Headphones", price: 149.99, category: "electronics" },
-  { id: "8002", name: "Organic Cotton T-Shirt", price: 34.99, category: "apparel" },
-  { id: "8003", name: "Leather Messenger Bag", price: 189.00, category: "accessories" },
-  { id: "8004", name: "Stainless Steel Water Bottle", price: 29.99, category: "lifestyle" },
-  { id: "8005", name: "Yoga Mat Pro", price: 79.99, category: "fitness" },
-  { id: "8006", name: "Bluetooth Speaker Mini", price: 59.99, category: "electronics" },
-  { id: "8007", name: "Running Shoes Elite", price: 129.00, category: "footwear" },
-  { id: "8008", name: "Smart Watch Band", price: 24.99, category: "accessories" },
-  { id: "8009", name: "Ceramic Coffee Mug Set", price: 44.99, category: "home" },
-  { id: "8010", name: "Bamboo Desk Organizer", price: 39.99, category: "office" },
-];
-
-const COLLECTIONS = [
-  { id: "9001", name: "Summer Sale 2025" },
-  { id: "9002", name: "New Arrivals" },
-  { id: "9003", name: "Best Sellers" },
-  { id: "9004", name: "Holiday Gift Guide" },
-];
-
-interface DemoEvent {
-  shopifyId: string;
-  topic: string;
-  author: string;
-  message: string;
-  diff: string | null;
-  hoursAgo: number;
-  minutesAgo?: number; // For fine-grained timing
-}
-
-function randomChoice<T>(arr: T[]): T {
-  return arr[Math.floor(Math.random() * arr.length)];
-}
-
-function createDemoEvents(): DemoEvent[] {
-  const events: DemoEvent[] = [];
-
-  // ============================================
-  // THE STORY: A Day at the Store
-  // ============================================
-  // Morning: Normal operations
-  // ~4 hours ago: Marcus accidentally drops price from $149 to $49
-  // ~3-4 hours ago: Sales tank (suspicious activity)
-  // ~2 hours ago: Sarah notices and fixes the price
-  // ~1-2 hours ago: Sales recover
-  // Recent: Normal activity continues
-  // ============================================
-
-  // === THE MISTAKE (4 hours ago) ===
-  events.push({
-    shopifyId: `gid://shopify/Product/${PRODUCTS[0].id}`,
-    topic: "products/update",
-    author: "Marcus Johnson",
-    message: `Marcus Johnson updated "${PRODUCTS[0].name}"`,
-    diff: JSON.stringify({
-      changes: [
-        { field: "price", label: "Price", old: "$149.99", new: "$49.99" },
-      ],
-      snapshot: { title: PRODUCTS[0].name, price: "49.99" },
-    }),
-    hoursAgo: 4,
-  });
-
-  // === THE FIX (2 hours ago) ===
-  events.push({
-    shopifyId: `gid://shopify/Product/${PRODUCTS[0].id}`,
-    topic: "products/update",
-    author: "Sarah Chen",
-    message: `Sarah Chen updated "${PRODUCTS[0].name}"`,
-    diff: JSON.stringify({
-      changes: [
-        { field: "price", label: "Price", old: "$49.99", new: "$149.99" },
-      ],
-      snapshot: { title: PRODUCTS[0].name, price: "149.99" },
-    }),
-    hoursAgo: 2,
-  });
-
-  // === MORNING ACTIVITY (Earlier in the day) ===
-
-  // Product description update
-  events.push({
-    shopifyId: `gid://shopify/Product/${PRODUCTS[2].id}`,
-    topic: "products/update",
-    author: "Emily Rodriguez",
-    message: `Emily Rodriguez updated "${PRODUCTS[2].name}"`,
-    diff: JSON.stringify({
-      changes: [
-        { field: "description", label: "Description", old: "Leather messenger bag", new: "Premium full-grain leather messenger bag with brass hardware. Fits 15\" laptop." },
-        { field: "price", label: "Price", old: "$189.00", new: "$169.00" },
-      ],
-      snapshot: { title: PRODUCTS[2].name, price: "169.00" },
-    }),
-    hoursAgo: 6,
-  });
-
-  // New product created
-  events.push({
-    shopifyId: `gid://shopify/Product/${PRODUCTS[4].id}`,
-    topic: "products/create",
-    author: "Jake Thompson",
-    message: `Jake Thompson created "${PRODUCTS[4].name}"`,
-    diff: JSON.stringify({
-      changes: [],
-      snapshot: { title: PRODUCTS[4].name, price: "79.99", status: "active" },
-    }),
-    hoursAgo: 7,
-  });
-
-  // Inventory adjustment by bot
-  events.push({
-    shopifyId: `gid://shopify/Product/${PRODUCTS[1].id}`,
-    topic: "inventory_levels/update",
-    author: "Inventory Sync",
-    message: `Inventory Sync adjusted inventory for "${PRODUCTS[1].name}"`,
-    diff: JSON.stringify({
-      changes: [
-        { field: "inventory", label: "Stock", old: "150", new: "12" },
-      ],
-      snapshot: { title: PRODUCTS[1].name, inventory: 12 },
-    }),
-    hoursAgo: 5,
-  });
-
-  // Status change
-  events.push({
-    shopifyId: `gid://shopify/Product/${PRODUCTS[3].id}`,
-    topic: "products/update",
-    author: "Sarah Chen",
-    message: `Sarah Chen updated "${PRODUCTS[3].name}"`,
-    diff: JSON.stringify({
-      changes: [
-        { field: "status", label: "Status", old: "Draft", new: "Active" },
-      ],
-      snapshot: { title: PRODUCTS[3].name, status: "active" },
-    }),
-    hoursAgo: 8,
-  });
-
-  // Collection created
-  events.push({
-    shopifyId: `gid://shopify/Collection/${COLLECTIONS[0].id}`,
-    topic: "collections/create",
-    author: "Emily Rodriguez",
-    message: `Emily Rodriguez created collection "${COLLECTIONS[0].name}"`,
-    diff: null,
-    hoursAgo: 9,
-  });
-
-  // Shopify Flow automation
-  events.push({
-    shopifyId: `gid://shopify/Product/${PRODUCTS[5].id}`,
-    topic: "products/update",
-    author: "Shopify Flow",
-    message: `Shopify Flow updated "${PRODUCTS[5].name}"`,
-    diff: JSON.stringify({
-      changes: [
-        { field: "tags", label: "Tags", old: "electronics", new: "electronics, on-sale, featured" },
-      ],
-      snapshot: { title: PRODUCTS[5].name, tags: ["electronics", "on-sale", "featured"] },
-    }),
-    hoursAgo: 3,
-  });
-
-  // === RECENT ACTIVITY (Last 2 hours) ===
-
-  // Image update
-  events.push({
-    shopifyId: `gid://shopify/Product/${PRODUCTS[6].id}`,
-    topic: "products/update",
-    author: "Jake Thompson",
-    message: `Jake Thompson updated "${PRODUCTS[6].name}"`,
-    diff: JSON.stringify({
-      changes: [
-        { field: "images", label: "Images", old: "2 images", new: "5 images" },
-      ],
-      snapshot: { title: PRODUCTS[6].name, imageCount: 5 },
-    }),
-    hoursAgo: 1,
-    minutesAgo: 30,
-  });
-
-  // Compare-at price (sale setup)
-  events.push({
-    shopifyId: `gid://shopify/Product/${PRODUCTS[7].id}`,
-    topic: "products/update",
-    author: "Sarah Chen",
-    message: `Sarah Chen updated "${PRODUCTS[7].name}"`,
-    diff: JSON.stringify({
-      changes: [
-        { field: "compareAtPrice", label: "Compare Price", old: "none", new: "$34.99" },
-        { field: "price", label: "Price", old: "$24.99", new: "$19.99" },
-      ],
-      snapshot: { title: PRODUCTS[7].name, price: "19.99", compareAtPrice: "34.99" },
-    }),
-    hoursAgo: 1,
-  });
-
-  // Inventory restock
-  events.push({
-    shopifyId: `gid://shopify/Product/${PRODUCTS[0].id}`,
-    topic: "inventory_levels/update",
-    author: "System/App",
-    message: `System/App adjusted inventory for "${PRODUCTS[0].name}"`,
-    diff: JSON.stringify({
-      changes: [
-        { field: "inventory", label: "Stock", old: "45", new: "42" },
-      ],
-    }),
-    hoursAgo: 0,
-    minutesAgo: 45,
-  });
-
-  // Very recent update
-  events.push({
-    shopifyId: `gid://shopify/Product/${PRODUCTS[8].id}`,
-    topic: "products/update",
-    author: "Marcus Johnson",
-    message: `Marcus Johnson updated "${PRODUCTS[8].name}"`,
-    diff: JSON.stringify({
-      changes: [
-        { field: "title", label: "Title", old: "Coffee Mug Set", new: "Ceramic Coffee Mug Set" },
-        { field: "vendor", label: "Vendor", old: "Generic", new: "Artisan Co." },
-      ],
-      snapshot: { title: PRODUCTS[8].name },
-    }),
-    hoursAgo: 0,
-    minutesAgo: 20,
-  });
-
-  // Collection update
-  events.push({
-    shopifyId: `gid://shopify/Collection/${COLLECTIONS[1].id}`,
-    topic: "collections/update",
-    author: "Emily Rodriguez",
-    message: `Emily Rodriguez updated collection "${COLLECTIONS[1].name}"`,
-    diff: null,
-    hoursAgo: 0,
-    minutesAgo: 10,
-  });
-
-  // === OLDER ACTIVITY (For Pro users viewing 7d range) ===
-
-  // Product deleted 2 days ago
-  events.push({
-    shopifyId: "gid://shopify/Product/9999",
-    topic: "products/delete",
-    author: "Jake Thompson",
-    message: `Jake Thompson deleted "Discontinued Winter Jacket"`,
-    diff: null,
-    hoursAgo: 48,
-  });
-
-  // Big inventory update 3 days ago
-  events.push({
-    shopifyId: `gid://shopify/Product/${PRODUCTS[2].id}`,
-    topic: "inventory_levels/update",
-    author: "Inventory Sync",
-    message: `Inventory Sync adjusted inventory for "${PRODUCTS[2].name}"`,
-    diff: JSON.stringify({
-      changes: [
-        { field: "inventory", label: "Stock", old: "0", new: "50" },
-      ],
-      snapshot: { title: PRODUCTS[2].name, inventory: 50 },
-    }),
-    hoursAgo: 72,
-  });
-
-  return events;
-}
-
-function createOrderEvents(): DemoEvent[] {
-  const orders: DemoEvent[] = [];
-  const now = new Date();
-
-  // Generate orders for the past 12 hours with a pattern
-  // More orders = more sales in the chart
-
-  // Order amounts vary by time of day
-  const getOrderPattern = (hoursAgo: number): { count: number; avgAmount: number } => {
-    // THE DIP: 4-5 hours ago (when wrong price was active)
-    if (hoursAgo >= 3.5 && hoursAgo <= 5) {
-      return { count: 2, avgAmount: 35 }; // Very few, cheap orders
-    }
-    // RECOVERING: 2-3.5 hours ago
-    if (hoursAgo >= 2 && hoursAgo < 3.5) {
-      return { count: 4, avgAmount: 65 };
-    }
-    // RECOVERED: After fix
-    if (hoursAgo >= 1 && hoursAgo < 2) {
-      return { count: 6, avgAmount: 95 };
-    }
-    // RECENT: Last hour - back to normal
-    if (hoursAgo < 1) {
-      return { count: 5, avgAmount: 110 };
-    }
-    // NORMAL: Before the incident
-    return { count: 5, avgAmount: 100 };
-  };
-
-  let orderNumber = 1001;
-
-  // Generate orders for each hour
-  for (let h = 12; h >= 0; h -= 0.5) {
-    const pattern = getOrderPattern(h);
-
-    for (let i = 0; i < pattern.count; i++) {
-      const amount = pattern.avgAmount + (Math.random() - 0.5) * pattern.avgAmount * 0.4;
-      const product = randomChoice(PRODUCTS);
-      const quantity = Math.ceil(Math.random() * 3);
-
-      const orderId = 1000000 + orderNumber;
-      const orderName = `#${orderNumber}`;
-      orderNumber++;
-
-      const minutesVariation = Math.random() * 25; // Spread within the half-hour
-
-      orders.push({
-        shopifyId: String(orderId),
-        topic: "ORDERS_CREATE",
-        author: "Customer",
-        message: `ðŸ’° Order ${orderName} - $${amount.toFixed(2)}`,
-        diff: JSON.stringify({
-          orderId,
-          orderName,
-          total: amount.toFixed(2),
-          subtotal: (amount * 0.9).toFixed(2),
-          currency: "USD",
-          status: "paid",
-          itemCount: quantity,
-          itemSummary: quantity === 1 ? product.name : `${quantity} items`,
-          items: [{
-            title: product.name,
-            variant: null,
-            quantity,
-            price: (amount / quantity).toFixed(2),
-            productId: parseInt(product.id),
-          }],
-          discounts: [],
-        }),
-        hoursAgo: h,
-        minutesAgo: minutesVariation,
-      });
-    }
-  }
-
-  return orders;
-}
-
-async function seed() {
-  console.log("ðŸŒ± Seeding demo data for screenshots & videos...\n");
-  console.log(`   Shop: ${SHOP}`);
-
-  // Clear existing data for this shop
-  const deleted = await db.eventLog.deleteMany({
-    where: { shop: SHOP },
-  });
-  console.log(`   Cleared ${deleted.count} existing events\n`);
-
-  const activityEvents = createDemoEvents();
-  const orderEvents = createOrderEvents();
-  const allEvents = [...activityEvents, ...orderEvents];
-  const now = new Date();
-
-  console.log("ðŸ“ Creating activity events...\n");
-
-  for (const event of activityEvents) {
-    const hoursMs = event.hoursAgo * 60 * 60 * 1000;
-    const minutesMs = (event.minutesAgo || 0) * 60 * 1000;
-    const timestamp = new Date(now.getTime() - hoursMs - minutesMs);
-
-    await db.eventLog.create({
-      data: {
-        shop: SHOP,
-        shopifyId: event.shopifyId,
-        topic: event.topic,
-        author: event.author,
-        message: event.message,
-        diff: event.diff,
-        timestamp,
-        webhookId: `demo-activity-${Date.now()}-${Math.random().toString(36).slice(2)}`,
-      },
-    });
-
-    const isBot = ["System/App", "Shopify Flow", "Inventory Sync"].includes(event.author);
-    const icon = isBot ? "ðŸ¤–" : "ðŸ‘¤";
-    const timeAgo = event.hoursAgo < 1
-      ? `${event.minutesAgo || 0}m ago`
-      : `${event.hoursAgo}h ago`;
-    console.log(`   ${icon} ${event.author.padEnd(16)} â”‚ ${event.topic.padEnd(22)} â”‚ ${timeAgo}`);
-  }
-
-  console.log(`\nðŸ’° Creating ${orderEvents.length} order events...\n`);
-
-  let orderCount = 0;
-  for (const event of orderEvents) {
-    const hoursMs = event.hoursAgo * 60 * 60 * 1000;
-    const minutesMs = (event.minutesAgo || 0) * 60 * 1000;
-    const timestamp = new Date(now.getTime() - hoursMs - minutesMs);
-
-    await db.eventLog.create({
-      data: {
-        shop: SHOP,
-        shopifyId: event.shopifyId,
-        topic: event.topic,
-        author: event.author,
-        message: event.message,
-        diff: event.diff,
-        timestamp,
-        webhookId: `demo-order-${Date.now()}-${Math.random().toString(36).slice(2)}`,
-      },
-    });
-    orderCount++;
-  }
-  console.log(`   Created ${orderCount} orders with sales pattern showing the price mistake impact`);
-
-  console.log(`\nâœ… Created ${allEvents.length} total events`);
-
-  console.log("\n" + "â•".repeat(60));
-  console.log("ðŸ“¸ SCREENSHOT & VIDEO CHECKLIST");
-  console.log("â•".repeat(60));
-  console.log(`
-1. THE HERO SHOT (Sales Impact):
-   - Access: ${process.env.SHOPIFY_APP_URL || 'https://insightops-app.fly.dev'}/app?demo=true
-   - Click on the price drop event (~4h ago)
-   - Show the before/after sales dip in the chart
-
-2. ACTIVITY FEED (Staff vs Bots):
-   - Mix of ðŸ‘¤ staff avatars and ðŸ¤– bot avatars
-   - Show variety: price changes, inventory, collections
-
-3. DIFF CARDS:
-   - Hover over events to show detailed change diffs
-   - Price: $149.99 â†’ $49.99 (the mistake)
-   - Price: $49.99 â†’ $149.99 (the fix)
-   - Inventory: 150 â†’ 12 (low stock alert)
-
-4. PRO FEATURES:
-   - Switch to "7d" or "30d" view
-   - Show longer history and Week-over-Week comparison
-
-ðŸ’¡ TIP: Use "Today" view for the price mistake story
-ðŸ’¡ TIP: Add ?demo=true to URL for fake chart data if no real orders
-`);
-}
-
-seed()
-  .catch((e) => {
-    console.error("âŒ Seed failed:", e);
-    process.exit(1);
-  })
-  .finally(async () => {
-    await db.$disconnect();
-  });

==========================================
BRANCH: v2/p0-pagination
==========================================
diff --git a/insightops/.ralphy/config.yaml b/insightops/.ralphy/config.yaml
new file mode 100644
index 0000000..a61148f
--- /dev/null
+++ b/insightops/.ralphy/config.yaml
@@ -0,0 +1,60 @@
+# Ralphy Configuration â€” StoreGuard V2
+# https://github.com/michaelshimeles/ralphy
+
+project:
+  name: "storeguard"
+  language: "TypeScript"
+  framework: "React Router v7 + Prisma + Shopify Polaris"
+  description: "Shopify store protection app â€” monitors changes that cost merchants money"
+
+commands:
+  test: "npx vitest run"
+  lint: "npx tsc --noEmit"
+  build: "npm run build"
+
+rules:
+  # Architecture
+  - "Read claude.md before making any changes â€” it is the project intelligence file"
+  - "Read PRD_V2.md for product context and feature requirements"
+  - "This is a Shopify embedded app using React Router v7 (SSR), Prisma ORM, PostgreSQL, Shopify Polaris Web Components"
+
+  # Code Quality
+  - "TypeScript strict mode â€” no 'any' types, no type assertions unless absolutely necessary"
+  - "Every new feature MUST have unit tests (Vitest). No exceptions."
+  - "Every webhook handler MUST ACK immediately (<500ms) and queue work to background jobs"
+  - "Never use mock/fake data. Show 'No data available' with helpful CTAs instead"
+  - "Handle errors gracefully â€” never crash, never show stack traces to users"
+
+  # Shopify Patterns
+  - "Follow the webhook processing pattern in claude.md section 'Critical Patterns'"
+  - "All new webhook subscriptions go in shopify.app.toml"
+  - "Use Shopify Polaris components for all UI â€” no custom CSS unless Polaris can't do it"
+  - "Check feature gates (free vs pro) before creating change events"
+
+  # UX Standards
+  - "Mobile-first design â€” test at 320px width minimum"
+  - "All alerts must include business context, not just 'X changed'"
+  - "Touch targets minimum 44px for mobile"
+  - "Empty states must be helpful, not blank"
+
+  # Database
+  - "Always use Prisma migrations â€” never raw SQL in application code"
+  - "Add proper indexes for any new query patterns"
+  - "Use cursor-based pagination for any list that could exceed 100 items"
+
+  # Security
+  - "Never log sensitive data (API keys, tokens, customer PII)"
+  - "Validate all webhook payloads with Shopify's authenticate.webhook()"
+  - "CRON_SECRET required for all cron/digest endpoints"
+
+  # Git
+  - "Small, focused commits â€” one concern per commit"
+  - "Commit messages: type(scope): description (e.g., feat(collections): add collection change monitoring)"
+  - "Never commit .env files or secrets"
+
+boundaries:
+  never_touch:
+    - "prisma/migrations/**"  # Don't modify existing migrations
+    - "*.lock"
+    - ".env*"
+    - "node_modules/**"
diff --git a/insightops/.ralphy/progress.txt b/insightops/.ralphy/progress.txt
new file mode 100644
index 0000000..7c396bd
--- /dev/null
+++ b/insightops/.ralphy/progress.txt
@@ -0,0 +1,2 @@
+# Ralphy Progress Log
+
diff --git a/insightops/CLAUDE.md b/insightops/CLAUDE.md
new file mode 100644
index 0000000..5e3f68d
--- /dev/null
+++ b/insightops/CLAUDE.md
@@ -0,0 +1,794 @@
+# StoreGuard - Project Intelligence File
+
+> This file is the single source of truth for AI assistants working on this project.
+> It tracks architecture decisions, progress, patterns, and critical context.
+
+## Project Overview
+
+**StoreGuard** is a Shopify app that monitors store changes and sends daily digest alerts.
+This is a rebuild/simplification of InsightOps, focusing on change detection and alerting.
+
+### Value Proposition
+Store owners lose revenue when unauthorized or accidental changes happen:
+- Prices silently changed
+- Products unpublished
+- Inventory hits zero without notice
+- Theme published unexpectedly
+
+StoreGuard watches for these changes and sends a daily digest email.
+
+---
+
+## Architecture Decision: Leverage Existing Codebase
+
+**Decision Date**: 2026-01-30
+
+### Why Leverage (Not Rebuild):
+1. **70% infrastructure reuse** - Auth, webhooks, job queue, sessions production-ready
+2. **StoreGuard is simpler** - No analytics, no charts, just detection + alerts
+3. **Proven patterns** - Webhook deduplication, retries, multi-tenancy already solved
+4. **Modern stack** - React Router v7, Prisma 6, TypeScript strict, Shopify latest API
+5. **Time to market** - Weeks vs. months for fresh build
+
+### What We Keep:
+- Shopify OAuth + App Bridge integration
+- Background job queue with retries (`jobQueue.server.ts`, `jobProcessor.server.ts`)
+- Prisma + PostgreSQL schema (evolving it)
+- Webhook infrastructure (`webhooks/*.tsx`)
+- Session storage (`shopify.server.ts`)
+
+### What We Remove:
+- Sales impact analysis (`productSales.server.ts`, `impactAnalysis.ts`)
+- ShopifyQL analytics (`analytics.server.ts`)
+- Sales charts in UI (`app._index.tsx` - significant portion)
+- Product sales aggregation (`ProductSalesPoint` model)
+
+### What We Add:
+- Theme webhook handler (`themes/publish`)
+- Daily digest generator + email templates
+- Settings page with toggles
+- `change_events` table (cleaner than EventLog for alerts)
+- Free/Pro feature gates with Stripe
+
+---
+
+## Tech Stack
+
+| Layer | Technology | Version | Notes |
+|-------|------------|---------|-------|
+| **Runtime** | Node.js | 20.19+ or 22.12+ | Required by Shopify CLI |
+| **Framework** | React Router v7 | 7.x | SSR + API routes |
+| **Language** | TypeScript | 5.9 | Strict mode enabled |
+| **Database** | PostgreSQL | 15+ | Via Prisma ORM |
+| **ORM** | Prisma | 6.16 | Type-safe queries |
+| **UI** | Shopify Polaris | Web Components | Official Shopify design |
+| **Icons** | Lucide React | 0.556 | Lightweight icon set |
+| **Testing** | Vitest | 4.0 | Unit + integration |
+| **Shopify API** | Admin API | 2025-10 | Latest stable |
+| **Email** | Resend | - | Modern email API, great deliverability |
+
+---
+
+## Database Schema (Target State)
+
+### Existing Models (Keep)
+```prisma
+model Session {
+  // Shopify OAuth sessions - DO NOT MODIFY
+}
+
+model ProductCache {
+  // Product name cache for delete events - KEEP
+}
+
+model WebhookJob {
+  // Background job queue - KEEP
+}
+
+model ShopSync {
+  // Product sync progress - KEEP
+}
+```
+
+### Modified Models
+```prisma
+model Shop {
+  id               String   @id @default(uuid())
+  shopifyDomain    String   @unique
+  plan             String   @default("free") // "free" | "pro"
+  alertEmail       String?
+  trackPrices      Boolean  @default(true)
+  trackVisibility  Boolean  @default(true)
+  trackInventory   Boolean  @default(true)
+  trackThemes      Boolean  @default(false) // Pro only
+  lowStockThreshold Int     @default(5) // Alert when inventory drops below this
+  instantAlerts    Boolean  @default(false) // Send alerts immediately (Pro only)
+  installedAt      DateTime @default(now())
+  uninstalledAt    DateTime?
+}
+
+model ChangeEvent {
+  id           String   @id @default(uuid())
+  shop         String
+  entityType   String   // "product" | "variant" | "theme"
+  entityId     String   // Shopify ID of the entity
+  eventType    String   // "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish"
+  resourceName String   // Human-readable name for display
+  beforeValue  String?  // Previous value
+  afterValue   String?  // New value
+  detectedAt   DateTime @default(now())
+  digestedAt   DateTime? // When included in daily digest
+  source       String   @default("webhook") // "webhook" | "sync_job" | "manual"
+  importance   String   @default("medium") // "high" | "medium" | "low"
+  groupId      String?  // For grouping related changes (bulk edits)
+  webhookId    String   @unique // Deduplication
+
+  @@index([shop])
+  @@index([shop, detectedAt])
+  @@index([shop, eventType])
+  @@index([digestedAt])
+  @@index([shop, entityType, entityId])
+}
+
+model ProductSnapshot {
+  id          String   @id // Shopify product ID
+  shop        String
+  title       String
+  status      String   // "active" | "draft" | "archived"
+  variants    String   // JSON: [{id, title, price, inventoryQuantity}]
+  updatedAt   DateTime @updatedAt
+
+  @@unique([shop, id])
+  @@index([shop])
+}
+```
+
+### Removed Models
+- `EventLog` - Replaced by `ChangeEvent` (cleaner, purpose-built)
+- `ProductSalesPoint` - Not needed (no analytics)
+
+---
+
+## Change Detection Rules (Explicit)
+
+### Price Change Detection (ISSUE #6)
+- **Rule**: `price_before !== price_after`
+- **Granularity**: One event per variant that changed
+- **Entity**: `variant`
+- **Importance**: Based on change magnitude (>=50% = high, >=20% = medium, <20% = low)
+- **Ignore**: No-op updates where Shopify sends same price
+
+### Visibility Change Detection (ISSUE #7)
+- **Rule**: Specific status transitions only
+- **Tracked Transitions**:
+  - `active -> draft` (hidden from store) - HIGH importance
+  - `active -> archived` (hidden from store) - HIGH importance
+  - `draft -> active` (visible on store) - MEDIUM importance
+  - `archived -> active` (visible on store) - MEDIUM importance
+- **Ignored**: `draft <-> archived` (both hidden, not meaningful)
+- **Entity**: `product`
+
+### Low Stock Detection (NEW)
+- **Rule**: Trigger when quantity crosses from above threshold to at/below threshold
+- **Threshold**: Configurable per shop (default: 5 units)
+- **Ignore**:
+  - Already below threshold (no repeated alerts)
+  - Quantity is zero (handled by inventory_zero)
+  - `null -> any` (unknown previous state)
+- **Entity**: `variant` (uses inventory_item_id)
+- **Importance**: Always `medium`
+- **Dedup**: 24-hour window per variant to prevent spam
+
+### Inventory Zero Detection (ISSUE #8)
+- **Rule**: Only trigger on transition `>0 -> 0`
+- **Ignore**:
+  - `0 -> 0` (no change)
+  - `negative -> 0` (edge case)
+  - `null -> 0` (unknown previous state)
+  - Low stock already triggered (prevents double alert)
+- **Entity**: `variant` (uses inventory_item_id)
+- **Importance**: Always `high`
+- **Dedup**: 24-hour window per variant to prevent spam
+
+### Theme Publish Detection (ISSUE #9)
+- **Rule**: Only when `theme.role === "main"` (became live theme)
+- **Entity**: `theme`
+- **Importance**: Always `high`
+- **Note**: themes/publish webhook only fires on publish, but we explicitly check role
+
+---
+
+## Sanity Checklist
+
+- [x] We know **what changed** (eventType)
+- [x] We know **what entity** (entityType: product/variant/theme)
+- [x] We know **which entity** (entityId)
+- [x] We know **where** (resourceName for human display)
+- [x] We know **when** (detectedAt)
+- [x] We can show **before/after** in human-readable way
+- [x] We log in a way that's **easy to query** (per shop, indexed)
+- [x] We have **importance** for future prioritization
+- [x] We have **groupId** for bulk edit correlation
+
+---
+
+## Implementation Plan (GitHub Issues Order)
+
+### Milestone 0: Project & Environment Setup âœ…
+- [x] Existing Shopify app scaffold (done in InsightOps)
+- [x] **ISSUE #1**: Rebrand to StoreGuard (app name, config, UI) - commit `0685820`
+- [x] **ISSUE #2**: Database schema migration (new models) - commit `0685820`
+
+### Milestone 1: Shopify Auth & Webhooks âœ…
+- [x] OAuth flow (existing)
+- [x] **ISSUE #3**: Shop model persistence on install - commit `bdaa3cb`
+- [x] **ISSUE #4**: Register `themes/publish` webhook - commit `0685820`
+
+### Milestone 2: State Snapshot Engine âœ…
+- [x] Product snapshot storage
+- [x] **ISSUE #5**: Migrate ProductSnapshot model
+
+### Milestone 3: Change Detection (Core Value) âœ…
+- [x] **ISSUE #6**: Price change detection (per-variant, importance scoring)
+- [x] **ISSUE #7**: Product visibility change detection (significant transitions only)
+- [x] **ISSUE #8**: Inventory zero detection (>0 -> 0 rule)
+- [x] **ISSUE #9**: Theme publish detection (role === "main" only)
+- [x] **ISSUE #10**: Recent Changes page (debug UI at /app/changes)
+
+### Milestone 4: Settings & Controls âœ…
+- [x] **ISSUE #11**: Settings page (Polaris UI)
+- [x] **ISSUE #12**: Free vs Pro feature gates
+
+### Milestone 5: Daily Digest (The Product) âœ…
+- [x] **ISSUE #13**: Daily digest generator
+- [x] **ISSUE #14**: Email template (HTML)
+- [x] **ISSUE #15**: Daily cron job (API endpoint)
+
+### Milestone 6: Billing & Monetization âœ…
+- [x] **ISSUE #16**: Stripe subscription integration ($19/month)
+
+### Milestone 7: Polish & Launch âœ…
+- [x] **ISSUE #17**: App uninstall cleanup (cancel Stripe sub, clean jobs)
+- [x] **ISSUE #18**: App Store submission prep (config, scopes, webhooks)
+
+---
+
+## File Structure (Target State)
+
+```
+insightops/                   # Will rename to storeguard/
+â”œâ”€â”€ app/
+â”‚   â”œâ”€â”€ routes/
+â”‚   â”‚   â”œâ”€â”€ _index/           # Auth page (keep)
+â”‚   â”‚   â”œâ”€â”€ app._index.tsx    # Main dashboard (simplify to alerts list)
+â”‚   â”‚   â”œâ”€â”€ app.settings.tsx  # NEW: Settings page
+â”‚   â”‚   â”œâ”€â”€ app.billing.tsx   # Billing (modify for Stripe)
+â”‚   â”‚   â”œâ”€â”€ api.digest.tsx    # NEW: Trigger daily digest
+â”‚   â”‚   â”œâ”€â”€ api.jobs.*.tsx    # Job processing (keep)
+â”‚   â”‚   â””â”€â”€ webhooks.*.tsx    # Webhook handlers (modify)
+â”‚   â”œâ”€â”€ services/
+â”‚   â”‚   â”œâ”€â”€ changeDetection.server.ts  # NEW: Core detection logic
+â”‚   â”‚   â”œâ”€â”€ dailyDigest.server.ts      # NEW: Digest generator
+â”‚   â”‚   â”œâ”€â”€ emailService.server.ts     # NEW: Email sending
+â”‚   â”‚   â”œâ”€â”€ jobProcessor.server.ts     # MODIFY: Process change events
+â”‚   â”‚   â”œâ”€â”€ jobQueue.server.ts         # KEEP
+â”‚   â”‚   â””â”€â”€ productSync.server.ts      # KEEP (simplified)
+â”‚   â”œâ”€â”€ utils/
+â”‚   â”‚   â””â”€â”€ featureGates.ts            # NEW: Free/Pro checks
+â”‚   â”œâ”€â”€ emails/
+â”‚   â”‚   â””â”€â”€ dailyDigest.tsx            # NEW: Email template
+â”‚   â”œâ”€â”€ db.server.ts          # Keep
+â”‚   â””â”€â”€ shopify.server.ts     # Keep
+â”œâ”€â”€ prisma/
+â”‚   â””â”€â”€ schema.prisma         # MODIFY: New models
+â””â”€â”€ shopify.app.toml          # MODIFY: Add themes/publish webhook
+```
+
+---
+
+## Critical Patterns & Conventions
+
+### 1. Webhook Processing Pattern
+```typescript
+// ALWAYS: ACK immediately, process in background
+export const action = async ({ request }) => {
+  const { shop, topic, payload } = await authenticate.webhook(request);
+
+  // Return immediately (< 5 seconds to avoid Shopify timeout)
+  await queueWebhookJob({ shop, topic, payload, delayMs: 2000 });
+  return new Response();
+};
+```
+
+### 2. Change Event Creation
+```typescript
+// ALWAYS: Check feature gates before creating events
+async function createChangeEvent(event: ChangeEventInput) {
+  const shop = await getShop(event.shop);
+
+  // Feature gate check
+  if (event.eventType === 'theme_publish' && shop.plan !== 'pro') {
+    return; // Theme tracking is Pro-only
+  }
+
+  if (event.eventType === 'price_change' && !shop.trackPrices) {
+    return; // User disabled price tracking
+  }
+
+  // Deduplication via webhookId
+  await prisma.changeEvent.upsert({...});
+}
+```
+
+### 3. Snapshot Comparison
+```typescript
+// ALWAYS: Compare against snapshot, then update snapshot
+async function detectChanges(product: Product, snapshot: ProductSnapshot) {
+  const changes: ChangeEvent[] = [];
+
+  // Price changes (per variant)
+  for (const variant of product.variants) {
+    const oldVariant = snapshot.variants.find(v => v.id === variant.id);
+    if (oldVariant && oldVariant.price !== variant.price) {
+      changes.push({
+        eventType: 'price_change',
+        beforeValue: oldVariant.price,
+        afterValue: variant.price,
+        // ...
+      });
+    }
+  }
+
+  // Status changes
+  if (product.status !== snapshot.status) {
+    changes.push({
+      eventType: 'status_change',
+      beforeValue: snapshot.status,
+      afterValue: product.status,
+      // ...
+    });
+  }
+
+  // Update snapshot AFTER detection
+  await updateSnapshot(product);
+
+  return changes;
+}
+```
+
+### 4. Free vs Pro Gates
+```typescript
+// Free Plan Limits
+const FREE_LIMITS = {
+  maxProducts: 50,
+  historyDays: 7,
+  themeTracking: false,
+};
+
+// Pro Plan Limits
+const PRO_LIMITS = {
+  maxProducts: Infinity,
+  historyDays: 90,
+  themeTracking: true,
+};
+```
+
+---
+
+## V1 Pricing Strategy (LOCKED)
+
+> **Rule**: Do NOT debate pricing until 10+ active Pro users or explicit "I'd pay more for X" feedback.
+
+### Free Plan â€” $0/month
+**Purpose**: Hook + trust + installs (Trojan Horse)
+
+| Feature | Limit |
+|---------|-------|
+| Products monitored | 50 |
+| Daily digest email | âœ… |
+| Price change tracking | âœ… |
+| Visibility change tracking | âœ… |
+| Low stock alerts | âœ… (configurable threshold) |
+| Inventory zero tracking | âœ… |
+| Alert history | 7 days |
+| Theme publish alerts | âŒ |
+| Instant alerts | âŒ |
+| Slack integration | âŒ |
+
+### Pro Plan â€” $19/month
+**Purpose**: Early revenue + validation
+
+| Feature | Limit |
+|---------|-------|
+| Products monitored | Unlimited |
+| Daily digest email | âœ… |
+| Price change tracking | âœ… |
+| Visibility change tracking | âœ… |
+| Low stock alerts | âœ… (configurable threshold) |
+| Inventory zero tracking | âœ… |
+| Alert history | 90 days |
+| Theme publish alerts | âœ… |
+| Instant alerts | âœ… (email immediately) |
+| Priority processing | âœ… |
+
+**Why $19**: Impulse-buy, no finance gate, comparable to utility apps, proves willingness to pay.
+
+### Explicitly NOT in V1
+- âŒ Slack integration (instant alerts are email only)
+- âŒ AI summaries
+- âŒ Sales/conversion analysis
+- âŒ Multiple pricing tiers
+- âŒ Annual plans
+
+### Future Upsell Path
+| Phase | Feature | Price |
+|-------|---------|-------|
+| V1 | Change Detection | $19 |
+| Phase 2 | AI Morning Briefing | $49 |
+| Phase 3 | Baseline Signals | $99 |
+| Phase 4 | Ops Copilot | $149+ |
+
+### 5. Daily Digest Query
+```typescript
+// Get undigested events from last 24 hours
+const events = await prisma.changeEvent.findMany({
+  where: {
+    shop: shopDomain,
+    digestedAt: null,
+    detectedAt: { gte: twentyFourHoursAgo }
+  },
+  orderBy: { detectedAt: 'desc' },
+  take: 50, // Cap for email sanity
+});
+
+// Mark as digested AFTER email sent successfully
+await prisma.changeEvent.updateMany({
+  where: { id: { in: events.map(e => e.id) } },
+  data: { digestedAt: new Date() }
+});
+```
+
+---
+
+## Environment Variables
+
+```env
+# Shopify (existing)
+SHOPIFY_API_KEY=xxx
+SHOPIFY_API_SECRET=xxx
+
+# Database (existing)
+DATABASE_URL=postgresql://...
+
+# Email Service
+RESEND_API_KEY=xxx
+DIGEST_FROM_EMAIL=alerts@storeguard.app
+
+# Cron/Digest Trigger
+CRON_SECRET=xxx               # Protects /api/digest endpoint
+
+# Stripe (NEW - replaces Shopify billing)
+STRIPE_SECRET_KEY=xxx
+STRIPE_WEBHOOK_SECRET=xxx
+STRIPE_PRO_PRICE_ID=price_xxx
+
+# Jobs
+JOB_PROCESSOR_SECRET=xxx      # Existing
+```
+
+---
+
+## Current Progress
+
+### Completed
+- [x] Initial InsightOps codebase reviewed
+- [x] Architecture decision made (leverage existing)
+- [x] claude.md created
+- [x] GitHub repository renamed to storeguard
+- [x] **Milestone 0 complete** - Rebrand + schema migration (commit `0685820`)
+  - Rebranded all files from InsightOps to StoreGuard
+  - Added Shop, ChangeEvent, ProductSnapshot models
+  - Added themes/publish webhook handler
+  - Updated all console log prefixes
+- [x] **Milestone 1 complete** - Shop persistence (commit `bdaa3cb`)
+  - Created shopService.server.ts with getOrCreateShop
+  - Shop record created on first app access
+  - Uninstall webhook marks shop as uninstalled
+- [x] **Milestones 2-3 complete** - Change Detection (core value)
+  - Created changeDetection.server.ts with all detection functions
+  - Integrated detection into jobProcessor.server.ts
+  - Enhanced ChangeEvent model with entityType, source, importance, groupId
+  - Explicit detection rules documented and implemented
+  - Created Recent Changes debug page at /app/changes
+  - Files changed:
+    - `prisma/schema.prisma` - Enhanced ChangeEvent model
+    - `app/services/changeDetection.server.ts` - Core detection logic
+    - `app/services/jobProcessor.server.ts` - Integration
+    - `app/services/shopService.server.ts` - Feature gates
+    - `app/routes/webhooks.themes.publish.tsx` - Theme detection
+    - `app/routes/app.changes.tsx` - Debug UI
+    - `app/routes/app.tsx` - Nav link to Changes
+- [x] **Milestone 4 complete** - Settings & Controls
+  - Created app.settings.tsx with full settings UI
+  - Email input for daily digest recipient
+  - Feature toggles for price, visibility, inventory, theme tracking
+  - Pro-only badge on theme tracking with disabled state for free plan
+  - Plan enforcement via shopService.server.ts (blocks trackThemes for free)
+  - Form validation with success/error feedback
+  - Added Settings link to navigation
+  - Files changed:
+    - `app/routes/app.settings.tsx` - New settings page
+    - `app/routes/app.tsx` - Added nav link
+
+- [x] **Milestone 5 complete** - Daily Digest (The Product)
+  - Created dailyDigest.server.ts with digest generation logic
+  - Created emailService.server.ts with Resend API integration
+  - HTML email template with grouped events by type
+  - API endpoint at /api/digest for cron trigger
+  - Authentication via CRON_SECRET header
+  - Files created:
+    - `app/services/dailyDigest.server.ts` - Digest generation
+    - `app/services/emailService.server.ts` - Email sending via Resend
+    - `app/routes/api.digest.tsx` - Cron-triggered endpoint
+
+- [x] **Milestone 6 complete** - Billing & Monetization
+  - Created stripeService.server.ts with Stripe API integration
+  - Stripe Checkout for Pro upgrade ($19/month)
+  - Customer Portal for subscription management
+  - Webhook handler at /api/stripe/webhook for subscription events
+  - Handles: checkout.session.completed, subscription created/updated/deleted
+  - App Bridge compatible with window.open for iframe escape
+  - Files created:
+    - `app/services/stripeService.server.ts` - Stripe API service
+    - `app/routes/api.billing.checkout.tsx` - Checkout/Portal session creation
+    - `app/routes/api.stripe.webhook.tsx` - Stripe webhook handler
+  - Files modified:
+    - `app/routes/app.settings.tsx` - Added billing buttons and states
+
+- [x] **Milestone 7 complete** - Polish & Launch
+  - Enhanced uninstall webhook to cancel Stripe subscriptions
+  - Clean up pending webhook jobs on uninstall
+  - Updated shopify.app.toml:
+    - App name: StoreGuard
+    - App URL: storeguard-app.fly.dev
+    - Added themes/publish webhook
+    - Cleaned up scopes (read_inventory, read_products, read_themes)
+  - Files modified:
+    - `app/routes/webhooks.app.uninstalled.tsx` - Stripe cancellation + job cleanup
+    - `app/services/stripeService.server.ts` - Added cancelShopSubscription
+    - `shopify.app.toml` - App config for submission
+
+### V1.1 Enhancements (2026-02-03)
+- [x] **Low Stock Alerts** - Configurable threshold (default: 5 units)
+  - New `lowStockThreshold` field in Shop model
+  - New `inventory_low` event type
+  - Triggers when stock drops below threshold
+  - Settings UI with threshold input
+- [x] **Instant Alerts (Pro only)** - Email immediately on change detection
+  - New `instantAlerts` field in Shop model
+  - Sends email right away instead of waiting for daily digest
+  - Clean instant alert email template
+  - Pro-only feature gate
+- Files changed:
+  - `prisma/schema.prisma` - Added lowStockThreshold, instantAlerts
+  - `app/services/shopService.server.ts` - New settings + feature gates
+  - `app/services/changeDetection.server.ts` - detectLowStock function + instant alert integration
+  - `app/services/emailService.server.ts` - Instant alert emails
+  - `app/services/dailyDigest.server.ts` - inventory_low support
+  - `app/services/jobProcessor.server.ts` - Low stock detection call
+  - `app/routes/app.settings.tsx` - Threshold input + instant alerts toggle
+  - `app/routes/app.changes.tsx` - inventory_low display
+
+### Completed
+- All milestones complete! ðŸŽ‰
+- V1.1 enhancements complete!
+
+### Blocked
+- None
+
+### Known Issues
+- None
+
+---
+
+## Key Decisions Log
+
+| Date | Decision | Rationale |
+|------|----------|-----------|
+| 2026-01-30 | Leverage existing codebase | 70% reuse, faster time to market |
+| 2026-01-30 | Stripe for billing | More flexible than Shopify billing, supports annual plans |
+| 2026-01-30 | Separate ChangeEvent model | Cleaner than repurposing EventLog, purpose-built for alerts |
+| 2026-01-30 | Resend for email | User confirmed - modern, developer-friendly, great deliverability |
+| 2026-01-30 | Stripe for billing | User confirmed - more flexible than Shopify billing |
+| 2026-01-30 | UTC for digest timezone | User confirmed - simpler for V1, can add timezone later |
+| 2026-02-03 | Add low stock alerts | Market research: "zero only" is too late, all competitors have threshold alerts |
+| 2026-02-03 | Add instant alerts (Pro) | Market research: many competitors offer instant + scheduled, Pro feature differentiator |
+
+---
+
+## Confirmed Decisions
+
+| Question | Decision | Date |
+|----------|----------|------|
+| Email Provider | **Resend** | 2026-01-30 |
+| Billing | **Stripe** | 2026-01-30 |
+| Digest Timezone | **UTC** (V1) | 2026-01-30 |
+| Cron Job | **API endpoint** (`/api/digest`) | 2026-02-01 |
+
+---
+
+## Files Deleted (Cleanup Complete) âœ…
+
+Removed on 2026-02-01:
+- ~~`app/services/analytics.server.ts`~~
+- ~~`app/services/productSales.server.ts`~~
+- ~~`app/utils/impactAnalysis.ts`~~
+- ~~`app/utils/impactAnalysis.test.ts`~~
+- ~~`app/routes/api.product-sales.tsx`~~
+- ~~`app/routes/api.product-impact.tsx`~~
+- ~~`app/routes/api.debug-sales.tsx`~~
+- Removed `ProductSalesPoint` model from schema
+
+Note: `EventLog` model still in use by jobProcessor/productSync for baseline tracking. Can be refactored later.
+
+---
+
+## Testing Strategy
+
+### Unit Tests (Vitest)
+- Change detection logic
+- Feature gate enforcement
+- Digest grouping logic
+
+### Integration Tests
+- Webhook processing end-to-end
+- Email template rendering
+
+### Manual Testing
+- Shopify dev store with test products
+- Trigger webhooks via Shopify admin
+- Verify digest email delivery
+
+---
+
+## Launch Checklist
+
+### Development Complete
+- [x] All 18 issues completed (Milestones 0-7)
+- [x] Privacy policy page exists (at /privacy route)
+- [x] GDPR webhooks implemented (customers/data_request, customers/redact, shop/redact)
+- [x] Uninstall cleanup with Stripe cancellation
+- [x] App config updated (shopify.app.toml)
+- [x] Stripe products created ($19/month Pro plan)
+- [x] UX polish: removed emojis, cleaned up metadata, fixed toast positioning
+
+### Production Deployment (Render) - DONE 2026-02-02
+- [x] Production database provisioned (PostgreSQL on Render)
+- [x] Production environment variables configured
+- [x] Stripe webhook URL configured (`https://storeguard-app.onrender.com/api/stripe/webhook`)
+- [x] Shopify app deployed (`npm run deploy --force`)
+- [x] App live at: https://storeguard-app.onrender.com
+- [x] Change detection working (tested with price change)
+
+### Remaining Tasks
+- [ ] **Add CRON_SECRET to GitHub Secrets** - Go to GitHub repo â†’ Settings â†’ Secrets â†’ Actions â†’ Add `CRON_SECRET` (get value from Render environment)
+- [ ] **Test daily digest** - Manually trigger: `curl -X POST https://storeguard-app.onrender.com/api/digest -H "Authorization: Bearer YOUR_CRON_SECRET"`
+- [ ] **Email deliverability** - If you have a domain, add to Resend with SPF/DKIM/DMARC
+- [ ] App listing copy written
+- [ ] Screenshots captured (Settings, Digest email, Changes page)
+- [ ] Support email configured
+- [ ] App submitted to Shopify
+- [ ] Marketing site live
+
+---
+
+## V2 â€” Store Protection Expansion
+
+> **Read PRD_V2.md for full product requirements. This section covers what changed for V2.**
+
+### V2 Identity (CRITICAL)
+StoreGuard is a **store protection app**, NOT a staff attribution tool. We do NOT:
+- Track who made changes (webhooks don't include user IDs for public apps)
+- Do sales causality analysis
+- Do "blame game" features
+- Show analytics or charts
+
+We DO: Monitor changes that cost merchants money and alert with business context.
+
+### V2 New Monitoring Types
+
+**Collections** (scope: read_products â€” already have)
+- `collections/create` â€” new collection created
+- `collections/update` â€” products added/removed, rules changed
+- `collections/delete` â€” collection deleted (breaks links)
+- Entity: `collection`
+- Event types: `collection_products_changed`, `collection_deleted`
+
+**Discounts** (NEW scope needed: read_discounts)
+- `discounts/create` â€” new discount code created
+- `discounts/update` â€” discount modified
+- `discounts/delete` â€” discount deleted
+- Entity: `discount`
+- Event types: `discount_created`, `discount_changed`, `discount_deleted`
+- **Pro only**
+
+**Domains** (no scope needed)
+- `domains/create` â€” domain added
+- `domains/update` â€” domain changed
+- `domains/destroy` â€” domain removed
+- Entity: `domain`
+- Event types: `domain_changed`, `domain_removed`
+- **Pro only**
+
+**App Permissions** (no scope needed)
+- `app/scopes_update` â€” any installed app changes its permissions
+- Entity: `app`
+- Event type: `app_permissions_changed`
+- **Pro only**
+
+### V2 Schema Additions
+```prisma
+// Extend ChangeEvent entityType to include: "collection" | "discount" | "domain" | "app"
+// Extend eventType to include new types above
+// Add contextData Json? field for business context
+// Add revenueImpact Decimal? field for money saved calculation
+
+// New: Money Saved tracking
+model MoneyImpact {
+  id                String   @id @default(uuid())
+  shop              String
+  changeEventId     String   @unique
+  estimatedSavings  Decimal
+  calculationMethod String   // "price_error" | "stockout" | "visibility"
+  calculatedAt      DateTime @default(now())
+  
+  @@index([shop])
+}
+
+// Extend Shop model:
+// trackCollections  Boolean @default(true)
+// trackDiscounts    Boolean @default(false) // Pro only
+// trackDomains      Boolean @default(false) // Pro only
+// trackAppPermissions Boolean @default(false) // Pro only
+```
+
+### V2 Feature Gates
+```typescript
+const FREE_LIMITS = {
+  maxProducts: 50,
+  historyDays: 7,
+  themeTracking: false,
+  collectionTracking: true,  // Free gets this
+  discountTracking: false,   // Pro only
+  domainTracking: false,     // Pro only
+  appPermissionTracking: false, // Pro only
+  instantAlerts: false,
+  moneySavedDashboard: false,
+};
+
+const PRO_LIMITS = {
+  maxProducts: Infinity,
+  historyDays: 90,
+  themeTracking: true,
+  collectionTracking: true,
+  discountTracking: true,
+  domainTracking: true,
+  appPermissionTracking: true,
+  instantAlerts: true,
+  moneySavedDashboard: true,
+};
+```
+
+### V2 Context-Rich Alerts (IMPORTANT)
+Every alert MUST include business context. Examples:
+- Price: "Blue Jacket dropped from $89 to $8.90 (90% decrease) â€” probably a typo"
+- Inventory: "Black Hoodie hit zero stock â€” you've been selling 8/day"
+- Visibility: "Red Sneakers went active â†’ draft â€” no longer visible (sold 5 yesterday)"
+- Collection: "3 products removed from Featured collection"
+- Theme: "Theme 'Minimal v2' went live at 3:17 AM, replacing 'Dawn Custom'"
+- Discount: "Your Black Friday 50% off code was just deleted"
+- App: "Klaviyo just expanded permissions to access your orders"
+
+### V2 Linear Issues
+Project: StoreGuard V2
+BOT-5 through BOT-19 â€” see Linear for details.
diff --git a/insightops/PRD_V2.md b/insightops/PRD_V2.md
new file mode 100644
index 0000000..07c1a83
--- /dev/null
+++ b/insightops/PRD_V2.md
@@ -0,0 +1,356 @@
+# StoreGuard PRD V2
+**A security camera for Shopify stores that catches money-costing changes before they add up**
+
+---
+
+## 1. Product Vision
+
+### What It Is
+StoreGuard is the only app that comprehensively monitors your entire Shopify store for changes that can cost you money. Think "security camera for your business" â€” it watches everything, alerts you immediately when something dangerous happens, and keeps a permanent record.
+
+### Who It's For
+Every single Shopify store owner (5M+ stores). Not just multi-staff stores. Solo owners make typos. Apps make silent changes. Webhooks fail. Things slip through cracks. Everyone needs this.
+
+### The "Why Now"
+**The Problem**: Store owners wake up to disasters. Bestseller priced at $5 instead of $50. Homepage collection emptied by a broken app. Theme replaced overnight. Stock ran out days ago. Each incident costs hundreds to thousands in lost revenue.
+
+**The Solution**: StoreGuard catches these issues the moment they happen and tells you exactly what changed, why it matters, and how much money is at stake.
+
+**The Hook**: "StoreGuard protected $2,847 this month by catching 6 issues before they cost you money."
+
+---
+
+## 2. What We Monitor & Why
+
+### Revenue Protection
+**Price Changes** (products/update)
+- Why: Accidental price drops cost immediate revenue. Apps can silently modify prices.
+- Context: "Your #1 seller dropped from $59 to $5.90 â€” 90% drop, likely an error"
+
+**Inventory Depletion** (inventory_levels/update)
+- Zero Stock: Why: You can't sell what you don't have. Stockouts = lost sales.
+- Low Stock: Why: Running low on bestsellers risks stockouts during peak hours.
+- Context: "Your top seller has 0 stock â€” you sold 12 yesterday" / "Winter Coat down to 3 units â€” restock before weekend rush?"
+
+### Store Integrity
+**Product Visibility** (products/update)
+- Why: Hidden products generate zero revenue. Mass status changes often indicate app bugs.
+- Context: "Blue Jacket went from active â†’ draft â€” no longer visible on your store"
+
+**Collection Changes** (collections/update, collections/delete)
+- Why: Products removed from collections become invisible on storefront navigation. Deleted collections break site structure.
+- Context: "3 products removed from Homepage collection â€” customers can't find them" / "Winter Sale collection deleted â€” broken links on your site"
+
+**Theme Publishes** (themes/publish)
+- Why: Unintended theme changes can break checkout, hide products, or ruin site design.
+- Context: "Your live theme was replaced at 3:17 AM â€” probably not intentional"
+
+### Security & Control
+**App Permission Changes** (app/scopes_update)
+- Why: Apps expanding permissions without notice is a red flag. New access to customer data, orders, or products requires your attention.
+- Context: "Klaviyo just expanded permissions to access your orders â€” review what they can do now"
+
+**Domain Changes** (domains/create, domains/update, domains/destroy)
+- Why: Domain changes can break SSL, redirect traffic, or take your store offline.
+- Context: "Primary domain changed from yourstore.com to yourstore.myshopify.com â€” customers may get confused"
+
+---
+
+## 3. Context-Rich Alerts
+
+**The Differentiator**: Every alert includes business impact that makes you ACT, not just read.
+
+### Price Change Examples
+- **Bad**: "Product price changed"
+- **Good**: "Blue Winter Jacket price dropped from $89 to $8.90 (90% decrease) â€” probably a typo, fix before customers notice"
+- **Context Added**: Product name, old price, new price, percentage change, sales velocity
+
+### Visibility Change Examples
+- **Bad**: "Product status updated"
+- **Good**: "Red Sneakers went from active â†’ draft â€” no longer visible on your store (sold 5 yesterday)"
+- **Context Added**: Product name, status transition, sales history, revenue impact
+
+### Inventory Examples
+- **Bad**: "Inventory updated"
+- **Good**: "Black Hoodie hit zero stock â€” you've been selling 8/day, lost sales start now"
+- **Context Added**: Product name, previous quantity, sales velocity, urgency level
+
+### Collection Examples
+- **Bad**: "Collection updated"
+- **Good**: "3 products removed from Featured collection â€” customers landing on /collections/featured won't see them"
+- **Context Added**: Collection name, number of products affected, customer impact
+
+### Theme Examples
+- **Bad**: "Theme published"
+- **Good**: "Theme 'Minimal v2' went live at 3:17 AM, replacing 'Dawn Custom' â€” double-check your site looks right"
+- **Context Added**: Theme names, publish time, suggestion for action
+
+---
+
+## 4. The "Money Saved" Engine
+
+**Purpose**: Justify $19/month forever by quantifying protection value.
+
+### Calculation Algorithm
+For each caught issue, estimate revenue impact using:
+
+**Price Error Impact**:
+```
+Daily Sales Rate Ã— Hours Until Discovery Ã— Price Difference
+Example: Bestseller at $5 instead of $50
+- Normal: 10 sales/day = 0.4 sales/hour
+- Lost Revenue: 0.4 Ã— 2 hours Ã— $45 difference = $36 saved
+```
+
+**Stock-Out Impact**:
+```
+Daily Sales Rate Ã— Hours Out of Stock Ã— Average Order Value
+Example: Popular item hits zero, would stay out 24 hours
+- Normal: 5 sales/day Ã— 1 day Ã— $35 AOV = $175 saved
+```
+
+**Visibility Impact**:
+```
+Product Sales Rate Ã— Days Hidden Ã— Average Order Value
+Example: Product hidden from homepage for 1 day
+- Normal: 3 sales/day Ã— 1 day Ã— $40 AOV = $120 saved
+```
+
+### Display Strategy
+- **Monthly Counter**: "StoreGuard protected $2,847 this month"
+- **Per-Alert**: "This alert saved you ~$156 by catching it early"
+- **Historical**: "Total protected since install: $8,491"
+
+### Conservative Estimation
+Always underestimate. Better to surprise upward than disappoint. Use 50% of calculated impact to account for natural discovery timing.
+
+---
+
+## 5. Current State & Critical Fixes
+
+### V1 Broken Things (Must Fix)
+**Scalability Issues**:
+- Hard 1,000 product limit breaks large stores
+- 250 order limit makes sales data useless for high-volume merchants
+- No pagination handling causes crashes
+
+**Mock Data Problem**:
+- Fake random sales numbers destroy merchant trust
+- Must show "No data" instead of fabricated metrics
+
+**Webhook Timeouts**:
+- 2-second inline delays will cause Shopify to retry/delist us
+- Must use background job queue for all processing
+
+**Naive Attribution**:
+- Correlation â‰  causation in sales impact analysis
+- Need time-of-day normalization and better baselines
+
+---
+
+## 6. V2 Feature Priorities
+
+### P0: Fix the Broken (Week 1)
+- Remove all mock data generation
+- Implement proper pagination for products/orders
+- Background job queue for webhook processing
+- Fix product sync to handle unlimited products
+
+### P1: New Monitoring Capabilities (Weeks 2-4)
+- Collections webhook monitoring (products removed/added, collections deleted)
+- Discount code monitoring (codes created/changed/deleted)
+- App permission monitoring (scope expansions)
+- Domain change monitoring
+- Low stock threshold alerts (configurable per shop)
+
+### P2: Context Engine & Retention (Weeks 5-8)
+- Business context calculation for all alert types
+- Money saved engine with conservative impact estimation
+- Instant alerts for Pro users (email immediately)
+- Historical "money saved" dashboard
+- Mobile-optimized email templates
+
+---
+
+## 7. Technical Specifications
+
+### New Webhook Subscriptions Needed
+- `collections/create` â€” New collection monitoring
+- `collections/update` â€” Collection changes (products added/removed)
+- `collections/delete` â€” Collection deletion detection
+- `discounts/create` â€” New discount tracking
+- `discounts/update` â€” Discount changes
+- `discounts/delete` â€” Discount deletion
+- `domains/create` â€” Domain additions
+- `domains/update` â€” Domain changes
+- `domains/destroy` â€” Domain removal
+- `app_scopes/update` â€” App permission changes
+
+### New Scopes Required
+- `read_discounts` â€” Access discount codes for monitoring
+- (collections, domains, app_scopes don't need explicit scopes)
+
+### Schema Additions
+```sql
+-- Extend ChangeEvent for new types
+ALTER TABLE ChangeEvent ADD COLUMN contextData JSONB;
+ALTER TABLE ChangeEvent ADD COLUMN revenueImpact DECIMAL(10,2);
+ALTER TABLE ChangeEvent ADD COLUMN severity VARCHAR(20); -- 'critical', 'high', 'medium', 'low'
+
+-- Add money saved tracking
+CREATE TABLE MoneyImpact (
+  id UUID PRIMARY KEY,
+  shop VARCHAR NOT NULL,
+  changeEventId UUID REFERENCES ChangeEvent(id),
+  estimatedSavings DECIMAL(10,2) NOT NULL,
+  calculationMethod VARCHAR(50) NOT NULL,
+  calculatedAt TIMESTAMP DEFAULT NOW()
+);
+
+-- Low stock configuration
+ALTER TABLE Shop ADD COLUMN lowStockThreshold INTEGER DEFAULT 5;
+ALTER TABLE Shop ADD COLUMN trackCollections BOOLEAN DEFAULT TRUE;
+ALTER TABLE Shop ADD COLUMN trackDiscounts BOOLEAN DEFAULT FALSE; -- Pro only
+ALTER TABLE Shop ADD COLUMN trackDomains BOOLEAN DEFAULT FALSE; -- Pro only
+ALTER TABLE Shop ADD COLUMN trackAppPermissions BOOLEAN DEFAULT FALSE; -- Pro only
+```
+
+### Context Data Sources
+- **Product Performance**: Last 30-day sales velocity from orders API
+- **Collection Traffic**: Referral data from Analytics API (if available)
+- **Business Hours**: Infer peak hours from historical order timestamps
+- **Price History**: Track in ProductSnapshot for trend analysis
+- **Inventory Velocity**: Calculate from inventory_levels/update frequency
+
+---
+
+## 8. Monetization Strategy
+
+### Free Plan: The Hook ($0/month)
+**Limits**:
+- 50 products monitored
+- Core monitoring only (prices, visibility, inventory, basic themes)
+- Daily digest emails only
+- 7-day alert history
+
+**Purpose**: Get merchants hooked, build trust, prove value
+
+### Pro Plan: The Revenue ($19/month)
+**Limits**:
+- Unlimited products monitored
+- All monitoring types (collections, discounts, domains, app permissions)
+- Instant alerts (email immediately)
+- 90-day alert history
+- Money saved dashboard
+- Priority support
+
+**Upgrade Triggers**:
+- Hit 50 product limit â†’ "Upgrade to monitor your full catalog"
+- Miss a collection/discount change â†’ "Pro monitoring would have caught this"
+- Want instant alerts â†’ "Get alerts immediately, not just daily"
+- Want money saved tracking â†’ "See exactly how much we've protected"
+
+### Value Justification
+- **Customer pays**: $19/month = $228/year
+- **Customer saves**: One caught pricing error = $200-2000 saved
+- **ROI**: Pays for itself with first major catch
+
+---
+
+## 9. Go-to-Market Strategy
+
+### App Store Positioning
+**Primary Keywords**: "store monitoring", "change alerts", "price protection", "inventory alerts"
+**Secondary Keywords**: "security", "store safety", "mistake prevention", "revenue protection"
+
+**Avoid**: "analytics", "insights", "activity log" (too generic/competitive)
+
+### Emotional Hook
+**Fear**: "What changed in your store while you were sleeping?"
+**Relief**: "StoreGuard watches your store 24/7 so you don't have to"
+**Pride**: "Protected $2,847 this month by catching issues early"
+
+### Landing Page Copy
+**Headline**: "The security camera your Shopify store needs"
+**Subhead**: "Catch price errors, inventory issues, and store changes before they cost you money"
+**Social Proof**: "Protected over $1.2M for 2,000+ stores"
+
+### Content Marketing
+- **Blog**: "5 Shopify changes that cost merchants $10,000 overnight"
+- **Case Study**: "How StoreGuard caught a $3,000 pricing error in 12 minutes"
+- **Guides**: "Complete checklist: What to monitor in your Shopify store"
+
+---
+
+## 10. Metrics & Milestones
+
+### 3-Month Build Timeline
+**Month 1**: Fix V1 issues, core monitoring expansion
+- Remove scalability blocks
+- Add collections, discounts monitoring
+- Background job queue implementation
+
+**Month 2**: Context engine and Pro features
+- Money saved calculation engine
+- Instant alerts for Pro users
+- Advanced context for all alert types
+
+**Month 3**: Polish and growth features
+- Mobile email optimization
+- Historical money saved dashboard
+- Onboarding flow improvement
+
+### Success Metrics
+**Technical**:
+- Zero webhook timeouts (100% success rate)
+- <200ms average alert generation time
+- Support for 100,000+ product stores
+
+**Business**:
+- 1,000 free installs in first 3 months
+- 10% free-to-Pro conversion rate
+- $5,000 MRR by month 6
+- 4.8+ App Store rating
+
+**Validation**:
+- Merchant feedback: "This saved me $___"
+- Support tickets <5% of installs
+- Uninstall rate <10% after 30 days
+
+### Monthly Targets (Solo Dev)
+- **Month 1**: 50 installs, 2 Pro subscribers
+- **Month 2**: 200 installs, 15 Pro subscribers
+- **Month 3**: 500 installs, 50 Pro subscribers
+- **Month 6**: 1,500 installs, 150 Pro subscribers ($2,850 MRR)
+
+### Key Assumptions to Validate
+- Merchants will pay $19/month for comprehensive monitoring
+- Context-rich alerts drive higher engagement than basic notifications
+- "Money saved" messaging resonates more than "issues caught"
+- Solo merchants value protection as much as multi-staff stores
+
+---
+
+## Launch Readiness Checklist
+
+### Technical
+- [ ] All V1 scalability issues resolved
+- [ ] All 8 monitoring types implemented and tested
+- [ ] Money saved calculation working accurately
+- [ ] Email deliverability optimized
+- [ ] Error handling and edge cases covered
+
+### Business
+- [ ] Stripe Pro plan configured ($19/month)
+- [ ] App Store listing optimized with screenshots
+- [ ] Support documentation created
+- [ ] Privacy policy and terms updated
+- [ ] GDPR compliance verified
+
+### Marketing
+- [ ] Landing page live with social proof
+- [ ] First 3 blog posts published
+- [ ] Email sequences for onboarding and conversion
+- [ ] App Store keywords researched and implemented
+
+**Success Definition**: When a store owner installs StoreGuard and says "I wish I had this sooner" within 24 hours.
\ No newline at end of file
diff --git a/insightops/app/services/productSync.server.ts b/insightops/app/services/productSync.server.ts
index cf87dd8..6e95349 100644
--- a/insightops/app/services/productSync.server.ts
+++ b/insightops/app/services/productSync.server.ts
@@ -23,7 +23,13 @@ interface ProductNode {
   status: string;
   tags: string[];
   images: { edges: Array<{ node: { id: string } }> };
-  variants: { edges: Array<{ node: ProductVariant }> };
+  variants: {
+    edges: Array<{ node: ProductVariant }>;
+    pageInfo: {
+      hasNextPage: boolean;
+      endCursor: string | null;
+    };
+  };
   options: ProductOption[];
 }
 
@@ -31,6 +37,12 @@ interface ProductEdge {
   node: ProductNode;
 }
 
+interface ThrottleStatus {
+  maximumAvailable: number;
+  currentlyAvailable: number;
+  restoreRate: number;
+}
+
 interface ProductsResponse {
   data?: {
     products: {
@@ -41,6 +53,95 @@ interface ProductsResponse {
       };
     };
   };
+  extensions?: {
+    cost: {
+      requestedQueryCost: number;
+      actualQueryCost: number;
+      throttleStatus: ThrottleStatus;
+    };
+  };
+  errors?: Array<{ message: string; extensions?: { code: string } }>;
+}
+
+interface VariantsResponse {
+  data?: {
+    product: {
+      variants: {
+        edges: Array<{ node: ProductVariant }>;
+        pageInfo: {
+          hasNextPage: boolean;
+          endCursor: string | null;
+        };
+      };
+    };
+  };
+  extensions?: {
+    cost: {
+      requestedQueryCost: number;
+      actualQueryCost: number;
+      throttleStatus: ThrottleStatus;
+    };
+  };
+  errors?: Array<{ message: string; extensions?: { code: string } }>;
+}
+
+/** Batch size for product pagination (Shopify max is 250) */
+export const PRODUCTS_PER_PAGE = 250;
+
+/** Batch size for variant pagination within a product */
+export const VARIANTS_PER_PAGE = 100;
+
+/**
+ * Minimum available query cost before we pause to let the bucket refill.
+ * Shopify's default bucket is 1000 points with 50/sec restore rate.
+ * A products query with 250 products costs ~500+ points.
+ */
+const THROTTLE_THRESHOLD = 200;
+
+/**
+ * Wait for Shopify's rate limit bucket to refill enough for the next query.
+ * Returns immediately if sufficient budget is available.
+ */
+export async function waitForRateLimit(
+  throttleStatus: ThrottleStatus | undefined,
+  queryCost: number
+): Promise<void> {
+  if (!throttleStatus) return;
+
+  const { currentlyAvailable, restoreRate } = throttleStatus;
+
+  if (currentlyAvailable < Math.max(queryCost, THROTTLE_THRESHOLD)) {
+    const pointsNeeded = queryCost - currentlyAvailable;
+    const waitSeconds = Math.ceil(pointsNeeded / restoreRate) + 1;
+    console.log(
+      `[StoreGuard] Rate limit: ${currentlyAvailable} points available, need ~${queryCost}. Waiting ${waitSeconds}s...`
+    );
+    await new Promise((resolve) => setTimeout(resolve, waitSeconds * 1000));
+  }
+}
+
+/**
+ * Check if a GraphQL response contains a THROTTLED error and extract retry-after info.
+ * Returns the number of ms to wait, or 0 if not throttled.
+ */
+export function getThrottleRetryMs(
+  response: ProductsResponse | VariantsResponse
+): number {
+  if (!response.errors) return 0;
+
+  const throttled = response.errors.some(
+    (e) => e.extensions?.code === "THROTTLED"
+  );
+  if (!throttled) return 0;
+
+  // Use cost info to calculate wait, or default to 2s
+  const restoreRate = response.extensions?.cost?.throttleStatus?.restoreRate ?? 50;
+  const needed = response.extensions?.cost?.requestedQueryCost ?? 100;
+  const available = response.extensions?.cost?.throttleStatus?.currentlyAvailable ?? 0;
+  const deficit = needed - available;
+
+  if (deficit <= 0) return 2000;
+  return Math.ceil((deficit / restoreRate) * 1000) + 1000;
 }
 
 // Snapshot format (matches jobProcessor.server.ts)
@@ -126,13 +227,98 @@ export async function getSyncStatus(shop: string): Promise<{
   };
 }
 
+/**
+ * Fetch all variants for a product using cursor-based pagination.
+ * Most products have <10 variants, but Shopify supports up to 2000.
+ * Only makes additional requests if the first page indicates more variants exist.
+ */
+async function fetchAllVariants(
+  admin: {
+    graphql: (
+      query: string,
+      options?: { variables?: Record<string, unknown> }
+    ) => Promise<Response>;
+  },
+  product: ProductNode
+): Promise<ProductVariant[]> {
+  // Collect variants from the initial query
+  const allVariants = product.variants.edges.map((e) => e.node);
+
+  // If no more pages, we're done (most products)
+  if (!product.variants.pageInfo.hasNextPage) {
+    return allVariants;
+  }
+
+  // Paginate remaining variants
+  let variantCursor = product.variants.pageInfo.endCursor;
+  let hasMore = true;
+
+  while (hasMore) {
+    const response = await admin.graphql(
+      `#graphql
+        query GetProductVariants($productId: ID!, $cursor: String) {
+          product(id: $productId) {
+            variants(first: ${VARIANTS_PER_PAGE}, after: $cursor) {
+              edges {
+                node {
+                  id
+                  title
+                  price
+                  compareAtPrice
+                  sku
+                  inventoryQuantity
+                }
+              }
+              pageInfo {
+                hasNextPage
+                endCursor
+              }
+            }
+          }
+        }
+      `,
+      { variables: { productId: product.id, cursor: variantCursor } }
+    );
+
+    const data: VariantsResponse = await response.json();
+
+    // Handle throttling on variant fetches
+    const retryMs = getThrottleRetryMs(data);
+    if (retryMs > 0) {
+      console.log(`[StoreGuard] Throttled on variant fetch, waiting ${retryMs}ms`);
+      await new Promise((resolve) => setTimeout(resolve, retryMs));
+      continue; // Retry the same cursor
+    }
+
+    const variantPage = data.data?.product?.variants;
+    if (!variantPage) break;
+
+    for (const edge of variantPage.edges) {
+      allVariants.push(edge.node);
+    }
+
+    // Proactive rate limit wait
+    await waitForRateLimit(
+      data.extensions?.cost?.throttleStatus,
+      data.extensions?.cost?.actualQueryCost ?? 10
+    );
+
+    hasMore = variantPage.pageInfo.hasNextPage;
+    variantCursor = variantPage.pageInfo.endCursor;
+  }
+
+  return allVariants;
+}
+
 /**
  * Sync all products from Shopify to our ProductCache and create baseline snapshots.
  * This ensures we have:
  * 1. Product names available for delete events
  * 2. Baseline snapshots so the first update shows what changed
  * 3. ProductSnapshot records for StoreGuard change detection
- * Uses cursor-based pagination to handle stores with many products.
+ *
+ * Uses cursor-based pagination to handle stores with 100K+ products.
+ * Includes Shopify GraphQL rate limit awareness to avoid throttling.
  */
 export async function syncProducts(
   shop: string,
@@ -161,7 +347,7 @@ export async function syncProducts(
       const response = await admin.graphql(
         `#graphql
           query GetProducts($cursor: String) {
-            products(first: 50, after: $cursor) {
+            products(first: ${PRODUCTS_PER_PAGE}, after: $cursor) {
               edges {
                 node {
                   id
@@ -178,7 +364,7 @@ export async function syncProducts(
                       }
                     }
                   }
-                  variants(first: 10) {
+                  variants(first: ${VARIANTS_PER_PAGE}) {
                     edges {
                       node {
                         id
@@ -189,6 +375,10 @@ export async function syncProducts(
                         inventoryQuantity
                       }
                     }
+                    pageInfo {
+                      hasNextPage
+                      endCursor
+                    }
                   }
                   options {
                     name
@@ -209,19 +399,37 @@ export async function syncProducts(
       );
 
       const data: ProductsResponse = await response.json();
+
+      // Handle THROTTLED errors â€” wait and retry the same cursor
+      const retryMs = getThrottleRetryMs(data);
+      if (retryMs > 0) {
+        console.log(`[StoreGuard] Throttled by Shopify, waiting ${retryMs}ms before retry...`);
+        await new Promise((resolve) => setTimeout(resolve, retryMs));
+        continue; // Retry with the same cursor
+      }
+
       const products = data.data?.products;
 
       if (!products) {
-        console.error("[StoreGuard] Failed to fetch products from GraphQL");
+        console.error("[StoreGuard] Failed to fetch products from GraphQL", data.errors);
         break;
       }
 
+      // Proactive rate limit: wait if we're running low on points
+      await waitForRateLimit(
+        data.extensions?.cost?.throttleStatus,
+        data.extensions?.cost?.actualQueryCost ?? 50
+      );
+
       // Upsert products into cache and create baseline EventLog entries
       for (const edge of products.edges) {
         const product = edge.node;
         // Extract numeric ID from GID (gid://shopify/Product/123)
         const numericId = product.id.split("/").pop() || product.id;
 
+        // Fetch all variants (handles products with >100 variants via pagination)
+        const allVariants = await fetchAllVariants(admin, product);
+
         // Upsert into cache for delete name resolution
         await db.productCache.upsert({
           where: {
@@ -242,11 +450,11 @@ export async function syncProducts(
 
         // === StoreGuard: Create ProductSnapshot for change detection ===
         // This is what changeDetection.server.ts uses to compare before/after
-        const productSnapshotVariants = product.variants.edges.map((v) => ({
-          id: v.node.id.split("/").pop() || v.node.id,
-          title: v.node.title,
-          price: v.node.price,
-          inventoryQuantity: v.node.inventoryQuantity ?? 0,
+        const productSnapshotVariants = allVariants.map((v) => ({
+          id: v.id.split("/").pop() || v.id,
+          title: v.title,
+          price: v.price,
+          inventoryQuantity: v.inventoryQuantity ?? 0,
         }));
 
         await db.productSnapshot.upsert({
@@ -265,6 +473,15 @@ export async function syncProducts(
           },
         });
 
+        // Build a synthetic ProductNode with all variants for snapshot creation
+        const fullProduct: ProductNode = {
+          ...product,
+          variants: {
+            edges: allVariants.map((v) => ({ node: v })),
+            pageInfo: { hasNextPage: false, endCursor: null },
+          },
+        };
+
         // Ensure we have a baseline snapshot for this product (legacy EventLog).
         // IMPORTANT: ProductCache can exist from webhooks, but that doesn't mean a baseline snapshot exists.
         // Only `products/snapshot` events count as baselines.
@@ -274,7 +491,7 @@ export async function syncProducts(
 
         if (!existingBaseline || force) {
           // Create baseline snapshot so future updates can show diffs
-          const snapshot = createSnapshotFromGraphQL(product);
+          const snapshot = createSnapshotFromGraphQL(fullProduct);
           const diff = JSON.stringify({
             snapshot: snapshot,
             changes: [], // No changes for baseline
@@ -313,7 +530,7 @@ export async function syncProducts(
         synced++;
 
         // Persist progress frequently so the UI doesn't appear "stuck".
-        if (synced % 10 === 0) {
+        if (synced % 50 === 0) {
           await db.shopSync.update({
             where: { shop },
             data: { syncedProducts: synced },
@@ -331,7 +548,7 @@ export async function syncProducts(
       });
 
       // Log progress for large catalogs
-      if (synced % 100 === 0 && synced > 0) {
+      if (synced % 500 === 0 && synced > 0) {
         console.log(`[StoreGuard] Sync progress: ${synced} products...`);
       }
     }
diff --git a/insightops/app/services/productSync.test.ts b/insightops/app/services/productSync.test.ts
new file mode 100644
index 0000000..00f9c75
--- /dev/null
+++ b/insightops/app/services/productSync.test.ts
@@ -0,0 +1,165 @@
+import { describe, it, expect, vi } from "vitest";
+import {
+  waitForRateLimit,
+  getThrottleRetryMs,
+  PRODUCTS_PER_PAGE,
+  VARIANTS_PER_PAGE,
+} from "./productSync.server";
+
+describe("PRODUCTS_PER_PAGE", () => {
+  it("should be 250 (Shopify max)", () => {
+    expect(PRODUCTS_PER_PAGE).toBe(250);
+  });
+});
+
+describe("VARIANTS_PER_PAGE", () => {
+  it("should be 100", () => {
+    expect(VARIANTS_PER_PAGE).toBe(100);
+  });
+});
+
+describe("getThrottleRetryMs", () => {
+  it("should return 0 when no errors present", () => {
+    const response = {
+      data: { products: { edges: [], pageInfo: { hasNextPage: false, endCursor: null } } },
+    };
+    expect(getThrottleRetryMs(response)).toBe(0);
+  });
+
+  it("should return 0 when errors are not THROTTLED", () => {
+    const response = {
+      data: undefined,
+      errors: [{ message: "Something went wrong", extensions: { code: "INTERNAL_ERROR" } }],
+    };
+    expect(getThrottleRetryMs(response)).toBe(0);
+  });
+
+  it("should return retry ms when THROTTLED error is present", () => {
+    const response = {
+      data: undefined,
+      errors: [{ message: "Throttled", extensions: { code: "THROTTLED" } }],
+      extensions: {
+        cost: {
+          requestedQueryCost: 500,
+          actualQueryCost: 0,
+          throttleStatus: {
+            maximumAvailable: 1000,
+            currentlyAvailable: 100,
+            restoreRate: 50,
+          },
+        },
+      },
+    };
+    const retryMs = getThrottleRetryMs(response);
+    // (500 - 100) / 50 = 8 seconds + 1s buffer = 9000ms
+    expect(retryMs).toBe(9000);
+  });
+
+  it("should return calculated fallback when THROTTLED but no cost info", () => {
+    const response = {
+      data: undefined,
+      errors: [{ message: "Throttled", extensions: { code: "THROTTLED" } }],
+    };
+    // Defaults: needed=100, available=0, restoreRate=50
+    // (100/50)*1000 + 1000 = 3000ms
+    expect(getThrottleRetryMs(response)).toBe(3000);
+  });
+
+  it("should return default 2000ms when deficit is zero or negative", () => {
+    const response = {
+      data: undefined,
+      errors: [{ message: "Throttled", extensions: { code: "THROTTLED" } }],
+      extensions: {
+        cost: {
+          requestedQueryCost: 50,
+          actualQueryCost: 50,
+          throttleStatus: {
+            maximumAvailable: 1000,
+            currentlyAvailable: 800,
+            restoreRate: 50,
+          },
+        },
+      },
+    };
+    expect(getThrottleRetryMs(response)).toBe(2000);
+  });
+
+  it("should detect THROTTLED among multiple errors", () => {
+    const response = {
+      data: undefined,
+      errors: [
+        { message: "Another error" },
+        { message: "Throttled", extensions: { code: "THROTTLED" } },
+      ],
+      extensions: {
+        cost: {
+          requestedQueryCost: 200,
+          actualQueryCost: 0,
+          throttleStatus: {
+            maximumAvailable: 1000,
+            currentlyAvailable: 0,
+            restoreRate: 50,
+          },
+        },
+      },
+    };
+    const retryMs = getThrottleRetryMs(response);
+    // (200 - 0) / 50 = 4s + 1s = 5000ms
+    expect(retryMs).toBe(5000);
+  });
+});
+
+describe("waitForRateLimit", () => {
+  it("should resolve immediately when throttleStatus is undefined", async () => {
+    const start = Date.now();
+    await waitForRateLimit(undefined, 100);
+    expect(Date.now() - start).toBeLessThan(50);
+  });
+
+  it("should resolve immediately when enough points available", async () => {
+    const start = Date.now();
+    await waitForRateLimit(
+      { maximumAvailable: 1000, currentlyAvailable: 800, restoreRate: 50 },
+      100
+    );
+    expect(Date.now() - start).toBeLessThan(50);
+  });
+
+  it("should wait when points are below threshold", async () => {
+    vi.useFakeTimers();
+    const promise = waitForRateLimit(
+      { maximumAvailable: 1000, currentlyAvailable: 50, restoreRate: 50 },
+      300
+    );
+
+    // Should be waiting â€” advance timers
+    // Need (300 - 50) / 50 = 5 + 1 = 6 seconds
+    await vi.advanceTimersByTimeAsync(6000);
+    await promise;
+
+    vi.useRealTimers();
+  });
+
+  it("should use THROTTLE_THRESHOLD as minimum when queryCost is small", async () => {
+    vi.useFakeTimers();
+    // queryCost is 10 but THROTTLE_THRESHOLD is 200, so we should wait
+    // since currentlyAvailable (100) < max(10, 200) = 200
+    const promise = waitForRateLimit(
+      { maximumAvailable: 1000, currentlyAvailable: 100, restoreRate: 50 },
+      10
+    );
+
+    // pointsNeeded = 10 - 100 = negative, but the threshold triggers
+    // Actually: queryCost (10) < THROTTLE_THRESHOLD (200), so we compare
+    // currentlyAvailable (100) < max(10, 200) = 200 => must wait
+    // pointsNeeded = queryCost - available = 10 - 100 = -90 => ceil(-90/50)+1 = -1+1 = 0
+    // Wait: 0 seconds? No â€” let's check:
+    // We need `queryCost - currentlyAvailable`, so 10 - 100 = -90
+    // waitSeconds = ceil(-90 / 50) + 1 = ceil(-1.8) + 1 = -1 + 1 = 0
+    // setTimeout(resolve, 0) resolves on next tick
+    await vi.advanceTimersByTimeAsync(0);
+    await promise;
+
+    vi.useRealTimers();
+  });
+});

==========================================
BRANCH: v2/p0-background-jobs
==========================================
diff --git a/insightops/app/routes/webhooks.app.scopes_update.tsx b/insightops/app/routes/webhooks.app.scopes_update.tsx
index b1610b8..1de6837 100644
--- a/insightops/app/routes/webhooks.app.scopes_update.tsx
+++ b/insightops/app/routes/webhooks.app.scopes_update.tsx
@@ -1,21 +1,26 @@
 import type { ActionFunctionArgs } from "react-router";
 import { authenticate } from "../shopify.server";
-import db from "../db.server";
+import { queueWebhookJob } from "../services/jobQueue.server";
 
 export const action = async ({ request }: ActionFunctionArgs) => {
-    const { payload, session, topic, shop } = await authenticate.webhook(request);
-    console.log(`Received ${topic} webhook for ${shop}`);
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
 
-    const current = payload.current as string[];
-    if (session) {
-        await db.session.update({   
-            where: {
-                id: session.id
-            },
-            data: {
-                scope: current.toString(),
-            },
-        });
-    }
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
     return new Response();
+  }
+
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: shop,
+    payload,
+    webhookId: webhookId || undefined,
+  });
+
+  return new Response();
 };
diff --git a/insightops/app/routes/webhooks.collections.create.tsx b/insightops/app/routes/webhooks.collections.create.tsx
index 2712988..9659714 100644
--- a/insightops/app/routes/webhooks.collections.create.tsx
+++ b/insightops/app/routes/webhooks.collections.create.tsx
@@ -1,12 +1,6 @@
 import type { ActionFunctionArgs } from "react-router";
 import { authenticate } from "../shopify.server";
-import { queueWebhookJob, isWebhookProcessed } from "../services/jobQueue.server";
-
-interface CollectionWebhookPayload {
-  id: number;
-  title: string;
-  handle: string;
-}
+import { queueWebhookJob } from "../services/jobQueue.server";
 
 export const action = async ({ request }: ActionFunctionArgs) => {
   const webhookId = request.headers.get("X-Shopify-Webhook-Id");
@@ -14,34 +8,22 @@ export const action = async ({ request }: ActionFunctionArgs) => {
   const { shop, session, topic, payload } =
     await authenticate.webhook(request);
 
-  console.log(`Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
 
   if (!session) {
-    console.log(`No session found for ${shop}, skipping`);
-    return new Response();
-  }
-
-  if (webhookId && await isWebhookProcessed(webhookId)) {
-    console.log(`[StoreGuard] Duplicate webhook ${webhookId}, skipping`);
     return new Response();
   }
 
-  const collection = payload as CollectionWebhookPayload;
-
-  try {
-    await queueWebhookJob({
-      shop,
-      topic,
-      resourceId: String(collection.id),
-      payload: collection,
-      webhookId: webhookId || undefined,
-      delayMs: 2000,
-    });
+  const collection = payload as { id: number };
 
-    console.log(`[StoreGuard] Queued ${topic} for collection ${collection.id}`);
-  } catch (error) {
-    console.error(`[StoreGuard] Failed to queue job:`, error);
-  }
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(collection.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
 
   return new Response();
 };
diff --git a/insightops/app/routes/webhooks.collections.delete.tsx b/insightops/app/routes/webhooks.collections.delete.tsx
index c932f56..d8e02af 100644
--- a/insightops/app/routes/webhooks.collections.delete.tsx
+++ b/insightops/app/routes/webhooks.collections.delete.tsx
@@ -1,10 +1,6 @@
 import type { ActionFunctionArgs } from "react-router";
 import { authenticate } from "../shopify.server";
-import { queueWebhookJob, isWebhookProcessed } from "../services/jobQueue.server";
-
-interface CollectionDeletePayload {
-  id: number;
-}
+import { queueWebhookJob } from "../services/jobQueue.server";
 
 export const action = async ({ request }: ActionFunctionArgs) => {
   const webhookId = request.headers.get("X-Shopify-Webhook-Id");
@@ -12,34 +8,21 @@ export const action = async ({ request }: ActionFunctionArgs) => {
   const { shop, session, topic, payload } =
     await authenticate.webhook(request);
 
-  console.log(`Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
 
   if (!session) {
-    console.log(`No session found for ${shop}, skipping`);
-    return new Response();
-  }
-
-  if (webhookId && await isWebhookProcessed(webhookId)) {
-    console.log(`[StoreGuard] Duplicate webhook ${webhookId}, skipping`);
     return new Response();
   }
 
-  const collection = payload as CollectionDeletePayload;
-
-  try {
-    await queueWebhookJob({
-      shop,
-      topic,
-      resourceId: String(collection.id),
-      payload: collection,
-      webhookId: webhookId || undefined,
-      delayMs: 0,
-    });
+  const collection = payload as { id: number };
 
-    console.log(`[StoreGuard] Queued ${topic} for collection ${collection.id}`);
-  } catch (error) {
-    console.error(`[StoreGuard] Failed to queue job:`, error);
-  }
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(collection.id),
+    payload,
+    webhookId: webhookId || undefined,
+  });
 
   return new Response();
 };
diff --git a/insightops/app/routes/webhooks.collections.update.tsx b/insightops/app/routes/webhooks.collections.update.tsx
index 2712988..9659714 100644
--- a/insightops/app/routes/webhooks.collections.update.tsx
+++ b/insightops/app/routes/webhooks.collections.update.tsx
@@ -1,12 +1,6 @@
 import type { ActionFunctionArgs } from "react-router";
 import { authenticate } from "../shopify.server";
-import { queueWebhookJob, isWebhookProcessed } from "../services/jobQueue.server";
-
-interface CollectionWebhookPayload {
-  id: number;
-  title: string;
-  handle: string;
-}
+import { queueWebhookJob } from "../services/jobQueue.server";
 
 export const action = async ({ request }: ActionFunctionArgs) => {
   const webhookId = request.headers.get("X-Shopify-Webhook-Id");
@@ -14,34 +8,22 @@ export const action = async ({ request }: ActionFunctionArgs) => {
   const { shop, session, topic, payload } =
     await authenticate.webhook(request);
 
-  console.log(`Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
 
   if (!session) {
-    console.log(`No session found for ${shop}, skipping`);
-    return new Response();
-  }
-
-  if (webhookId && await isWebhookProcessed(webhookId)) {
-    console.log(`[StoreGuard] Duplicate webhook ${webhookId}, skipping`);
     return new Response();
   }
 
-  const collection = payload as CollectionWebhookPayload;
-
-  try {
-    await queueWebhookJob({
-      shop,
-      topic,
-      resourceId: String(collection.id),
-      payload: collection,
-      webhookId: webhookId || undefined,
-      delayMs: 2000,
-    });
+  const collection = payload as { id: number };
 
-    console.log(`[StoreGuard] Queued ${topic} for collection ${collection.id}`);
-  } catch (error) {
-    console.error(`[StoreGuard] Failed to queue job:`, error);
-  }
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(collection.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
 
   return new Response();
 };
diff --git a/insightops/app/routes/webhooks.inventory.update.tsx b/insightops/app/routes/webhooks.inventory.update.tsx
index a802977..f4015c1 100644
--- a/insightops/app/routes/webhooks.inventory.update.tsx
+++ b/insightops/app/routes/webhooks.inventory.update.tsx
@@ -1,13 +1,6 @@
 import type { ActionFunctionArgs } from "react-router";
 import { authenticate } from "../shopify.server";
-import { queueWebhookJob, isWebhookProcessed } from "../services/jobQueue.server";
-
-interface InventoryLevelPayload {
-  inventory_item_id: number;
-  location_id: number;
-  available: number;
-  updated_at: string;
-}
+import { queueWebhookJob } from "../services/jobQueue.server";
 
 export const action = async ({ request }: ActionFunctionArgs) => {
   const webhookId = request.headers.get("X-Shopify-Webhook-Id");
@@ -15,37 +8,22 @@ export const action = async ({ request }: ActionFunctionArgs) => {
   const { shop, session, topic, payload } =
     await authenticate.webhook(request);
 
-  console.log(`Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
 
   if (!session) {
-    console.log(`No session found for ${shop}, skipping`);
-    return new Response();
-  }
-
-  // Check for duplicate (already processed or queued)
-  if (webhookId && await isWebhookProcessed(webhookId)) {
-    console.log(`[StoreGuard] Duplicate webhook ${webhookId}, skipping`);
     return new Response();
   }
 
-  const inventoryPayload = payload as InventoryLevelPayload;
-
-  // Queue the job with 2s delay (consistent with other webhooks, though inventory might be faster)
-  try {
-    await queueWebhookJob({
-      shop,
-      topic,
-      resourceId: String(inventoryPayload.inventory_item_id),
-      payload: inventoryPayload,
-      webhookId: webhookId || undefined,
-      delayMs: 2000,
-    });
+  const inventoryPayload = payload as { inventory_item_id: number };
 
-    console.log(`[StoreGuard] Queued ${topic} for inventory item ${inventoryPayload.inventory_item_id}`);
-  } catch (error) {
-    console.error(`[StoreGuard] Failed to queue job:`, error);
-  }
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(inventoryPayload.inventory_item_id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
 
-  // Always return 200 OK immediately
   return new Response();
 };
diff --git a/insightops/app/routes/webhooks.orders.paid.tsx b/insightops/app/routes/webhooks.orders.paid.tsx
index ac39ac4..023d3b4 100644
--- a/insightops/app/routes/webhooks.orders.paid.tsx
+++ b/insightops/app/routes/webhooks.orders.paid.tsx
@@ -1,28 +1,6 @@
 import type { ActionFunctionArgs } from "react-router";
 import { authenticate } from "../shopify.server";
-import db from "../db.server";
-
-// Note: We intentionally don't access customer data to avoid needing
-// protected customer data approval. We only use order-level info.
-interface LineItem {
-  title: string;
-  quantity: number;
-  price: string;
-  variant_title: string | null;
-  product_id: number | null;
-}
-
-interface OrderPayload {
-  id: number;
-  name: string; // Order number like "#1001"
-  total_price: string;
-  subtotal_price: string;
-  currency: string;
-  financial_status: string;
-  created_at: string;
-  line_items: LineItem[];
-  discount_codes: Array<{ code: string; amount: string }>;
-}
+import { queueWebhookJob } from "../services/jobQueue.server";
 
 export const action = async ({ request }: ActionFunctionArgs) => {
   const webhookId = request.headers.get("X-Shopify-Webhook-Id");
@@ -33,74 +11,18 @@ export const action = async ({ request }: ActionFunctionArgs) => {
   console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
 
   if (!session) {
-    console.log(`[StoreGuard] No session found for ${shop}, skipping order`);
     return new Response();
   }
 
-  // Check for duplicate
-  if (webhookId) {
-    const existing = await db.eventLog.findFirst({
-      where: { webhookId },
-    });
-    if (existing) {
-      console.log(`[StoreGuard] Duplicate order webhook ${webhookId}, skipping`);
-      return new Response();
-    }
-  }
-
-  const order = payload as OrderPayload;
-
-  // Build order summary (no customer data - just item info)
-  const itemCount = order.line_items.reduce((sum, item) => sum + item.quantity, 0);
-  const firstItem = order.line_items[0]?.title || "items";
-  const itemSummary = itemCount === 1
-    ? firstItem
-    : `${itemCount} items`;
+  const order = payload as { id: number };
 
-  // Format the amount
-  const amount = parseFloat(order.total_price);
-  const formattedAmount = amount.toLocaleString("en-US", {
-    style: "currency",
-    currency: order.currency || "USD",
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(order.id),
+    payload,
+    webhookId: webhookId || undefined,
   });
 
-  // Create an exciting message (no customer PII)
-  const message = `ðŸ’° Order ${order.name} - ${formattedAmount}`;
-
-  // Build diff with order details (no customer data)
-  const diff = JSON.stringify({
-    orderId: order.id,
-    orderName: order.name,
-    total: order.total_price,
-    subtotal: order.subtotal_price,
-    currency: order.currency,
-    status: order.financial_status,
-    itemCount,
-    itemSummary,
-    items: order.line_items.map((item) => ({
-      title: item.title,
-      variant: item.variant_title,
-      quantity: item.quantity,
-      price: item.price,
-      productId: item.product_id,
-    })),
-    discounts: order.discount_codes,
-  });
-
-  // Log the order event
-  await db.eventLog.create({
-    data: {
-      shop,
-      shopifyId: String(order.id),
-      topic: "ORDERS_CREATE",
-      author: "Customer", // Generic - no PII
-      message,
-      diff,
-      webhookId,
-    },
-  });
-
-  console.log(`[StoreGuard] âœ… Logged order: ${message}`);
-
   return new Response();
 };
diff --git a/insightops/app/routes/webhooks.products.create.tsx b/insightops/app/routes/webhooks.products.create.tsx
index a8324d5..d156dc0 100644
--- a/insightops/app/routes/webhooks.products.create.tsx
+++ b/insightops/app/routes/webhooks.products.create.tsx
@@ -1,20 +1,6 @@
 import type { ActionFunctionArgs } from "react-router";
 import { authenticate } from "../shopify.server";
-import { queueWebhookJob, isWebhookProcessed } from "../services/jobQueue.server";
-
-interface ProductWebhookPayload {
-  id: number;
-  title: string;
-  handle: string;
-  variants: Array<{
-    id: number;
-    price: string;
-    compare_at_price: string | null;
-    inventory_quantity: number;
-    title: string;
-  }>;
-  created_at: string;
-}
+import { queueWebhookJob } from "../services/jobQueue.server";
 
 export const action = async ({ request }: ActionFunctionArgs) => {
   const webhookId = request.headers.get("X-Shopify-Webhook-Id");
@@ -22,34 +8,22 @@ export const action = async ({ request }: ActionFunctionArgs) => {
   const { shop, session, topic, payload } =
     await authenticate.webhook(request);
 
-  console.log(`Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
 
   if (!session) {
-    console.log(`No session found for ${shop}, skipping`);
-    return new Response();
-  }
-
-  if (webhookId && await isWebhookProcessed(webhookId)) {
-    console.log(`[StoreGuard] Duplicate webhook ${webhookId}, skipping`);
     return new Response();
   }
 
-  const product = payload as ProductWebhookPayload;
-
-  try {
-    await queueWebhookJob({
-      shop,
-      topic,
-      resourceId: String(product.id),
-      payload: product,
-      webhookId: webhookId || undefined,
-      delayMs: 2000,
-    });
+  const product = payload as { id: number };
 
-    console.log(`[StoreGuard] Queued ${topic} for product ${product.id}`);
-  } catch (error) {
-    console.error(`[StoreGuard] Failed to queue job:`, error);
-  }
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(product.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
 
   return new Response();
 };
diff --git a/insightops/app/routes/webhooks.products.delete.tsx b/insightops/app/routes/webhooks.products.delete.tsx
index 8724780..cdc1278 100644
--- a/insightops/app/routes/webhooks.products.delete.tsx
+++ b/insightops/app/routes/webhooks.products.delete.tsx
@@ -1,10 +1,6 @@
 import type { ActionFunctionArgs } from "react-router";
 import { authenticate } from "../shopify.server";
-import { queueWebhookJob, isWebhookProcessed } from "../services/jobQueue.server";
-
-interface ProductDeletePayload {
-  id: number;
-}
+import { queueWebhookJob } from "../services/jobQueue.server";
 
 export const action = async ({ request }: ActionFunctionArgs) => {
   const webhookId = request.headers.get("X-Shopify-Webhook-Id");
@@ -12,35 +8,22 @@ export const action = async ({ request }: ActionFunctionArgs) => {
   const { shop, session, topic, payload } =
     await authenticate.webhook(request);
 
-  console.log(`Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
 
   if (!session) {
-    console.log(`No session found for ${shop}, skipping`);
-    return new Response();
-  }
-
-  if (webhookId && await isWebhookProcessed(webhookId)) {
-    console.log(`[StoreGuard] Duplicate webhook ${webhookId}, skipping`);
     return new Response();
   }
 
-  const product = payload as ProductDeletePayload;
-
-  try {
-    // No delay for delete - we need to grab the title from cache before cleanup
-    await queueWebhookJob({
-      shop,
-      topic,
-      resourceId: String(product.id),
-      payload: product,
-      webhookId: webhookId || undefined,
-      delayMs: 0, // Process immediately
-    });
+  const product = payload as { id: number };
 
-    console.log(`[StoreGuard] Queued ${topic} for product ${product.id}`);
-  } catch (error) {
-    console.error(`[StoreGuard] Failed to queue job:`, error);
-  }
+  // No delay for delete â€” need to grab the title from cache before cleanup
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(product.id),
+    payload,
+    webhookId: webhookId || undefined,
+  });
 
   return new Response();
 };
diff --git a/insightops/app/routes/webhooks.products.update.tsx b/insightops/app/routes/webhooks.products.update.tsx
index 6c516cc..26f23fa 100644
--- a/insightops/app/routes/webhooks.products.update.tsx
+++ b/insightops/app/routes/webhooks.products.update.tsx
@@ -1,20 +1,6 @@
 import type { ActionFunctionArgs } from "react-router";
 import { authenticate } from "../shopify.server";
-import { queueWebhookJob, isWebhookProcessed } from "../services/jobQueue.server";
-
-interface ProductWebhookPayload {
-  id: number;
-  title: string;
-  handle: string;
-  variants: Array<{
-    id: number;
-    price: string;
-    compare_at_price: string | null;
-    inventory_quantity: number;
-    title: string;
-  }>;
-  updated_at: string;
-}
+import { queueWebhookJob } from "../services/jobQueue.server";
 
 export const action = async ({ request }: ActionFunctionArgs) => {
   const webhookId = request.headers.get("X-Shopify-Webhook-Id");
@@ -22,40 +8,23 @@ export const action = async ({ request }: ActionFunctionArgs) => {
   const { shop, session, topic, payload } =
     await authenticate.webhook(request);
 
-  console.log(`Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
 
-  // ACK immediately if no session - Shopify requires fast response
   if (!session) {
-    console.log(`No session found for ${shop}, skipping`);
-    return new Response();
-  }
-
-  // Check for duplicate (already processed or queued)
-  if (webhookId && await isWebhookProcessed(webhookId)) {
-    console.log(`[StoreGuard] Duplicate webhook ${webhookId}, skipping`);
     return new Response();
   }
 
-  const product = payload as ProductWebhookPayload;
-
-  // Queue the job with 2s delay for Events API propagation
-  // This returns immediately, avoiding webhook timeout
-  try {
-    await queueWebhookJob({
-      shop,
-      topic,
-      resourceId: String(product.id),
-      payload: product,
-      webhookId: webhookId || undefined,
-      delayMs: 2000, // Wait for Shopify Events API to populate
-    });
+  const product = payload as { id: number };
 
-    console.log(`[StoreGuard] Queued ${topic} for product ${product.id}`);
-  } catch (error) {
-    // If queue fails (e.g., duplicate), just log and continue
-    console.error(`[StoreGuard] Failed to queue job:`, error);
-  }
+  // Queue and return immediately â€” dedup handled by unique constraint on webhookId
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(product.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000, // Wait for Shopify Events API to populate
+  });
 
-  // Always return 200 OK immediately
   return new Response();
 };
diff --git a/insightops/app/routes/webhooks.themes.publish.tsx b/insightops/app/routes/webhooks.themes.publish.tsx
index 0151e66..1b0605f 100644
--- a/insightops/app/routes/webhooks.themes.publish.tsx
+++ b/insightops/app/routes/webhooks.themes.publish.tsx
@@ -1,18 +1,6 @@
 import type { ActionFunctionArgs } from "react-router";
 import { authenticate } from "../shopify.server";
-import { recordThemePublish } from "../services/changeDetection.server";
-
-interface ThemePayload {
-  id: number;
-  name: string;
-  role: string; // "main", "unpublished", "demo"
-  theme_store_id: number | null;
-  previewable: boolean;
-  processing: boolean;
-  admin_graphql_api_id: string;
-  created_at: string;
-  updated_at: string;
-}
+import { queueWebhookJob } from "../services/jobQueue.server";
 
 export const action = async ({ request }: ActionFunctionArgs) => {
   const webhookId = request.headers.get("X-Shopify-Webhook-Id");
@@ -23,23 +11,18 @@ export const action = async ({ request }: ActionFunctionArgs) => {
   console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
 
   if (!session) {
-    console.log(`[StoreGuard] No session found for ${shop}, skipping`);
-    return new Response();
-  }
-
-  if (!webhookId) {
-    console.log(`[StoreGuard] No webhookId, skipping`);
     return new Response();
   }
 
-  const theme = payload as ThemePayload;
-
-  // Record theme publish event (checks if Pro plan and theme tracking enabled)
-  const recorded = await recordThemePublish(shop, theme, webhookId);
+  const theme = payload as { id: number };
 
-  if (recorded) {
-    console.log(`[StoreGuard] âœ… Theme publish alert created for "${theme.name}"`);
-  }
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(theme.id),
+    payload,
+    webhookId: webhookId || undefined,
+  });
 
   return new Response();
 };
diff --git a/insightops/app/services/jobProcessor.server.ts b/insightops/app/services/jobProcessor.server.ts
index 7068c66..acc4c19 100644
--- a/insightops/app/services/jobProcessor.server.ts
+++ b/insightops/app/services/jobProcessor.server.ts
@@ -11,6 +11,7 @@ import {
   detectInventoryZero,
   detectLowStock,
   deleteProductSnapshot,
+  recordThemePublish,
 } from "./changeDetection.server";
 
 // Full product payload from Shopify webhook
@@ -824,6 +825,109 @@ async function processInventoryUpdate(
   console.log(`[StoreGuard] âœ… Logged: ${message}`);
 }
 
+/**
+ * Process a theme publish job
+ */
+async function processThemePublish(
+  shop: string,
+  payload: { id: number; name: string; role: string },
+  webhookId: string | null
+): Promise<void> {
+  if (!webhookId) {
+    console.log(`[StoreGuard] No webhookId for theme publish, skipping`);
+    return;
+  }
+
+  const recorded = await recordThemePublish(shop, payload, webhookId);
+  if (recorded) {
+    console.log(`[StoreGuard] Theme publish alert created for "${payload.name}"`);
+  }
+}
+
+/**
+ * Process an order paid job
+ */
+async function processOrderPaid(
+  shop: string,
+  payload: {
+    id: number;
+    name: string;
+    total_price: string;
+    subtotal_price: string;
+    currency: string;
+    financial_status: string;
+    line_items: Array<{
+      title: string;
+      quantity: number;
+      price: string;
+      variant_title: string | null;
+      product_id: number | null;
+    }>;
+    discount_codes: Array<{ code: string; amount: string }>;
+  },
+  webhookId: string | null
+): Promise<void> {
+  const itemCount = payload.line_items.reduce((sum, item) => sum + item.quantity, 0);
+  const firstItem = payload.line_items[0]?.title || "items";
+  const itemSummary = itemCount === 1 ? firstItem : `${itemCount} items`;
+
+  const amount = parseFloat(payload.total_price);
+  const formattedAmount = amount.toLocaleString("en-US", {
+    style: "currency",
+    currency: payload.currency || "USD",
+  });
+
+  const message = `Order ${payload.name} - ${formattedAmount}`;
+
+  const diff = JSON.stringify({
+    orderId: payload.id,
+    orderName: payload.name,
+    total: payload.total_price,
+    subtotal: payload.subtotal_price,
+    currency: payload.currency,
+    status: payload.financial_status,
+    itemCount,
+    itemSummary,
+    items: payload.line_items.map((item) => ({
+      title: item.title,
+      variant: item.variant_title,
+      quantity: item.quantity,
+      price: item.price,
+      productId: item.product_id,
+    })),
+    discounts: payload.discount_codes,
+  });
+
+  await db.eventLog.create({
+    data: {
+      shop,
+      shopifyId: String(payload.id),
+      topic: "ORDERS_CREATE",
+      author: "Customer",
+      message,
+      diff,
+      webhookId,
+    },
+  });
+
+  console.log(`[StoreGuard] Logged: ${message}`);
+}
+
+/**
+ * Process an app scopes update job
+ */
+async function processScopesUpdate(
+  shop: string,
+  sessionId: string,
+  payload: { current: string[] }
+): Promise<void> {
+  await db.session.update({
+    where: { id: sessionId },
+    data: { scope: payload.current.toString() },
+  });
+  console.log(`[StoreGuard] Updated scopes for ${shop}`);
+}
+
 /**
  * Process a single job
  */
@@ -867,6 +971,15 @@ async function processJob(job: {
     case "inventory/levels/update":
       await processInventoryUpdate(job.shop, session.accessToken, payload, job.webhookId);
       break;
+    case "themes/publish":
+      await processThemePublish(job.shop, payload, job.webhookId);
+      break;
+    case "orders/paid":
+      await processOrderPaid(job.shop, payload, job.webhookId);
+      break;
+    case "app/scopes/update":
+      await processScopesUpdate(job.shop, session.id, payload);
+      break;
     default:
       console.log(`[StoreGuard] Unknown topic: ${job.topic} (normalized: ${normalizedTopic})`);
   }
diff --git a/insightops/app/services/jobQueue.server.ts b/insightops/app/services/jobQueue.server.ts
index 17b4868..11bf93b 100644
--- a/insightops/app/services/jobQueue.server.ts
+++ b/insightops/app/services/jobQueue.server.ts
@@ -16,29 +16,40 @@ interface WebhookJobData {
  * Queue a webhook for background processing.
  * Returns immediately so the webhook handler can respond with 200 OK.
  * Automatically schedules job processing after the delay.
+ *
+ * Handles duplicate webhookIds gracefully via unique constraint â€” returns null if already queued.
  */
-export async function queueWebhookJob(data: WebhookJobData): Promise<string> {
+export async function queueWebhookJob(data: WebhookJobData): Promise<string | null> {
   const processAt = data.delayMs
     ? new Date(Date.now() + data.delayMs)
     : new Date();
 
-  const job = await db.webhookJob.create({
-    data: {
-      shop: data.shop,
-      topic: data.topic,
-      resourceId: data.resourceId,
-      payload: JSON.stringify(data.payload),
-      webhookId: data.webhookId,
-      processAt,
-    },
-  });
+  try {
+    const job = await db.webhookJob.create({
+      data: {
+        shop: data.shop,
+        topic: data.topic,
+        resourceId: data.resourceId,
+        payload: JSON.stringify(data.payload),
+        webhookId: data.webhookId,
+        processAt,
+      },
+    });
 
-  console.log(`[StoreGuard] Queued job ${job.id} for ${data.topic}`);
+    console.log(`[StoreGuard] Queued job ${job.id} for ${data.topic}`);
 
-  // Auto-schedule job processing (fire-and-forget)
-  scheduleJobProcessing(data.delayMs ? data.delayMs + 500 : 500);
+    // Auto-schedule job processing (fire-and-forget)
+    scheduleJobProcessing(data.delayMs ? data.delayMs + 500 : 100);
 
-  return job.id;
+    return job.id;
+  } catch (error: unknown) {
+    // Handle duplicate webhookId (unique constraint violation)
+    if (error instanceof Error && error.message.includes("Unique constraint")) {
+      console.log(`[StoreGuard] Duplicate webhook ${data.webhookId}, already queued`);
+      return null;
+    }
+    throw error;
+  }
 }
 
 /**
@@ -66,19 +77,6 @@ function scheduleJobProcessing(delayMs: number): void {
   }, delayMs);
 }
 
-/**
- * Check if a webhook has already been processed (deduplication)
- */
-export async function isWebhookProcessed(webhookId: string): Promise<boolean> {
-  // Check both completed jobs and event logs
-  const [existingJob, existingEvent] = await Promise.all([
-    db.webhookJob.findUnique({ where: { webhookId } }),
-    db.eventLog.findUnique({ where: { webhookId } }),
-  ]);
-
-  return !!(existingJob || existingEvent);
-}
-
 /**
  * Get pending jobs ready for processing
  */

==========================================
BRANCH: v2/p0-order-limits
==========================================
diff --git a/insightops/app/routes/app.changes.tsx b/insightops/app/routes/app.changes.tsx
index 26d7faf..e6cda41 100644
--- a/insightops/app/routes/app.changes.tsx
+++ b/insightops/app/routes/app.changes.tsx
@@ -15,6 +15,7 @@ interface ChangeEvent {
   detectedAt: string;
   source: string;
   importance: string;
+  contextData: string | null;
 }
 
 export const loader = async ({ request }: LoaderFunctionArgs) => {
@@ -181,6 +182,30 @@ export default function RecentChanges() {
                   </div>
                 )}
 
+                {event.contextData && (() => {
+                  try {
+                    const ctx = JSON.parse(event.contextData) as {
+                      velocityContext?: string | null;
+                      revenueImpact?: number | null;
+                    };
+                    if (!ctx.velocityContext && ctx.revenueImpact === null) return null;
+                    return (
+                      <div style={{ marginTop: 6, fontSize: 12, color: "#6b7280" }}>
+                        {ctx.velocityContext && (
+                          <span style={{ marginRight: 8 }}>{ctx.velocityContext}</span>
+                        )}
+                        {ctx.revenueImpact !== null && ctx.revenueImpact !== undefined && (
+                          <span style={{ color: "#dc2626", fontWeight: 500 }}>
+                            ~${ctx.revenueImpact.toFixed(2)}/hr impact
+                          </span>
+                        )}
+                      </div>
+                    );
+                  } catch {
+                    return null;
+                  }
+                })()}
+
               </div>
             );
           })}
diff --git a/insightops/app/services/changeDetection.server.ts b/insightops/app/services/changeDetection.server.ts
index 8d0a946..b1f1c7c 100644
--- a/insightops/app/services/changeDetection.server.ts
+++ b/insightops/app/services/changeDetection.server.ts
@@ -9,6 +9,8 @@ import {
   shouldAlertLowStock as checkLowStock,
   formatVariantLabel,
 } from "./changeDetection.utils";
+import { getProductSalesVelocity } from "./salesVelocity.server";
+import { formatVelocityContext, estimateRevenueImpact } from "./salesVelocity.utils";
 
 /**
  * Change Detection Service for StoreGuard
@@ -114,6 +116,7 @@ async function createChangeEvent(data: {
   source?: "webhook" | "sync_job" | "manual";
   importance?: "high" | "medium" | "low";
   groupId?: string;
+  contextData?: string | null;
 }): Promise<void> {
   try {
     const event = await db.changeEvent.create({
@@ -129,6 +132,7 @@ async function createChangeEvent(data: {
         source: data.source ?? "webhook",
         importance: data.importance ?? "medium",
         groupId: data.groupId,
+        contextData: data.contextData ?? null,
       },
     });
     console.log(`[StoreGuard] Created ${data.eventType} event for "${data.resourceName}"`);
@@ -147,6 +151,7 @@ async function createChangeEvent(data: {
             afterValue: data.afterValue,
             importance: data.importance ?? "medium",
             detectedAt: event.detectedAt,
+            contextData: data.contextData ?? null,
           },
           data.shop,
           alertEmail
@@ -199,6 +204,14 @@ export async function detectPriceChanges(
 
   let changesDetected = 0;
 
+  // Fetch sales velocity for business context (best-effort, non-blocking)
+  let velocity: Awaited<ReturnType<typeof getProductSalesVelocity>> = null;
+  try {
+    velocity = await getProductSalesVelocity(shop, productId);
+  } catch {
+    // Non-critical â€” proceed without velocity context
+  }
+
   // Compare each variant's price - only alert when price_before !== price_after
   for (const newVariant of product.variants) {
     const oldVariant = oldSnapshot.variants.find(v => v.id === String(newVariant.id));
@@ -208,6 +221,16 @@ export async function detectPriceChanges(
       const variantLabel = formatVariantLabel(product.title, newVariant.title);
       const importance = calculatePriceImportance(oldVariant.price, newVariant.price);
 
+      // Build context data with sales velocity
+      const priceDiff = Math.abs(parseFloat(newVariant.price) - parseFloat(oldVariant.price));
+      const velocityContext = formatVelocityContext(velocity);
+      const revenueImpact = estimateRevenueImpact(velocity, "price_error", {
+        priceDifference: priceDiff,
+      });
+      const contextData = (velocityContext || revenueImpact !== null)
+        ? JSON.stringify({ velocityContext, revenueImpact })
+        : null;
+
       await createChangeEvent({
         shop,
         entityType: "variant",
@@ -218,6 +241,7 @@ export async function detectPriceChanges(
         afterValue: `$${newVariant.price}`,
         webhookId: `${webhookId}-price-${newVariant.id}`,
         importance: importance as "high" | "medium" | "low",
+        contextData,
       });
       changesDetected++;
     }
@@ -272,6 +296,20 @@ export async function detectVisibilityChanges(
   if (isSignificantVisibilityTransition(oldSnapshot.status, product.status)) {
     const importance = getVisibilityImportance(product.status);
 
+    // Fetch sales velocity for business context (best-effort)
+    let velocity: Awaited<ReturnType<typeof getProductSalesVelocity>> = null;
+    try {
+      velocity = await getProductSalesVelocity(shop, productId);
+    } catch {
+      // Non-critical
+    }
+
+    const velocityContext = formatVelocityContext(velocity);
+    const revenueImpact = estimateRevenueImpact(velocity, "visibility", {});
+    const contextData = (velocityContext || revenueImpact !== null)
+      ? JSON.stringify({ velocityContext, revenueImpact })
+      : null;
+
     await createChangeEvent({
       shop,
       entityType: "product",
@@ -282,6 +320,7 @@ export async function detectVisibilityChanges(
       afterValue: product.status,
       webhookId: `${webhookId}-status`,
       importance,
+      contextData,
     });
 
     // Update snapshot
@@ -357,6 +396,20 @@ export async function detectInventoryZero(
     return false;
   }
 
+  // Fetch sales velocity for business context (best-effort)
+  let velocity: Awaited<ReturnType<typeof getProductSalesVelocity>> = null;
+  try {
+    velocity = await getProductSalesVelocity(shop, productId);
+  } catch {
+    // Non-critical
+  }
+
+  const velocityContext = formatVelocityContext(velocity);
+  const revenueImpact = estimateRevenueImpact(velocity, "stockout", {});
+  const contextData = (velocityContext || revenueImpact !== null)
+    ? JSON.stringify({ velocityContext, revenueImpact })
+    : null;
+
   await createChangeEvent({
     shop,
     entityType: "variant",
@@ -367,6 +420,7 @@ export async function detectInventoryZero(
     afterValue: "0",
     webhookId: `${webhookId}-inventory-zero-${inventoryItemId}`,
     importance: "high", // Out of stock is always high importance
+    contextData,
   });
 
   return true;
@@ -416,6 +470,20 @@ export async function detectLowStock(
 
   const displayName = formatVariantLabel(productTitle, variantTitle);
 
+  // Fetch sales velocity for business context (best-effort)
+  let velocity: Awaited<ReturnType<typeof getProductSalesVelocity>> = null;
+  try {
+    velocity = await getProductSalesVelocity(shop, productId);
+  } catch {
+    // Non-critical
+  }
+
+  const velocityContext = formatVelocityContext(velocity);
+  const revenueImpact = estimateRevenueImpact(velocity, "stockout", {});
+  const contextData = (velocityContext || revenueImpact !== null)
+    ? JSON.stringify({ velocityContext, revenueImpact })
+    : null;
+
   await createChangeEvent({
     shop,
     entityType: "variant",
@@ -426,6 +494,7 @@ export async function detectLowStock(
     afterValue: String(newQuantity),
     webhookId: `${webhookId}-inventory-low-${inventoryItemId}`,
     importance: "medium", // Low stock is medium importance (zero is high)
+    contextData,
   });
 
   console.log(`[StoreGuard] Low stock alert: ${displayName} dropped to ${newQuantity} (threshold: ${threshold})`);
diff --git a/insightops/app/services/dailyDigest.server.ts b/insightops/app/services/dailyDigest.server.ts
index 5120737..02b6584 100644
--- a/insightops/app/services/dailyDigest.server.ts
+++ b/insightops/app/services/dailyDigest.server.ts
@@ -17,6 +17,7 @@ export interface DigestEvent {
   afterValue: string | null;
   detectedAt: Date;
   importance: string;
+  contextData: string | null;
 }
 
 export interface DigestSummary {
@@ -131,6 +132,7 @@ export async function generateDigestForShop(shopDomain: string): Promise<DigestS
       afterValue: event.afterValue,
       detectedAt: event.detectedAt,
       importance: event.importance,
+      contextData: event.contextData,
     };
 
     if (event.importance === "high") {
diff --git a/insightops/app/services/dailyDigest.test.ts b/insightops/app/services/dailyDigest.test.ts
index 3341142..0723be2 100644
--- a/insightops/app/services/dailyDigest.test.ts
+++ b/insightops/app/services/dailyDigest.test.ts
@@ -18,6 +18,7 @@ function makeEvent(overrides: Partial<DigestEvent> = {}): DigestEvent {
     afterValue: "$15.00",
     detectedAt: new Date("2026-02-17T10:30:00Z"),
     importance: "medium",
+    contextData: null,
     ...overrides,
   };
 }
diff --git a/insightops/app/services/emailService.server.ts b/insightops/app/services/emailService.server.ts
index caada3b..5366b10 100644
--- a/insightops/app/services/emailService.server.ts
+++ b/insightops/app/services/emailService.server.ts
@@ -227,19 +227,34 @@ function formatChangeDescription(event: DigestSummary["eventsByType"]["price_cha
     hour12: true,
   });
 
+  // Parse context data for sales velocity
+  let velocitySuffix = "";
+  if (event.contextData) {
+    try {
+      const ctx = JSON.parse(event.contextData) as {
+        velocityContext?: string | null;
+      };
+      if (ctx.velocityContext) {
+        velocitySuffix = ` â€” ${ctx.velocityContext}`;
+      }
+    } catch {
+      // Ignore invalid context
+    }
+  }
+
   switch (event.eventType) {
     case "price_change":
-      return `${event.beforeValue} â†’ ${event.afterValue} â€¢ ${time}`;
+      return `${event.beforeValue} â†’ ${event.afterValue}${velocitySuffix} â€¢ ${time}`;
     case "visibility_change":
-      return `${event.beforeValue} â†’ ${event.afterValue} â€¢ ${time}`;
+      return `${event.beforeValue} â†’ ${event.afterValue}${velocitySuffix} â€¢ ${time}`;
     case "inventory_low":
-      return `Stock dropped to ${event.afterValue} units (was ${event.beforeValue}) â€¢ ${time}`;
+      return `Stock dropped to ${event.afterValue} units (was ${event.beforeValue})${velocitySuffix} â€¢ ${time}`;
     case "inventory_zero":
-      return `Now out of stock (was ${event.beforeValue} units) â€¢ ${time}`;
+      return `Now out of stock (was ${event.beforeValue} units)${velocitySuffix} â€¢ ${time}`;
     case "theme_publish":
       return `Now your live theme â€¢ ${time}`;
     default:
-      return `${event.beforeValue} â†’ ${event.afterValue} â€¢ ${time}`;
+      return `${event.beforeValue} â†’ ${event.afterValue}${velocitySuffix} â€¢ ${time}`;
   }
 }
 
@@ -266,6 +281,7 @@ interface InstantAlertEvent {
   afterValue: string | null;
   importance: string;
   detectedAt: Date;
+  contextData?: string | null;
 }
 
 /**
@@ -335,6 +351,22 @@ function generateInstantAlertHtml(
     hour12: true,
   });
 
+  // Parse context data for sales velocity
+  let velocityContext: string | null = null;
+  let revenueImpact: number | null = null;
+  if (event.contextData) {
+    try {
+      const ctx = JSON.parse(event.contextData) as {
+        velocityContext?: string | null;
+        revenueImpact?: number | null;
+      };
+      velocityContext = ctx.velocityContext ?? null;
+      revenueImpact = ctx.revenueImpact ?? null;
+    } catch {
+      // Invalid context data
+    }
+  }
+
   // Build change description
   let changeDescription = "";
   switch (event.eventType) {
@@ -357,6 +389,11 @@ function generateInstantAlertHtml(
       changeDescription = `${event.beforeValue || ""} â†’ ${event.afterValue || ""}`;
   }
 
+  // Append sales velocity context
+  if (velocityContext) {
+    changeDescription += ` â€” ${velocityContext}`;
+  }
+
   return `
 <!DOCTYPE html>
 <html>
@@ -382,6 +419,7 @@ function generateInstantAlertHtml(
       <p style="margin: 0 0 16px; color: #374151; font-size: 15px;">
         ${changeDescription}
       </p>
+      ${revenueImpact !== null ? `<p style="margin: 0 0 16px; color: #dc2626; font-size: 14px; font-weight: 500;">Estimated impact: ~$${revenueImpact.toFixed(2)}/hr until fixed</p>` : ""}
       <p style="margin: 0; color: #9ca3af; font-size: 13px;">
         Detected at ${time}
       </p>
diff --git a/insightops/app/services/salesVelocity.server.ts b/insightops/app/services/salesVelocity.server.ts
new file mode 100644
index 0000000..397dba5
--- /dev/null
+++ b/insightops/app/services/salesVelocity.server.ts
@@ -0,0 +1,277 @@
+/**
+ * Sales Velocity Service for StoreGuard
+ *
+ * Fetches order data from Shopify using GraphQL with cursor-based pagination
+ * and date-range filtering. Calculates per-product sales velocity for
+ * context-rich alerts (e.g., "you've been selling 8/day").
+ *
+ * Key design decisions:
+ * - Uses date-range queries (last 30 days) instead of fetching all orders
+ * - Cursor-based pagination handles stores with any order volume
+ * - Aggregates on our side since ShopifyQL is not available for public apps
+ * - Caches results to avoid repeated API calls during a single webhook batch
+ */
+
+import { apiVersion } from "../shopify.server";
+import db from "../db.server";
+import {
+  calculateProductVelocity,
+  type OrderData,
+  type ProductVelocity,
+} from "./salesVelocity.utils";
+
+const ORDERS_QUERY = `#graphql
+  query GetOrders($query: String!, $cursor: String) {
+    orders(first: 50, after: $cursor, query: $query) {
+      edges {
+        node {
+          id
+          createdAt
+          lineItems(first: 50) {
+            edges {
+              node {
+                product {
+                  id
+                }
+                variant {
+                  id
+                }
+                quantity
+                originalUnitPriceSet {
+                  shopMoney {
+                    amount
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+      pageInfo {
+        hasNextPage
+        endCursor
+      }
+    }
+  }
+`;
+
+// Max pages to fetch to prevent runaway pagination
+const MAX_PAGES = 20; // 20 pages * 50 orders = 1000 orders max
+
+// In-memory cache (lives for the lifetime of a single request/job batch)
+// Key: `${shop}:${periodDays}`, Value: velocity map
+const velocityCache = new Map<string, { data: Map<string, ProductVelocity>; expiresAt: number }>();
+const CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes
+
+/**
+ * Extract numeric ID from Shopify GID.
+ * "gid://shopify/Product/12345" -> "12345"
+ */
+function extractId(gid: string | null | undefined): string {
+  if (!gid) return "";
+  const match = gid.match(/\/(\d+)$/);
+  return match?.[1] ?? "";
+}
+
+/**
+ * Fetch orders from Shopify using cursor-based pagination with date-range filtering.
+ * Returns normalized OrderData array.
+ */
+async function fetchOrders(
+  shop: string,
+  accessToken: string,
+  periodDays: number
+): Promise<OrderData[]> {
+  const sinceDate = new Date(Date.now() - periodDays * 24 * 60 * 60 * 1000);
+  const query = `created_at:>='${sinceDate.toISOString()}'`;
+
+  const orders: OrderData[] = [];
+  let cursor: string | null = null;
+  let page = 0;
+
+  while (page < MAX_PAGES) {
+    const response = await fetch(
+      `https://${shop}/admin/api/${apiVersion}/graphql.json`,
+      {
+        method: "POST",
+        headers: {
+          "X-Shopify-Access-Token": accessToken,
+          "Content-Type": "application/json",
+        },
+        body: JSON.stringify({
+          query: ORDERS_QUERY,
+          variables: { query, cursor },
+        }),
+      }
+    );
+
+    if (!response.ok) {
+      console.error(
+        `[StoreGuard] Orders API returned ${response.status} for ${shop}`
+      );
+      break;
+    }
+
+    const data = (await response.json()) as {
+      data?: {
+        orders?: {
+          edges: Array<{
+            node: {
+              id: string;
+              createdAt: string;
+              lineItems: {
+                edges: Array<{
+                  node: {
+                    product: { id: string } | null;
+                    variant: { id: string } | null;
+                    quantity: number;
+                    originalUnitPriceSet: {
+                      shopMoney: { amount: string };
+                    } | null;
+                  };
+                }>;
+              };
+            };
+          }>;
+          pageInfo: {
+            hasNextPage: boolean;
+            endCursor: string | null;
+          };
+        };
+      };
+      errors?: Array<{ message: string }>;
+    };
+
+    if (data.errors?.length) {
+      console.error(
+        `[StoreGuard] Orders GraphQL errors:`,
+        data.errors.map((e) => e.message).join(", ")
+      );
+      break;
+    }
+
+    const edges = data.data?.orders?.edges ?? [];
+
+    for (const edge of edges) {
+      const lineItems = edge.node.lineItems.edges
+        .map((li) => ({
+          productId: extractId(li.node.product?.id),
+          variantId: extractId(li.node.variant?.id),
+          quantity: li.node.quantity,
+          price: parseFloat(
+            li.node.originalUnitPriceSet?.shopMoney?.amount ?? "0"
+          ),
+        }))
+        .filter((li) => li.productId !== "");
+
+      if (lineItems.length > 0) {
+        orders.push({
+          id: extractId(edge.node.id),
+          createdAt: edge.node.createdAt,
+          lineItems,
+        });
+      }
+    }
+
+    const pageInfo = data.data?.orders?.pageInfo;
+    if (!pageInfo?.hasNextPage || !pageInfo.endCursor) {
+      break;
+    }
+
+    cursor = pageInfo.endCursor;
+    page++;
+  }
+
+  if (page >= MAX_PAGES) {
+    console.log(
+      `[StoreGuard] Hit max page limit (${MAX_PAGES}) for ${shop}, processed ${orders.length} orders`
+    );
+  }
+
+  return orders;
+}
+
+/**
+ * Get sales velocity for all products in a shop.
+ * Uses cursor-based pagination to handle any order volume.
+ * Results are cached for 5 minutes to avoid redundant API calls.
+ *
+ * @param shop - Shop domain
+ * @param periodDays - Number of days to look back (default: 30)
+ */
+export async function getShopSalesVelocity(
+  shop: string,
+  periodDays: number = 30
+): Promise<Map<string, ProductVelocity>> {
+  // Check cache
+  const cacheKey = `${shop}:${periodDays}`;
+  const cached = velocityCache.get(cacheKey);
+  if (cached && cached.expiresAt > Date.now()) {
+    return cached.data;
+  }
+
+  // Get access token from session
+  const session = await db.session.findFirst({
+    where: { shop },
+    select: { accessToken: true },
+  });
+
+  if (!session?.accessToken) {
+    console.log(
+      `[StoreGuard] No session for ${shop}, cannot fetch sales velocity`
+    );
+    return new Map();
+  }
+
+  try {
+    const orders = await fetchOrders(shop, session.accessToken, periodDays);
+    const velocityMap = calculateProductVelocity(orders, periodDays);
+
+    // Cache the result
+    velocityCache.set(cacheKey, {
+      data: velocityMap,
+      expiresAt: Date.now() + CACHE_TTL_MS,
+    });
+
+    console.log(
+      `[StoreGuard] Calculated sales velocity for ${shop}: ${orders.length} orders, ${velocityMap.size} products`
+    );
+
+    return velocityMap;
+  } catch (error) {
+    console.error(
+      `[StoreGuard] Failed to fetch sales velocity for ${shop}:`,
+      error
+    );
+    return new Map();
+  }
+}
+
+/**
+ * Get sales velocity for a single product.
+ * Fetches shop-wide velocity (cached) and returns the product's data.
+ */
+export async function getProductSalesVelocity(
+  shop: string,
+  productId: string,
+  periodDays: number = 30
+): Promise<ProductVelocity | null> {
+  const velocityMap = await getShopSalesVelocity(shop, periodDays);
+  return velocityMap.get(productId) ?? null;
+}
+
+/**
+ * Clear the velocity cache for a shop.
+ * Call this when order data may have changed.
+ */
+export function clearVelocityCache(shop?: string): void {
+  if (shop) {
+    for (const key of velocityCache.keys()) {
+      if (key.startsWith(`${shop}:`)) {
+        velocityCache.delete(key);
+      }
+    }
+  } else {
+    velocityCache.clear();
+  }
+}
diff --git a/insightops/app/services/salesVelocity.test.ts b/insightops/app/services/salesVelocity.test.ts
new file mode 100644
index 0000000..150c457
--- /dev/null
+++ b/insightops/app/services/salesVelocity.test.ts
@@ -0,0 +1,290 @@
+import { describe, it, expect } from "vitest";
+import {
+  calculateProductVelocity,
+  getProductVelocity,
+  formatVelocityContext,
+  estimateRevenueImpact,
+  type OrderData,
+  type ProductVelocity,
+} from "./salesVelocity.utils";
+
+describe("calculateProductVelocity", () => {
+  it("should calculate velocity for a single product across multiple orders", () => {
+    const orders: OrderData[] = [
+      {
+        id: "1",
+        createdAt: "2026-02-15T10:00:00Z",
+        lineItems: [
+          { productId: "100", variantId: "200", quantity: 2, price: 50 },
+        ],
+      },
+      {
+        id: "2",
+        createdAt: "2026-02-16T10:00:00Z",
+        lineItems: [
+          { productId: "100", variantId: "200", quantity: 3, price: 50 },
+        ],
+      },
+    ];
+
+    const result = calculateProductVelocity(orders, 30);
+    const velocity = result.get("100");
+
+    expect(velocity).toBeDefined();
+    expect(velocity!.totalUnitsSold).toBe(5);
+    expect(velocity!.totalRevenue).toBe(250); // 5 * 50
+    expect(velocity!.orderCount).toBe(2);
+    expect(velocity!.dailySalesRate).toBeCloseTo(5 / 30);
+    expect(velocity!.dailyRevenue).toBeCloseTo(250 / 30);
+    expect(velocity!.periodDays).toBe(30);
+  });
+
+  it("should calculate velocity for multiple products", () => {
+    const orders: OrderData[] = [
+      {
+        id: "1",
+        createdAt: "2026-02-15T10:00:00Z",
+        lineItems: [
+          { productId: "100", variantId: "200", quantity: 1, price: 50 },
+          { productId: "101", variantId: "201", quantity: 3, price: 20 },
+        ],
+      },
+      {
+        id: "2",
+        createdAt: "2026-02-16T10:00:00Z",
+        lineItems: [
+          { productId: "100", variantId: "200", quantity: 1, price: 50 },
+        ],
+      },
+    ];
+
+    const result = calculateProductVelocity(orders, 7);
+
+    expect(result.size).toBe(2);
+    expect(result.get("100")!.totalUnitsSold).toBe(2);
+    expect(result.get("100")!.orderCount).toBe(2);
+    expect(result.get("101")!.totalUnitsSold).toBe(3);
+    expect(result.get("101")!.orderCount).toBe(1);
+  });
+
+  it("should handle empty orders", () => {
+    const result = calculateProductVelocity([], 30);
+    expect(result.size).toBe(0);
+  });
+
+  it("should use minimum 1 day for period to avoid division by zero", () => {
+    const orders: OrderData[] = [
+      {
+        id: "1",
+        createdAt: "2026-02-15T10:00:00Z",
+        lineItems: [
+          { productId: "100", variantId: "200", quantity: 5, price: 10 },
+        ],
+      },
+    ];
+
+    const result = calculateProductVelocity(orders, 0);
+    const velocity = result.get("100");
+    expect(velocity!.dailySalesRate).toBe(5); // 5 units / 1 day
+    expect(velocity!.periodDays).toBe(1);
+  });
+
+  it("should count same order only once in orderCount even with multiple line items", () => {
+    const orders: OrderData[] = [
+      {
+        id: "1",
+        createdAt: "2026-02-15T10:00:00Z",
+        lineItems: [
+          { productId: "100", variantId: "200", quantity: 1, price: 50 },
+          { productId: "100", variantId: "201", quantity: 2, price: 40 },
+        ],
+      },
+    ];
+
+    const result = calculateProductVelocity(orders, 30);
+    const velocity = result.get("100");
+    expect(velocity!.totalUnitsSold).toBe(3);
+    expect(velocity!.totalRevenue).toBe(130); // 1*50 + 2*40
+    expect(velocity!.orderCount).toBe(1); // Same order
+  });
+});
+
+describe("getProductVelocity", () => {
+  it("should return velocity for existing product", () => {
+    const map = new Map<string, ProductVelocity>();
+    map.set("100", {
+      productId: "100",
+      totalUnitsSold: 10,
+      totalRevenue: 500,
+      orderCount: 5,
+      dailySalesRate: 2,
+      dailyRevenue: 100,
+      periodDays: 5,
+    });
+
+    expect(getProductVelocity(map, "100")).toBeDefined();
+    expect(getProductVelocity(map, "100")!.totalUnitsSold).toBe(10);
+  });
+
+  it("should return null for non-existing product", () => {
+    const map = new Map<string, ProductVelocity>();
+    expect(getProductVelocity(map, "999")).toBeNull();
+  });
+});
+
+describe("formatVelocityContext", () => {
+  it("should return null for null velocity", () => {
+    expect(formatVelocityContext(null)).toBeNull();
+  });
+
+  it("should return null for zero sales", () => {
+    expect(
+      formatVelocityContext({
+        productId: "100",
+        totalUnitsSold: 0,
+        totalRevenue: 0,
+        orderCount: 0,
+        dailySalesRate: 0,
+        dailyRevenue: 0,
+        periodDays: 30,
+      })
+    ).toBeNull();
+  });
+
+  it("should format high velocity (>=1/day)", () => {
+    expect(
+      formatVelocityContext({
+        productId: "100",
+        totalUnitsSold: 240,
+        totalRevenue: 12000,
+        orderCount: 200,
+        dailySalesRate: 8,
+        dailyRevenue: 400,
+        periodDays: 30,
+      })
+    ).toBe("selling 8/day");
+  });
+
+  it("should round high velocity", () => {
+    expect(
+      formatVelocityContext({
+        productId: "100",
+        totalUnitsSold: 100,
+        totalRevenue: 5000,
+        orderCount: 80,
+        dailySalesRate: 3.33,
+        dailyRevenue: 166.5,
+        periodDays: 30,
+      })
+    ).toBe("selling 3/day");
+  });
+
+  it("should format moderate velocity (~1/week or more)", () => {
+    expect(
+      formatVelocityContext({
+        productId: "100",
+        totalUnitsSold: 6,
+        totalRevenue: 300,
+        orderCount: 6,
+        dailySalesRate: 0.2,
+        dailyRevenue: 10,
+        periodDays: 30,
+      })
+    ).toBe("selling ~1/week");
+  });
+
+  it("should format low velocity (total count)", () => {
+    expect(
+      formatVelocityContext({
+        productId: "100",
+        totalUnitsSold: 3,
+        totalRevenue: 150,
+        orderCount: 3,
+        dailySalesRate: 0.1,
+        dailyRevenue: 5,
+        periodDays: 30,
+      })
+    ).toBe("sold 3 in the last 30 days");
+  });
+});
+
+describe("estimateRevenueImpact", () => {
+  const highVelocity: ProductVelocity = {
+    productId: "100",
+    totalUnitsSold: 240,
+    totalRevenue: 12000,
+    orderCount: 200,
+    dailySalesRate: 8,
+    dailyRevenue: 400,
+    periodDays: 30,
+  };
+
+  it("should return null for null velocity", () => {
+    expect(estimateRevenueImpact(null, "price_error", { priceDifference: 10 })).toBeNull();
+  });
+
+  it("should return null for zero daily sales rate", () => {
+    const zeroVelocity: ProductVelocity = {
+      ...highVelocity,
+      dailySalesRate: 0,
+    };
+    expect(estimateRevenueImpact(zeroVelocity, "price_error", { priceDifference: 10 })).toBeNull();
+  });
+
+  it("should calculate price error impact with 50% conservative factor", () => {
+    // hourlySalesRate = 8/24 = 0.333
+    // impact = 0.333 * 2 hours * $40 diff * 0.5 = $13.33
+    const result = estimateRevenueImpact(highVelocity, "price_error", {
+      priceDifference: 40,
+      hoursUntilDiscovery: 2,
+    });
+    expect(result).toBeCloseTo(13.33, 1);
+  });
+
+  it("should use default 2 hours for discovery time", () => {
+    const result = estimateRevenueImpact(highVelocity, "price_error", {
+      priceDifference: 40,
+    });
+    // Same calc as above: 0.333 * 2 * 40 * 0.5 = 13.33
+    expect(result).toBeCloseTo(13.33, 1);
+  });
+
+  it("should return null for zero price difference on price error", () => {
+    expect(
+      estimateRevenueImpact(highVelocity, "price_error", { priceDifference: 0 })
+    ).toBeNull();
+  });
+
+  it("should calculate stockout impact", () => {
+    // hourlySalesRate = 8/24 = 0.333
+    // avgPrice = 400/8 = 50
+    // impact = 0.333 * 2 * 50 * 0.5 = 16.67
+    const result = estimateRevenueImpact(highVelocity, "stockout", {});
+    expect(result).toBeCloseTo(16.67, 0);
+  });
+
+  it("should calculate visibility impact", () => {
+    // Same as stockout
+    const result = estimateRevenueImpact(highVelocity, "visibility", {});
+    expect(result).toBeCloseTo(16.67, 0);
+  });
+
+  it("should use custom item price when provided", () => {
+    // hourlySalesRate = 8/24 = 0.333
+    // impact = 0.333 * 2 * 100 * 0.5 = 33.33
+    const result = estimateRevenueImpact(highVelocity, "stockout", {
+      itemPrice: 100,
+    });
+    expect(result).toBeCloseTo(33.33, 1);
+  });
+
+  it("should use custom hours until discovery", () => {
+    // hourlySalesRate = 8/24 = 0.333
+    // avgPrice = 50
+    // impact = 0.333 * 24 * 50 * 0.5 = 200
+    const result = estimateRevenueImpact(highVelocity, "stockout", {
+      hoursUntilDiscovery: 24,
+    });
+    expect(result).toBeCloseTo(200, 0);
+  });
+});
diff --git a/insightops/app/services/salesVelocity.utils.ts b/insightops/app/services/salesVelocity.utils.ts
new file mode 100644
index 0000000..379e6b6
--- /dev/null
+++ b/insightops/app/services/salesVelocity.utils.ts
@@ -0,0 +1,159 @@
+/**
+ * Pure utility functions for sales velocity calculations.
+ * Extracted for testability â€” no database or API calls.
+ */
+
+export interface OrderLineItem {
+  productId: string;
+  variantId: string;
+  quantity: number;
+  price: number;
+}
+
+export interface OrderData {
+  id: string;
+  createdAt: string; // ISO date
+  lineItems: OrderLineItem[];
+}
+
+export interface ProductVelocity {
+  productId: string;
+  totalUnitsSold: number;
+  totalRevenue: number;
+  orderCount: number;
+  dailySalesRate: number; // units per day
+  dailyRevenue: number; // revenue per day
+  periodDays: number;
+}
+
+/**
+ * Calculate sales velocity for each product from a list of orders.
+ * Uses the actual date range of orders (not a fixed window) for accuracy.
+ */
+export function calculateProductVelocity(
+  orders: OrderData[],
+  periodDays: number
+): Map<string, ProductVelocity> {
+  const productStats = new Map<
+    string,
+    { totalUnits: number; totalRevenue: number; orderIds: Set<string> }
+  >();
+
+  for (const order of orders) {
+    for (const item of order.lineItems) {
+      const existing = productStats.get(item.productId);
+      if (existing) {
+        existing.totalUnits += item.quantity;
+        existing.totalRevenue += item.quantity * item.price;
+        existing.orderIds.add(order.id);
+      } else {
+        productStats.set(item.productId, {
+          totalUnits: item.quantity,
+          totalRevenue: item.quantity * item.price,
+          orderIds: new Set([order.id]),
+        });
+      }
+    }
+  }
+
+  const effectiveDays = Math.max(periodDays, 1);
+  const result = new Map<string, ProductVelocity>();
+
+  for (const [productId, stats] of productStats) {
+    result.set(productId, {
+      productId,
+      totalUnitsSold: stats.totalUnits,
+      totalRevenue: stats.totalRevenue,
+      orderCount: stats.orderIds.size,
+      dailySalesRate: stats.totalUnits / effectiveDays,
+      dailyRevenue: stats.totalRevenue / effectiveDays,
+      periodDays: effectiveDays,
+    });
+  }
+
+  return result;
+}
+
+/**
+ * Get velocity for a single product from a velocity map.
+ */
+export function getProductVelocity(
+  velocityMap: Map<string, ProductVelocity>,
+  productId: string
+): ProductVelocity | null {
+  return velocityMap.get(productId) ?? null;
+}
+
+/**
+ * Format sales velocity as a human-readable string for alert context.
+ * Examples:
+ *   "selling 8/day" (high velocity)
+ *   "selling ~1/day" (moderate)
+ *   "sold 3 in the last 30 days" (low)
+ *   null (no sales data)
+ */
+export function formatVelocityContext(
+  velocity: ProductVelocity | null
+): string | null {
+  if (!velocity || velocity.totalUnitsSold === 0) {
+    return null;
+  }
+
+  if (velocity.dailySalesRate >= 1) {
+    const rounded = Math.round(velocity.dailySalesRate);
+    return `selling ${rounded}/day`;
+  }
+
+  if (velocity.dailySalesRate >= 0.14) {
+    // ~1/week or more
+    const weeklyRate = Math.round(velocity.dailySalesRate * 7);
+    return `selling ~${weeklyRate}/week`;
+  }
+
+  // Low velocity â€” just show total
+  return `sold ${velocity.totalUnitsSold} in the last ${velocity.periodDays} days`;
+}
+
+/**
+ * Estimate revenue impact for a stockout or pricing error.
+ *
+ * Price error: Daily Sales Rate * Hours Until Discovery * Price Difference
+ * Stockout: Daily Sales Rate * Hours Out of Stock * Average Item Price
+ */
+export function estimateRevenueImpact(
+  velocity: ProductVelocity | null,
+  type: "price_error" | "stockout" | "visibility",
+  params: {
+    priceDifference?: number; // For price errors
+    hoursUntilDiscovery?: number; // Default: 2 hours
+    itemPrice?: number; // For stockout/visibility
+  }
+): number | null {
+  if (!velocity || velocity.dailySalesRate === 0) {
+    return null;
+  }
+
+  const hourlySalesRate = velocity.dailySalesRate / 24;
+  const hours = params.hoursUntilDiscovery ?? 2;
+
+  switch (type) {
+    case "price_error": {
+      const priceDiff = params.priceDifference ?? 0;
+      if (priceDiff <= 0) return null;
+      // Conservative: 50% of calculated impact
+      return Math.round(hourlySalesRate * hours * priceDiff * 0.5 * 100) / 100;
+    }
+    case "stockout": {
+      const price = params.itemPrice ?? velocity.dailyRevenue / velocity.dailySalesRate;
+      // Conservative: 50% of calculated impact
+      return Math.round(hourlySalesRate * hours * price * 0.5 * 100) / 100;
+    }
+    case "visibility": {
+      const price = params.itemPrice ?? velocity.dailyRevenue / velocity.dailySalesRate;
+      // Conservative: 50% of calculated impact
+      return Math.round(hourlySalesRate * hours * price * 0.5 * 100) / 100;
+    }
+    default:
+      return null;
+  }
+}
diff --git a/insightops/prisma/schema.prisma b/insightops/prisma/schema.prisma
index 72a2545..ba5f87d 100644
--- a/insightops/prisma/schema.prisma
+++ b/insightops/prisma/schema.prisma
@@ -66,6 +66,7 @@ model ChangeEvent {
   importance   String    @default("medium") // "high" | "medium" | "low"
   groupId      String?   // For grouping related changes (e.g. bulk edit session)
   webhookId    String    @unique // Deduplication
+  contextData  String?   // JSON: sales velocity, revenue impact, business context
 
   @@index([shop])
   @@index([shop, detectedAt])

==========================================
BRANCH: v2/p1-multi-location-inventory
==========================================
diff --git a/insightops/app/services/changeDetection.server.ts b/insightops/app/services/changeDetection.server.ts
index 8d0a946..6b19fc4 100644
--- a/insightops/app/services/changeDetection.server.ts
+++ b/insightops/app/services/changeDetection.server.ts
@@ -320,6 +320,9 @@ export async function detectVisibilityChanges(
  * Detect inventory hitting zero
  * Explicit rule: Only triggers on transition >0 â†’ 0
  * Does NOT trigger on: 0 â†’ 0, negative â†’ 0, or any other scenario
+ *
+ * Multi-location aware: newQuantity and previousQuantity should be TOTAL
+ * across all locations. locationContext provides human-readable detail.
  */
 export async function detectInventoryZero(
   shop: string,
@@ -329,7 +332,8 @@ export async function detectInventoryZero(
   variantTitle: string,
   newQuantity: number,
   previousQuantity: number | null, // Must be provided from webhook processing
-  webhookId: string
+  webhookId: string,
+  locationContext?: string
 ): Promise<boolean> {
   // Check if shop wants to track inventory
   if (!await canTrackFeature(shop, "inventory")) {
@@ -357,6 +361,11 @@ export async function detectInventoryZero(
     return false;
   }
 
+  // afterValue includes location context for multi-location stores
+  const afterValue = locationContext
+    ? `0 (${locationContext})`
+    : "0";
+
   await createChangeEvent({
     shop,
     entityType: "variant",
@@ -364,7 +373,7 @@ export async function detectInventoryZero(
     eventType: "inventory_zero",
     resourceName: formatVariantLabel(productTitle, variantTitle),
     beforeValue: String(previousQuantity),
-    afterValue: "0",
+    afterValue,
     webhookId: `${webhookId}-inventory-zero-${inventoryItemId}`,
     importance: "high", // Out of stock is always high importance
   });
@@ -376,6 +385,9 @@ export async function detectInventoryZero(
  * Detect inventory dropping below low stock threshold
  * Triggers when quantity crosses from above threshold to at or below threshold
  * Does NOT trigger on: already below threshold, or at zero (that's inventory_zero)
+ *
+ * Multi-location aware: newQuantity and previousQuantity should be TOTAL
+ * across all locations. locationContext provides human-readable detail.
  */
 export async function detectLowStock(
   shop: string,
@@ -385,7 +397,8 @@ export async function detectLowStock(
   variantTitle: string,
   newQuantity: number,
   previousQuantity: number | null,
-  webhookId: string
+  webhookId: string,
+  locationContext?: string
 ): Promise<boolean> {
   // Get the shop's low stock threshold
   const threshold = await getLowStockThreshold(shop);
@@ -416,6 +429,11 @@ export async function detectLowStock(
 
   const displayName = formatVariantLabel(productTitle, variantTitle);
 
+  // afterValue includes location context for multi-location stores
+  const afterValue = locationContext
+    ? `${newQuantity} (${locationContext})`
+    : String(newQuantity);
+
   await createChangeEvent({
     shop,
     entityType: "variant",
@@ -423,12 +441,12 @@ export async function detectLowStock(
     eventType: "inventory_low",
     resourceName: displayName,
     beforeValue: String(previousQuantity),
-    afterValue: String(newQuantity),
+    afterValue,
     webhookId: `${webhookId}-inventory-low-${inventoryItemId}`,
     importance: "medium", // Low stock is medium importance (zero is high)
   });
 
-  console.log(`[StoreGuard] Low stock alert: ${displayName} dropped to ${newQuantity} (threshold: ${threshold})`);
+  console.log(`[StoreGuard] Low stock alert: ${displayName} dropped to ${newQuantity} total (threshold: ${threshold})`);
 
   return true;
 }
diff --git a/insightops/app/services/changeDetection.test.ts b/insightops/app/services/changeDetection.test.ts
index 22e5097..676307d 100644
--- a/insightops/app/services/changeDetection.test.ts
+++ b/insightops/app/services/changeDetection.test.ts
@@ -6,6 +6,11 @@ import {
   shouldAlertInventoryZero,
   shouldAlertLowStock,
   formatVariantLabel,
+  computeTotalInventory,
+  buildLocationContext,
+  shouldAlertInventoryZeroMultiLocation,
+  shouldAlertLowStockMultiLocation,
+  type LocationInventory,
 } from "./changeDetection.utils";
 
 describe("calculatePriceImportance", () => {
@@ -155,3 +160,139 @@ describe("formatVariantLabel", () => {
     expect(formatVariantLabel("Widget", null)).toBe("Widget");
   });
 });
+
+// ============================================
+// Multi-Location Inventory Tests
+// ============================================
+
+describe("computeTotalInventory", () => {
+  it("should sum inventory across multiple locations", () => {
+    const locations: LocationInventory[] = [
+      { locationId: "loc1", locationName: "Warehouse NYC", available: 10 },
+      { locationId: "loc2", locationName: "Warehouse LA", available: 20 },
+      { locationId: "loc3", locationName: "Store Front", available: 5 },
+    ];
+    expect(computeTotalInventory(locations)).toBe(35);
+  });
+
+  it("should return 0 for all-zero locations", () => {
+    const locations: LocationInventory[] = [
+      { locationId: "loc1", locationName: "Warehouse NYC", available: 0 },
+      { locationId: "loc2", locationName: "Warehouse LA", available: 0 },
+    ];
+    expect(computeTotalInventory(locations)).toBe(0);
+  });
+
+  it("should return the value for a single location", () => {
+    const locations: LocationInventory[] = [
+      { locationId: "loc1", locationName: "Main Warehouse", available: 42 },
+    ];
+    expect(computeTotalInventory(locations)).toBe(42);
+  });
+
+  it("should return 0 for empty array", () => {
+    expect(computeTotalInventory([])).toBe(0);
+  });
+});
+
+describe("buildLocationContext", () => {
+  const threeLocations: LocationInventory[] = [
+    { locationId: "loc1", locationName: "Warehouse NYC", available: 0 },
+    { locationId: "loc2", locationName: "Warehouse LA", available: 30 },
+    { locationId: "loc3", locationName: "Store Front", available: 15 },
+  ];
+
+  it("should describe one location hitting zero with stock remaining elsewhere", () => {
+    const context = buildLocationContext("Warehouse NYC", 0, threeLocations);
+    expect(context).toBe("Warehouse NYC hit zero, but 45 units remain across 2 other locations");
+  });
+
+  it("should describe completely out of stock across all locations", () => {
+    const allZero: LocationInventory[] = [
+      { locationId: "loc1", locationName: "Warehouse NYC", available: 0 },
+      { locationId: "loc2", locationName: "Warehouse LA", available: 0 },
+      { locationId: "loc3", locationName: "Store Front", available: 0 },
+    ];
+    const context = buildLocationContext("Warehouse NYC", 0, allZero);
+    expect(context).toBe("Completely out of stock across all 3 locations");
+  });
+
+  it("should describe low stock at triggering location with stock elsewhere", () => {
+    const locations: LocationInventory[] = [
+      { locationId: "loc1", locationName: "Warehouse NYC", available: 2 },
+      { locationId: "loc2", locationName: "Warehouse LA", available: 30 },
+    ];
+    const context = buildLocationContext("Warehouse NYC", 2, locations);
+    expect(context).toBe("Warehouse NYC has 2 left, 30 units at 1 other location");
+  });
+
+  it("should handle single location at zero", () => {
+    const singleZero: LocationInventory[] = [
+      { locationId: "loc1", locationName: "Main Warehouse", available: 0 },
+    ];
+    const context = buildLocationContext("Main Warehouse", 0, singleZero);
+    expect(context).toBe("Out of stock");
+  });
+
+  it("should handle single location with stock", () => {
+    const singleLoc: LocationInventory[] = [
+      { locationId: "loc1", locationName: "Main Warehouse", available: 3 },
+    ];
+    const context = buildLocationContext("Main Warehouse", 3, singleLoc);
+    expect(context).toBe("Main Warehouse has 3 left (only location)");
+  });
+
+  it("should use singular 'unit' for 1 remaining unit", () => {
+    const locations: LocationInventory[] = [
+      { locationId: "loc1", locationName: "Warehouse NYC", available: 0 },
+      { locationId: "loc2", locationName: "Warehouse LA", available: 1 },
+    ];
+    const context = buildLocationContext("Warehouse NYC", 0, locations);
+    expect(context).toBe("Warehouse NYC hit zero, but 1 unit remains across 1 other location");
+  });
+});
+
+describe("shouldAlertInventoryZeroMultiLocation", () => {
+  it("should alert when total across all locations drops to zero", () => {
+    // Total was 10, now 0 (all locations depleted)
+    expect(shouldAlertInventoryZeroMultiLocation(0, 10)).toBe(true);
+  });
+
+  it("should NOT alert when only one location hits zero but total is positive", () => {
+    // One location hit 0, but total is still 45
+    // The caller passes totalAvailable, not per-location
+    expect(shouldAlertInventoryZeroMultiLocation(45, 55)).toBe(false);
+  });
+
+  it("should NOT alert when total was already zero", () => {
+    expect(shouldAlertInventoryZeroMultiLocation(0, 0)).toBe(false);
+  });
+
+  it("should NOT alert when previous total is unknown", () => {
+    expect(shouldAlertInventoryZeroMultiLocation(0, null)).toBe(false);
+  });
+});
+
+describe("shouldAlertLowStockMultiLocation", () => {
+  it("should alert when total drops below threshold", () => {
+    // Total was 10, now 3 (threshold 5)
+    expect(shouldAlertLowStockMultiLocation(3, 10, 5)).toBe(true);
+  });
+
+  it("should NOT alert when total is still above threshold", () => {
+    // One location dropped, but total is still 45 (threshold 5)
+    expect(shouldAlertLowStockMultiLocation(45, 55, 5)).toBe(false);
+  });
+
+  it("should NOT alert when total was already below threshold", () => {
+    expect(shouldAlertLowStockMultiLocation(2, 3, 5)).toBe(false);
+  });
+
+  it("should NOT alert when total is zero (handled by inventory_zero)", () => {
+    expect(shouldAlertLowStockMultiLocation(0, 10, 5)).toBe(false);
+  });
+
+  it("should NOT alert when previous total is unknown", () => {
+    expect(shouldAlertLowStockMultiLocation(3, null, 5)).toBe(false);
+  });
+});
diff --git a/insightops/app/services/changeDetection.utils.ts b/insightops/app/services/changeDetection.utils.ts
index cf64cce..394b3a5 100644
--- a/insightops/app/services/changeDetection.utils.ts
+++ b/insightops/app/services/changeDetection.utils.ts
@@ -102,3 +102,89 @@ export function formatVariantLabel(
   }
   return `${productTitle} - ${variantTitle}`;
 }
+
+// ============================================
+// Multi-Location Inventory Utilities
+// ============================================
+
+export interface LocationInventory {
+  locationId: string;
+  locationName: string;
+  available: number;
+}
+
+export interface MultiLocationResult {
+  totalAvailable: number;
+  locations: LocationInventory[];
+  locationCount: number;
+}
+
+/**
+ * Compute total available inventory across all locations.
+ */
+export function computeTotalInventory(locations: LocationInventory[]): number {
+  return locations.reduce((sum, loc) => sum + loc.available, 0);
+}
+
+/**
+ * Build a human-readable location context string for alerts.
+ * Examples:
+ *  - "Warehouse NYC hit zero, but 45 units remain across 2 other locations"
+ *  - "Completely out of stock across all 3 locations"
+ *  - "Stock low at Warehouse NYC (2 left), 45 units remain across 2 other locations"
+ */
+export function buildLocationContext(
+  triggeringLocationName: string,
+  triggeringLocationAvailable: number,
+  allLocations: LocationInventory[]
+): string {
+  const otherLocations = allLocations.filter(
+    (loc) => loc.locationName !== triggeringLocationName
+  );
+  const totalOther = otherLocations.reduce((sum, loc) => sum + loc.available, 0);
+  const totalAll = triggeringLocationAvailable + totalOther;
+
+  if (totalAll === 0) {
+    if (allLocations.length === 1) {
+      return "Out of stock";
+    }
+    return `Completely out of stock across all ${allLocations.length} locations`;
+  }
+
+  if (triggeringLocationAvailable === 0 && totalOther > 0) {
+    const otherCount = otherLocations.length;
+    const unitWord = totalOther !== 1 ? "units" : "unit";
+    const remainWord = totalOther !== 1 ? "remain" : "remains";
+    return `${triggeringLocationName} hit zero, but ${totalOther} ${unitWord} ${remainWord} across ${otherCount} other location${otherCount !== 1 ? "s" : ""}`;
+  }
+
+  if (totalOther > 0) {
+    const otherCount = otherLocations.length;
+    return `${triggeringLocationName} has ${triggeringLocationAvailable} left, ${totalOther} unit${totalOther !== 1 ? "s" : ""} at ${otherCount} other location${otherCount !== 1 ? "s" : ""}`;
+  }
+
+  return `${triggeringLocationName} has ${triggeringLocationAvailable} left (only location)`;
+}
+
+/**
+ * Determine if an inventory_zero alert should fire considering multi-location.
+ * Only alert when total inventory across ALL locations is zero.
+ */
+export function shouldAlertInventoryZeroMultiLocation(
+  totalAvailable: number,
+  previousTotalAvailable: number | null
+): boolean {
+  return shouldAlertInventoryZero(totalAvailable, previousTotalAvailable);
+}
+
+/**
+ * Determine if an inventory_low alert should fire considering multi-location.
+ * Uses total inventory across ALL locations against the threshold.
+ */
+export function shouldAlertLowStockMultiLocation(
+  totalAvailable: number,
+  previousTotalAvailable: number | null,
+  threshold: number
+): boolean {
+  return shouldAlertLowStock(totalAvailable, previousTotalAvailable, threshold);
+}
diff --git a/insightops/app/services/emailService.server.ts b/insightops/app/services/emailService.server.ts
index caada3b..6bf77ca 100644
--- a/insightops/app/services/emailService.server.ts
+++ b/insightops/app/services/emailService.server.ts
@@ -235,6 +235,10 @@ function formatChangeDescription(event: DigestSummary["eventsByType"]["price_cha
     case "inventory_low":
       return `Stock dropped to ${event.afterValue} units (was ${event.beforeValue}) â€¢ ${time}`;
     case "inventory_zero":
+      // afterValue may contain location context
+      if (event.afterValue && event.afterValue !== "0") {
+        return `${event.afterValue} (was ${event.beforeValue} units) â€¢ ${time}`;
+      }
       return `Now out of stock (was ${event.beforeValue} units) â€¢ ${time}`;
     case "theme_publish":
       return `Now your live theme â€¢ ${time}`;
@@ -345,10 +349,14 @@ function generateInstantAlertHtml(
       changeDescription = `Status changed from ${event.beforeValue} to ${event.afterValue}`;
       break;
     case "inventory_low":
+      // afterValue may contain location context, e.g. "3 (Warehouse NYC has 3 left, 10 units at 2 other locations)"
       changeDescription = `Stock dropped to ${event.afterValue} units (was ${event.beforeValue})`;
       break;
     case "inventory_zero":
-      changeDescription = `Now out of stock (was ${event.beforeValue} units)`;
+      // afterValue may contain location context, e.g. "0 (Warehouse NYC hit zero, but 45 units remain across 2 other locations)"
+      changeDescription = event.afterValue && event.afterValue !== "0"
+        ? `${event.afterValue} (was ${event.beforeValue} units)`
+        : `Now out of stock (was ${event.beforeValue} units)`;
       break;
     case "theme_publish":
       changeDescription = `"${event.resourceName}" is now your live theme`;
diff --git a/insightops/app/services/jobProcessor.server.ts b/insightops/app/services/jobProcessor.server.ts
index 7068c66..87eff51 100644
--- a/insightops/app/services/jobProcessor.server.ts
+++ b/insightops/app/services/jobProcessor.server.ts
@@ -12,6 +12,12 @@ import {
   detectLowStock,
   deleteProductSnapshot,
 } from "./changeDetection.server";
+import {
+  type LocationInventory,
+  type MultiLocationResult,
+  computeTotalInventory,
+  buildLocationContext,
+} from "./changeDetection.utils";
 
 // Full product payload from Shopify webhook
 interface ProductPayload {
@@ -568,12 +574,136 @@ async function processCollection(
   console.log(`[StoreGuard] Logged: ${message}`);
 }
 
+/**
+ * Fetch all inventory levels across all locations for an inventory item.
+ * Uses Shopify GraphQL to get a complete picture of multi-location inventory.
+ */
+async function fetchAllLocationInventory(
+  shop: string,
+  accessToken: string,
+  inventoryItemId: number
+): Promise<MultiLocationResult | null> {
+  try {
+    const gql = await fetch(`https://${shop}/admin/api/${apiVersion}/graphql.json`, {
+      method: "POST",
+      headers: {
+        "X-Shopify-Access-Token": accessToken,
+        "Content-Type": "application/json",
+      },
+      body: JSON.stringify({
+        query: `#graphql
+          query InventoryLevels($inventoryItemId: ID!) {
+            inventoryItem(id: $inventoryItemId) {
+              inventoryLevels(first: 50) {
+                edges {
+                  node {
+                    quantities(names: ["available"]) {
+                      name
+                      quantity
+                    }
+                    location {
+                      id
+                      name
+                    }
+                  }
+                }
+              }
+            }
+          }`,
+        variables: { inventoryItemId: `gid://shopify/InventoryItem/${inventoryItemId}` },
+      }),
+    });
+
+    const data = (await gql.json()) as any;
+    const edges = data?.data?.inventoryItem?.inventoryLevels?.edges;
+    if (!edges || edges.length === 0) return null;
+
+    const locations: LocationInventory[] = edges.map((edge: any) => {
+      const node = edge.node;
+      const availableQty = node.quantities?.find((q: any) => q.name === "available");
+      return {
+        locationId: node.location.id,
+        locationName: node.location.name,
+        available: availableQty?.quantity ?? 0,
+      };
+    });
+
+    return {
+      totalAvailable: computeTotalInventory(locations),
+      locations,
+      locationCount: locations.length,
+    };
+  } catch (error) {
+    console.error(`[StoreGuard] Failed to fetch multi-location inventory:`, error);
+    return null;
+  }
+}
+
+/**
+ * Get the previous total inventory across all locations for an inventory item.
+ * Stored in EventLog diff as `totalAvailable`.
+ * Falls back to single-location `available` for backwards compatibility.
+ */
+async function getPreviousTotalInventory(
+  shop: string,
+  inventoryItemId: string,
+  productId: string,
+  variantId: string
+): Promise<number | null> {
+  let oldTotal: number | null = null;
+
+  try {
+    const previousEvent = await db.eventLog.findFirst({
+      where: {
+        shop,
+        shopifyId: inventoryItemId,
+        topic: "INVENTORY_LEVELS_UPDATE",
+      },
+      orderBy: { timestamp: "desc" },
+    });
+
+    if (previousEvent?.diff) {
+      const prevDiff = JSON.parse(previousEvent.diff);
+      // Prefer totalAvailable (multi-location aware) over available (single-location)
+      if (prevDiff.totalAvailable !== undefined && prevDiff.totalAvailable !== null) {
+        oldTotal = prevDiff.totalAvailable;
+      } else if (prevDiff.available !== undefined && prevDiff.available !== null) {
+        // Backwards compat: old events before multi-location support
+        oldTotal = prevDiff.available;
+      }
+    }
+
+    // Fall back to ProductSnapshot
+    if (oldTotal === null && productId && variantId) {
+      const snapshot = await db.productSnapshot.findUnique({
+        where: { shop_id: { shop, id: productId } },
+      });
+      if (snapshot?.variants) {
+        try {
+          const variants = JSON.parse(snapshot.variants) as Array<{ id: string; inventoryQuantity: number }>;
+          const matchingVariant = variants.find(v => v.id === variantId);
+          if (matchingVariant && matchingVariant.inventoryQuantity !== undefined) {
+            oldTotal = matchingVariant.inventoryQuantity;
+            console.log(`[StoreGuard] Got previous inventory ${oldTotal} from ProductSnapshot`);
+          }
+        } catch {
+          // Invalid JSON in snapshot
+        }
+      }
+    }
+  } catch (prevError) {
+    console.error(`[StoreGuard] Failed to fetch previous inventory:`, prevError);
+  }
+
+  return oldTotal;
+}
+
 /**
  * Process an inventory update job
  *
- * NOTE: Once the orders/paid webhook is enabled (requires Protected Customer Data approval),
- * the noise filter below will automatically hide inventory updates caused by orders.
- * Until then, we keep logging inventory updates so the app isn't blind to sales activity.
+ * Multi-location aware: When an inventory_levels/update webhook fires for one location,
+ * we query ALL locations for that inventory item to get the true total sellable quantity.
+ * This prevents false "out of stock" alerts when only one warehouse hits zero.
  */
 async function processInventoryUpdate(
   shop: string,
@@ -670,98 +800,97 @@ async function processInventoryUpdate(
     }
   }
 
-  // Get previous inventory level for diff display AND for >0â†’0 detection
-  // Strategy: Check EventLog first (most recent), then fall back to ProductSnapshot
-  let oldAvailable: number | null = null;
-  try {
-    // First, try EventLog (recent inventory updates)
-    const previousEvent = await db.eventLog.findFirst({
-      where: {
-        shop,
-        shopifyId: String(payload.inventory_item_id),
-        topic: "INVENTORY_LEVELS_UPDATE",
-      },
-      orderBy: { timestamp: "desc" },
-    });
+  // === Multi-Location Inventory Aggregation ===
+  // Fetch ALL inventory levels across all locations for this item.
+  // The webhook only tells us about ONE location â€” we need the full picture.
+  let multiLocationData: MultiLocationResult | null = null;
+  let totalAvailable = payload.available; // Fallback to single-location value
+  let locationContext = "";
+  let triggeringLocationName = "";
+
+  multiLocationData = await fetchAllLocationInventory(shop, accessToken, payload.inventory_item_id);
+  if (multiLocationData && multiLocationData.locationCount > 0) {
+    totalAvailable = multiLocationData.totalAvailable;
+
+    // Find the triggering location name
+    const triggeringLoc = multiLocationData.locations.find(
+      (loc) => loc.locationId === `gid://shopify/Location/${payload.location_id}`
+    );
+    triggeringLocationName = triggeringLoc?.locationName ?? `Location ${payload.location_id}`;
 
-    if (previousEvent?.diff) {
-      const prevDiff = JSON.parse(previousEvent.diff);
-      oldAvailable = prevDiff.available;
-    }
+    locationContext = buildLocationContext(
+      triggeringLocationName,
+      payload.available,
+      multiLocationData.locations
+    );
 
-    // If no EventLog, fall back to ProductSnapshot
-    if (oldAvailable === null && productId && variantId) {
-      const snapshot = await db.productSnapshot.findUnique({
-        where: { shop_id: { shop, id: productId } },
-      });
-      if (snapshot?.variants) {
-        try {
-          const variants = JSON.parse(snapshot.variants) as Array<{ id: string; inventoryQuantity: number }>;
-          const matchingVariant = variants.find(v => v.id === variantId);
-          if (matchingVariant && matchingVariant.inventoryQuantity !== undefined) {
-            oldAvailable = matchingVariant.inventoryQuantity;
-            console.log(`[StoreGuard] Got previous inventory ${oldAvailable} from ProductSnapshot for ${productTitle}`);
-          }
-        } catch {
-          // Invalid JSON in snapshot
-        }
-      }
-    }
-  } catch (prevError) {
-    console.error(`[StoreGuard] Failed to fetch previous inventory:`, prevError);
+    console.log(
+      `[StoreGuard] Multi-location inventory for ${productTitle}: ` +
+      `${payload.available} at ${triggeringLocationName}, ` +
+      `${totalAvailable} total across ${multiLocationData.locationCount} locations`
+    );
   }
 
-  // === StoreGuard: Detect inventory changes ===
+  // Get previous TOTAL inventory for transition detection
+  const oldTotalAvailable = await getPreviousTotalInventory(
+    shop,
+    String(payload.inventory_item_id),
+    productId,
+    variantId
+  );
+
+  // === StoreGuard: Detect inventory changes using TOTAL inventory ===
   if (productId && webhookId) {
-    // Detect low stock (crossing below threshold)
+    // Detect low stock (crossing below threshold) â€” using total across all locations
     const lowStockDetected = await detectLowStock(
       shop,
       String(payload.inventory_item_id),
       productId,
       productTitle,
       variantTitle,
-      payload.available,
-      oldAvailable,
-      webhookId
+      totalAvailable,
+      oldTotalAvailable,
+      webhookId,
+      locationContext || undefined
     );
 
     // Detect inventory hitting zero (only if not already low stock alert)
-    // Rule: Only triggers on >0 â†’ 0 transition
-    if (payload.available === 0 && !lowStockDetected) {
+    // Rule: Only triggers on >0 â†’ 0 transition, using TOTAL inventory
+    if (totalAvailable === 0 && !lowStockDetected) {
       await detectInventoryZero(
         shop,
         String(payload.inventory_item_id),
         productId,
         productTitle,
         variantTitle,
-        payload.available,
-        oldAvailable,
-        webhookId
+        totalAvailable,
+        oldTotalAvailable,
+        webhookId,
+        locationContext || undefined
       );
     }
   }
 
-  // Update or create ProductSnapshot with inventory (keeps snapshot current for future comparisons)
+  // Update or create ProductSnapshot with TOTAL inventory
   if (productId && variantId) {
     try {
       const snapshot = await db.productSnapshot.findUnique({
         where: { shop_id: { shop, id: productId } },
       });
       if (snapshot?.variants) {
-        // Update existing snapshot
+        // Update existing snapshot with total inventory
         const variants = JSON.parse(snapshot.variants) as Array<{ id: string; title: string; price: string; inventoryQuantity: number }>;
         const variantIndex = variants.findIndex(v => v.id === variantId);
         if (variantIndex >= 0) {
-          variants[variantIndex].inventoryQuantity = payload.available;
+          variants[variantIndex].inventoryQuantity = totalAvailable;
           await db.productSnapshot.update({
             where: { shop_id: { shop, id: productId } },
             data: { variants: JSON.stringify(variants) },
           });
-          console.log(`[StoreGuard] Updated ProductSnapshot inventory for ${productTitle}: ${payload.available}`);
+          console.log(`[StoreGuard] Updated ProductSnapshot inventory for ${productTitle}: ${totalAvailable} (total)`);
         }
       } else if (!snapshot) {
         // No snapshot exists - create a minimal one for future tracking
-        // This ensures the NEXT inventory change can be detected
         await db.productSnapshot.create({
           data: {
             id: productId,
@@ -772,7 +901,7 @@ async function processInventoryUpdate(
               id: variantId,
               title: variantTitle || "Default Title",
               price: "0.00",
-              inventoryQuantity: payload.available,
+              inventoryQuantity: totalAvailable,
             }]),
           },
         });
@@ -790,28 +919,37 @@ async function processInventoryUpdate(
 
   // Create a clear message showing stock change
   let message: string;
-  if (oldAvailable !== null && oldAvailable !== payload.available) {
-    const change = payload.available - oldAvailable;
+  if (oldTotalAvailable !== null && oldTotalAvailable !== totalAvailable) {
+    const change = totalAvailable - oldTotalAvailable;
     const arrow = change > 0 ? "â†‘" : "â†“";
-    message = `Stock ${arrow} "${displayName}" (${oldAvailable} â†’ ${payload.available})`;
+    message = `Stock ${arrow} "${displayName}" (${oldTotalAvailable} â†’ ${totalAvailable} total)`;
   } else {
-    message = `Stock updated: "${displayName}" (${payload.available} units)`;
+    message = `Stock updated: "${displayName}" (${totalAvailable} units total)`;
+  }
+
+  // Add location context to message if multi-location
+  if (multiLocationData && multiLocationData.locationCount > 1) {
+    message += ` [${triggeringLocationName}: ${payload.available}]`;
   }
 
   const diff = JSON.stringify({
     available: payload.available,
+    totalAvailable,
     inventoryChange:
-      oldAvailable !== null && oldAvailable !== payload.available
-        ? { old: oldAvailable, new: payload.available }
+      oldTotalAvailable !== null && oldTotalAvailable !== totalAvailable
+        ? { old: oldTotalAvailable, new: totalAvailable }
         : null,
     locationId: payload.location_id,
+    locationName: triggeringLocationName || undefined,
+    locationCount: multiLocationData?.locationCount ?? 1,
+    locations: multiLocationData?.locations ?? undefined,
   });
 
   await db.eventLog.create({
     data: {
       shop,
       // Use inventory_item_id consistently for inventory events
-      // This matches the lookup in getPreviousInventory above
+      // This matches the lookup in getPreviousTotalInventory above
       shopifyId: String(payload.inventory_item_id),
       topic: "INVENTORY_LEVELS_UPDATE",
       author: "System/App",
@@ -821,7 +959,7 @@ async function processInventoryUpdate(
     },
   });
 
-  console.log(`[StoreGuard] âœ… Logged: ${message}`);
+  console.log(`[StoreGuard] Logged: ${message}`);
 }
 
 /**

==========================================
BRANCH: v2/p1-collection-monitoring
==========================================
diff --git a/insightops/app/routes/app.changes.tsx b/insightops/app/routes/app.changes.tsx
index 26d7faf..89e222e 100644
--- a/insightops/app/routes/app.changes.tsx
+++ b/insightops/app/routes/app.changes.tsx
@@ -41,6 +41,9 @@ const eventConfig: Record<string, { label: string; color: string }> = {
   inventory_low: { label: "Low Stock", color: "#f97316" },
   inventory_zero: { label: "Out of Stock", color: "#e74c3c" },
   theme_publish: { label: "Theme Published", color: "#3498db" },
+  collection_created: { label: "Collection Created", color: "#10b981" },
+  collection_products_changed: { label: "Collection Changed", color: "#10b981" },
+  collection_deleted: { label: "Collection Deleted", color: "#e74c3c" },
 };
 
 const importanceConfig: Record<string, { label: string; color: string }> = {
diff --git a/insightops/app/routes/app.settings.tsx b/insightops/app/routes/app.settings.tsx
index 1ec2a02..e7339d3 100644
--- a/insightops/app/routes/app.settings.tsx
+++ b/insightops/app/routes/app.settings.tsx
@@ -28,6 +28,7 @@ export const action = async ({ request }: ActionFunctionArgs): Promise<ActionRes
   const trackVisibility = formData.get("trackVisibility") === "on";
   const trackInventory = formData.get("trackInventory") === "on";
   const trackThemes = formData.get("trackThemes") === "on";
+  const trackCollections = formData.get("trackCollections") === "on";
   const lowStockThreshold = parseInt(formData.get("lowStockThreshold") as string) || 5;
   const instantAlerts = formData.get("instantAlerts") === "on";
 
@@ -50,6 +51,7 @@ export const action = async ({ request }: ActionFunctionArgs): Promise<ActionRes
       trackVisibility,
       trackInventory,
       trackThemes,
+      trackCollections,
       lowStockThreshold,
       instantAlerts,
     });
@@ -200,6 +202,12 @@ export default function Settings() {
               </label>
             </div>
           )}
+          <Toggle
+            name="trackCollections"
+            label="Collection changes"
+            description="Track when collections are created, updated, or deleted"
+            defaultChecked={settings.trackCollections}
+          />
           <Toggle
             name="trackThemes"
             label="Theme publishes"
diff --git a/insightops/app/services/changeDetection.server.ts b/insightops/app/services/changeDetection.server.ts
index 8d0a946..33ae787 100644
--- a/insightops/app/services/changeDetection.server.ts
+++ b/insightops/app/services/changeDetection.server.ts
@@ -48,6 +48,17 @@ interface ThemePayload {
   role: string;
 }
 
+// Collection payload from webhook
+interface CollectionPayload {
+  id: number;
+  title: string;
+  handle: string;
+  body_html: string | null;
+  published_scope: string;
+  sort_order: string;
+  collection_type?: string; // "smart" or "custom" (manual)
+}
+
 /**
  * Get or create a ProductSnapshot for comparison
  */
@@ -104,9 +115,9 @@ async function updateProductSnapshot(
  */
 async function createChangeEvent(data: {
   shop: string;
-  entityType: "product" | "variant" | "theme";
+  entityType: "product" | "variant" | "theme" | "collection";
   entityId: string;
-  eventType: "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish";
+  eventType: "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish" | "collection_created" | "collection_products_changed" | "collection_deleted";
   resourceName: string;
   beforeValue: string | null;
   afterValue: string | null;
@@ -471,6 +482,93 @@ export async function recordThemePublish(
   return true;
 }
 
+/**
+ * Record a collection created event
+ */
+export async function recordCollectionCreated(
+  shop: string,
+  collection: CollectionPayload,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "collections")) {
+    return false;
+  }
+
+  const collectionType = collection.collection_type === "smart" ? "smart" : "manual";
+
+  await createChangeEvent({
+    shop,
+    entityType: "collection",
+    entityId: String(collection.id),
+    eventType: "collection_created",
+    resourceName: collection.title,
+    beforeValue: null,
+    afterValue: collectionType,
+    webhookId: `${webhookId}-collection-created`,
+    importance: "medium",
+  });
+
+  return true;
+}
+
+/**
+ * Record a collection update event (products changed, rules changed, etc.)
+ */
+export async function recordCollectionUpdated(
+  shop: string,
+  collection: CollectionPayload,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "collections")) {
+    return false;
+  }
+
+  const collectionType = collection.collection_type === "smart" ? "smart" : "manual";
+
+  await createChangeEvent({
+    shop,
+    entityType: "collection",
+    entityId: String(collection.id),
+    eventType: "collection_products_changed",
+    resourceName: collection.title,
+    beforeValue: null,
+    afterValue: `updated (${collectionType})`,
+    webhookId: `${webhookId}-collection-updated`,
+    importance: "medium",
+  });
+
+  return true;
+}
+
+/**
+ * Record a collection deleted event
+ * Deletion is high importance because it can break storefront links
+ */
+export async function recordCollectionDeleted(
+  shop: string,
+  collectionId: string,
+  collectionTitle: string,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "collections")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "collection",
+    entityId: collectionId,
+    eventType: "collection_deleted",
+    resourceName: collectionTitle,
+    beforeValue: collectionTitle,
+    afterValue: "deleted",
+    webhookId: `${webhookId}-collection-deleted`,
+    importance: "high", // Deletions break storefront links
+  });
+
+  return true;
+}
+
 /**
  * Process a product update and detect all relevant changes
  * This is the main entry point called from jobProcessor
diff --git a/insightops/app/services/dailyDigest.server.ts b/insightops/app/services/dailyDigest.server.ts
index 5120737..9fe5ed4 100644
--- a/insightops/app/services/dailyDigest.server.ts
+++ b/insightops/app/services/dailyDigest.server.ts
@@ -33,6 +33,9 @@ export interface DigestSummary {
     inventory_low: DigestEvent[];
     inventory_zero: DigestEvent[];
     theme_publish: DigestEvent[];
+    collection_created: DigestEvent[];
+    collection_products_changed: DigestEvent[];
+    collection_deleted: DigestEvent[];
   };
 }
 
@@ -116,6 +119,9 @@ export async function generateDigestForShop(shopDomain: string): Promise<DigestS
     inventory_low: [] as DigestEvent[],
     inventory_zero: [] as DigestEvent[],
     theme_publish: [] as DigestEvent[],
+    collection_created: [] as DigestEvent[],
+    collection_products_changed: [] as DigestEvent[],
+    collection_deleted: [] as DigestEvent[],
   };
 
   let highPriorityCount = 0;
@@ -185,6 +191,9 @@ export function getEventIdsFromDigest(digest: DigestSummary): string[] {
     ...digest.eventsByType.inventory_low,
     ...digest.eventsByType.inventory_zero,
     ...digest.eventsByType.theme_publish,
+    ...digest.eventsByType.collection_created,
+    ...digest.eventsByType.collection_products_changed,
+    ...digest.eventsByType.collection_deleted,
   ];
 
   return allEvents.map((e) => e.id);
@@ -205,6 +214,12 @@ export function formatEventType(eventType: string): string {
       return "Out of Stock";
     case "theme_publish":
       return "Theme Published";
+    case "collection_created":
+      return "Collection Created";
+    case "collection_products_changed":
+      return "Collection Changed";
+    case "collection_deleted":
+      return "Collection Deleted";
     default:
       return eventType;
   }
@@ -231,6 +246,12 @@ export function formatEventForEmail(event: DigestEvent): string {
       return `${event.resourceName}: now out of stock (was ${event.beforeValue} units) (${time})`;
     case "theme_publish":
       return `"${event.resourceName}" is now your live theme (${time})`;
+    case "collection_created":
+      return `"${event.resourceName}" collection created (${event.afterValue}) (${time})`;
+    case "collection_products_changed":
+      return `"${event.resourceName}" collection was updated (${time})`;
+    case "collection_deleted":
+      return `"${event.resourceName}" collection was deleted (${time})`;
     default:
       return `${event.resourceName}: ${event.beforeValue} â†’ ${event.afterValue} (${time})`;
   }
diff --git a/insightops/app/services/dailyDigest.test.ts b/insightops/app/services/dailyDigest.test.ts
index 3341142..1b08b88 100644
--- a/insightops/app/services/dailyDigest.test.ts
+++ b/insightops/app/services/dailyDigest.test.ts
@@ -37,6 +37,9 @@ function makeDigest(overrides: Partial<DigestSummary> = {}): DigestSummary {
       inventory_low: [],
       inventory_zero: [],
       theme_publish: [],
+      collection_created: [],
+      collection_products_changed: [],
+      collection_deleted: [],
     },
     ...overrides,
   };
@@ -56,16 +59,21 @@ describe("getEventIdsFromDigest", () => {
         inventory_low: [],
         inventory_zero: [makeEvent({ id: "iz-1" })],
         theme_publish: [makeEvent({ id: "tp-1" })],
+        collection_created: [makeEvent({ id: "cc-1" })],
+        collection_products_changed: [],
+        collection_deleted: [makeEvent({ id: "cd-1" })],
       },
     });
 
     const ids = getEventIdsFromDigest(digest);
-    expect(ids).toHaveLength(5);
+    expect(ids).toHaveLength(7);
     expect(ids).toContain("pc-1");
     expect(ids).toContain("pc-2");
     expect(ids).toContain("vc-1");
     expect(ids).toContain("iz-1");
     expect(ids).toContain("tp-1");
+    expect(ids).toContain("cc-1");
+    expect(ids).toContain("cd-1");
   });
 
   it("should handle digest with events in only one category", () => {
@@ -76,6 +84,9 @@ describe("getEventIdsFromDigest", () => {
         inventory_low: [],
         inventory_zero: [],
         theme_publish: [],
+        collection_created: [],
+        collection_products_changed: [],
+        collection_deleted: [],
       },
     });
 
@@ -104,6 +115,18 @@ describe("formatEventType", () => {
     expect(formatEventType("theme_publish")).toBe("Theme Published");
   });
 
+  it("should format collection_created", () => {
+    expect(formatEventType("collection_created")).toBe("Collection Created");
+  });
+
+  it("should format collection_products_changed", () => {
+    expect(formatEventType("collection_products_changed")).toBe("Collection Changed");
+  });
+
+  it("should format collection_deleted", () => {
+    expect(formatEventType("collection_deleted")).toBe("Collection Deleted");
+  });
+
   it("should return raw event type for unknown types", () => {
     expect(formatEventType("unknown_event")).toBe("unknown_event");
   });
@@ -181,4 +204,47 @@ describe("formatEventForEmail", () => {
     expect(result).toContain("Dawn 2.0");
     expect(result).toContain("live theme");
   });
+
+  it("should format collection created event", () => {
+    const event = makeEvent({
+      eventType: "collection_created",
+      entityType: "collection",
+      resourceName: "Summer Sale",
+      beforeValue: null,
+      afterValue: "manual",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("Summer Sale");
+    expect(result).toContain("created");
+    expect(result).toContain("manual");
+  });
+
+  it("should format collection products changed event", () => {
+    const event = makeEvent({
+      eventType: "collection_products_changed",
+      entityType: "collection",
+      resourceName: "Featured",
+      beforeValue: null,
+      afterValue: "updated (manual)",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("Featured");
+    expect(result).toContain("updated");
+  });
+
+  it("should format collection deleted event", () => {
+    const event = makeEvent({
+      eventType: "collection_deleted",
+      entityType: "collection",
+      resourceName: "Winter Clearance",
+      beforeValue: "Winter Clearance",
+      afterValue: "deleted",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("Winter Clearance");
+    expect(result).toContain("deleted");
+  });
 });
diff --git a/insightops/app/services/emailService.server.ts b/insightops/app/services/emailService.server.ts
index caada3b..d9519f5 100644
--- a/insightops/app/services/emailService.server.ts
+++ b/insightops/app/services/emailService.server.ts
@@ -127,6 +127,20 @@ export function generateDigestEmailHtml(digest: DigestSummary): string {
     ));
   }
 
+  // Collection changes (combine all collection event types into one section)
+  const collectionEvents = [
+    ...digest.eventsByType.collection_created,
+    ...digest.eventsByType.collection_products_changed,
+    ...digest.eventsByType.collection_deleted,
+  ];
+  if (collectionEvents.length > 0) {
+    sections.push(buildEventSection(
+      "ðŸ“ Collection Changes",
+      collectionEvents,
+      "#10b981" // emerald
+    ));
+  }
+
   const sectionsHtml = sections.join("");
 
   // Summary stats
@@ -238,6 +252,12 @@ function formatChangeDescription(event: DigestSummary["eventsByType"]["price_cha
       return `Now out of stock (was ${event.beforeValue} units) â€¢ ${time}`;
     case "theme_publish":
       return `Now your live theme â€¢ ${time}`;
+    case "collection_created":
+      return `New collection created (${event.afterValue}) â€¢ ${time}`;
+    case "collection_products_changed":
+      return `Collection was updated â€¢ ${time}`;
+    case "collection_deleted":
+      return `Collection was deleted â€¢ ${time}`;
     default:
       return `${event.beforeValue} â†’ ${event.afterValue} â€¢ ${time}`;
   }
@@ -283,6 +303,12 @@ function getInstantAlertSubject(event: InstantAlertEvent, shopName: string): str
       return `ðŸš¨ Out of stock: ${event.resourceName} - ${shopName}`;
     case "theme_publish":
       return `ðŸŽ¨ Theme published: ${event.resourceName} - ${shopName}`;
+    case "collection_created":
+      return `ðŸ“ Collection created: ${event.resourceName} - ${shopName}`;
+    case "collection_products_changed":
+      return `ðŸ“ Collection changed: ${event.resourceName} - ${shopName}`;
+    case "collection_deleted":
+      return `ðŸš¨ Collection deleted: ${event.resourceName} - ${shopName}`;
     default:
       return `âš¡ Change detected: ${event.resourceName} - ${shopName}`;
   }
@@ -298,6 +324,9 @@ function getAlertIcon(eventType: string): string {
     case "inventory_low": return "âš ï¸";
     case "inventory_zero": return "ðŸš¨";
     case "theme_publish": return "ðŸŽ¨";
+    case "collection_created": return "ðŸ“";
+    case "collection_products_changed": return "ðŸ“";
+    case "collection_deleted": return "ðŸš¨";
     default: return "âš¡";
   }
 }
@@ -312,6 +341,9 @@ function getAlertColor(eventType: string): string {
     case "inventory_low": return "#f97316";
     case "inventory_zero": return "#ef4444";
     case "theme_publish": return "#06b6d4";
+    case "collection_created": return "#10b981";
+    case "collection_products_changed": return "#10b981";
+    case "collection_deleted": return "#ef4444";
     default: return "#6b7280";
   }
 }
@@ -353,6 +385,15 @@ function generateInstantAlertHtml(
     case "theme_publish":
       changeDescription = `"${event.resourceName}" is now your live theme`;
       break;
+    case "collection_created":
+      changeDescription = `New collection "${event.resourceName}" was created (${event.afterValue})`;
+      break;
+    case "collection_products_changed":
+      changeDescription = `Collection "${event.resourceName}" was updated`;
+      break;
+    case "collection_deleted":
+      changeDescription = `Collection "${event.resourceName}" was deleted â€” this may break storefront links`;
+      break;
     default:
       changeDescription = `${event.beforeValue || ""} â†’ ${event.afterValue || ""}`;
   }
diff --git a/insightops/app/services/jobProcessor.server.ts b/insightops/app/services/jobProcessor.server.ts
index 7068c66..7ef8805 100644
--- a/insightops/app/services/jobProcessor.server.ts
+++ b/insightops/app/services/jobProcessor.server.ts
@@ -11,6 +11,9 @@ import {
   detectInventoryZero,
   detectLowStock,
   deleteProductSnapshot,
+  recordCollectionCreated,
+  recordCollectionUpdated,
+  recordCollectionDeleted,
 } from "./changeDetection.server";
 
 // Full product payload from Shopify webhook
@@ -533,6 +536,11 @@ async function processCollection(
     const displayName = title || `Collection #${collectionId}`;
     const message = `Collection deleted: "${displayName}"`;
 
+    // === StoreGuard: Create ChangeEvent for collection delete ===
+    if (webhookId) {
+      await recordCollectionDeleted(shop, collectionId, displayName, webhookId);
+    }
+
     await db.eventLog.create({
       data: {
         shop,
@@ -553,6 +561,15 @@ async function processCollection(
   const author = (await fetchAuthor(shop, accessToken, "Collection", collection.id, verb)) || "System/App";
   const message = `${author} ${verb}d collection "${collection.title}"`;
 
+  // === StoreGuard: Create ChangeEvent for collection create/update ===
+  if (webhookId) {
+    if (verb === "create") {
+      await recordCollectionCreated(shop, collection, webhookId);
+    } else if (verb === "update") {
+      await recordCollectionUpdated(shop, collection, webhookId);
+    }
+  }
+
   await db.eventLog.create({
     data: {
       shop,
diff --git a/insightops/app/services/shopService.server.ts b/insightops/app/services/shopService.server.ts
index a11cccd..83f2e97 100644
--- a/insightops/app/services/shopService.server.ts
+++ b/insightops/app/services/shopService.server.ts
@@ -7,6 +7,7 @@ export interface ShopSettings {
   trackVisibility: boolean;
   trackInventory: boolean;
   trackThemes: boolean;
+  trackCollections: boolean;
   lowStockThreshold: number;
   instantAlerts: boolean;
 }
@@ -27,6 +28,7 @@ export async function getOrCreateShop(shopDomain: string): Promise<ShopSettings>
       trackVisibility: true,
       trackInventory: true,
       trackThemes: false, // Pro only by default
+      trackCollections: true,
       installedAt: new Date(),
     },
     update: {
@@ -44,6 +46,7 @@ export async function getOrCreateShop(shopDomain: string): Promise<ShopSettings>
     trackVisibility: shop.trackVisibility,
     trackInventory: shop.trackInventory,
     trackThemes: shop.trackThemes,
+    trackCollections: shop.trackCollections,
     lowStockThreshold: shop.lowStockThreshold,
     instantAlerts: shop.instantAlerts,
   };
@@ -67,6 +70,7 @@ export async function getShopSettings(shopDomain: string): Promise<ShopSettings
     trackVisibility: shop.trackVisibility,
     trackInventory: shop.trackInventory,
     trackThemes: shop.trackThemes,
+    trackCollections: shop.trackCollections,
     lowStockThreshold: shop.lowStockThreshold,
     instantAlerts: shop.instantAlerts,
   };
@@ -115,6 +119,7 @@ export async function updateShopSettings(
       trackVisibility: settings.trackVisibility ?? shop.trackVisibility,
       trackInventory: settings.trackInventory ?? shop.trackInventory,
       trackThemes,
+      trackCollections: settings.trackCollections ?? shop.trackCollections,
       lowStockThreshold,
       instantAlerts,
     },
@@ -129,6 +134,7 @@ export async function updateShopSettings(
     trackVisibility: updated.trackVisibility,
     trackInventory: updated.trackInventory,
     trackThemes: updated.trackThemes,
+    trackCollections: updated.trackCollections,
     lowStockThreshold: updated.lowStockThreshold,
     instantAlerts: updated.instantAlerts,
   };
@@ -195,7 +201,7 @@ export async function isProPlan(shopDomain: string): Promise<boolean> {
  */
 export async function canTrackFeature(
   shopDomain: string,
-  feature: "prices" | "visibility" | "inventory" | "themes"
+  feature: "prices" | "visibility" | "inventory" | "themes" | "collections"
 ): Promise<boolean> {
   const shop = await db.shop.findUnique({
     where: { shopifyDomain: shopDomain },
@@ -212,6 +218,8 @@ export async function canTrackFeature(
       return shop.trackInventory;
     case "themes":
       return shop.plan === "pro" && shop.trackThemes;
+    case "collections":
+      return shop.trackCollections;
     default:
       return false;
   }
diff --git a/insightops/prisma/schema.prisma b/insightops/prisma/schema.prisma
index 72a2545..515d077 100644
--- a/insightops/prisma/schema.prisma
+++ b/insightops/prisma/schema.prisma
@@ -41,6 +41,7 @@ model Shop {
   trackVisibility Boolean   @default(true)
   trackInventory  Boolean   @default(true)
   trackThemes     Boolean   @default(false) // Pro only
+  trackCollections Boolean  @default(true) // Free + Pro
   lowStockThreshold Int     @default(5) // Alert when inventory drops below this
   instantAlerts   Boolean   @default(false) // Send alerts immediately (Pro only)
   installedAt     DateTime  @default(now())
diff --git a/insightops/shopify.app.toml b/insightops/shopify.app.toml
index 62dc11a..2231d5a 100644
--- a/insightops/shopify.app.toml
+++ b/insightops/shopify.app.toml
@@ -43,6 +43,18 @@ api_version = "2025-10"
   topics = [ "themes/publish" ]
   uri = "/webhooks/themes/publish"
 
+  [[webhooks.subscriptions]]
+  topics = [ "collections/create" ]
+  uri = "/webhooks/collections/create"
+
+  [[webhooks.subscriptions]]
+  topics = [ "collections/update" ]
+  uri = "/webhooks/collections/update"
+
+  [[webhooks.subscriptions]]
+  topics = [ "collections/delete" ]
+  uri = "/webhooks/collections/delete"
+
 [access_scopes]
 # Learn more at https://shopify.dev/docs/apps/tools/cli/configuration#access_scopes
 # StoreGuard scopes: products for change detection, inventory for stock alerts, themes for publish tracking

==========================================
BRANCH: v2/p1-discount-monitoring
==========================================
diff --git a/insightops/app/routes/app.changes.tsx b/insightops/app/routes/app.changes.tsx
index 26d7faf..c7cc65a 100644
--- a/insightops/app/routes/app.changes.tsx
+++ b/insightops/app/routes/app.changes.tsx
@@ -41,6 +41,9 @@ const eventConfig: Record<string, { label: string; color: string }> = {
   inventory_low: { label: "Low Stock", color: "#f97316" },
   inventory_zero: { label: "Out of Stock", color: "#e74c3c" },
   theme_publish: { label: "Theme Published", color: "#3498db" },
+  discount_created: { label: "Discount Created", color: "#10b981" },
+  discount_changed: { label: "Discount Changed", color: "#f59e0b" },
+  discount_deleted: { label: "Discount Deleted", color: "#ef4444" },
 };
 
 const importanceConfig: Record<string, { label: string; color: string }> = {
diff --git a/insightops/app/routes/app.settings.tsx b/insightops/app/routes/app.settings.tsx
index 1ec2a02..76968f0 100644
--- a/insightops/app/routes/app.settings.tsx
+++ b/insightops/app/routes/app.settings.tsx
@@ -28,6 +28,7 @@ export const action = async ({ request }: ActionFunctionArgs): Promise<ActionRes
   const trackVisibility = formData.get("trackVisibility") === "on";
   const trackInventory = formData.get("trackInventory") === "on";
   const trackThemes = formData.get("trackThemes") === "on";
+  const trackDiscounts = formData.get("trackDiscounts") === "on";
   const lowStockThreshold = parseInt(formData.get("lowStockThreshold") as string) || 5;
   const instantAlerts = formData.get("instantAlerts") === "on";
 
@@ -50,6 +51,7 @@ export const action = async ({ request }: ActionFunctionArgs): Promise<ActionRes
       trackVisibility,
       trackInventory,
       trackThemes,
+      trackDiscounts,
       lowStockThreshold,
       instantAlerts,
     });
@@ -208,6 +210,14 @@ export default function Settings() {
             disabled={settings.plan !== "pro"}
             proOnly
           />
+          <Toggle
+            name="trackDiscounts"
+            label="Discount changes"
+            description="Track when discount codes are created, modified, or deleted"
+            defaultChecked={settings.trackDiscounts}
+            disabled={settings.plan !== "pro"}
+            proOnly
+          />
         </Section>
 
         {/* 2. Your Plan */}
diff --git a/insightops/app/routes/webhooks.discounts.create.tsx b/insightops/app/routes/webhooks.discounts.create.tsx
new file mode 100644
index 0000000..cbd6320
--- /dev/null
+++ b/insightops/app/routes/webhooks.discounts.create.tsx
@@ -0,0 +1,54 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob, isWebhookProcessed } from "../services/jobQueue.server";
+
+interface DiscountWebhookPayload {
+  id: number;
+  title: string;
+  code?: string;
+  value_type?: string;
+  value?: string;
+  usage_limit?: number | null;
+  ends_at?: string | null;
+  starts_at?: string | null;
+  status?: string;
+  discount_type?: string;
+}
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    console.log(`No session found for ${shop}, skipping`);
+    return new Response();
+  }
+
+  if (webhookId && await isWebhookProcessed(webhookId)) {
+    console.log(`[StoreGuard] Duplicate webhook ${webhookId}, skipping`);
+    return new Response();
+  }
+
+  const discount = payload as DiscountWebhookPayload;
+
+  try {
+    await queueWebhookJob({
+      shop,
+      topic,
+      resourceId: String(discount.id),
+      payload: discount,
+      webhookId: webhookId || undefined,
+      delayMs: 2000,
+    });
+
+    console.log(`[StoreGuard] Queued ${topic} for discount ${discount.id}`);
+  } catch (error) {
+    console.error(`[StoreGuard] Failed to queue job:`, error);
+  }
+
+  return new Response();
+};
diff --git a/insightops/app/routes/webhooks.discounts.delete.tsx b/insightops/app/routes/webhooks.discounts.delete.tsx
new file mode 100644
index 0000000..471eced
--- /dev/null
+++ b/insightops/app/routes/webhooks.discounts.delete.tsx
@@ -0,0 +1,46 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob, isWebhookProcessed } from "../services/jobQueue.server";
+
+interface DiscountDeletePayload {
+  id: number;
+  title?: string;
+}
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    console.log(`No session found for ${shop}, skipping`);
+    return new Response();
+  }
+
+  if (webhookId && await isWebhookProcessed(webhookId)) {
+    console.log(`[StoreGuard] Duplicate webhook ${webhookId}, skipping`);
+    return new Response();
+  }
+
+  const discount = payload as DiscountDeletePayload;
+
+  try {
+    await queueWebhookJob({
+      shop,
+      topic,
+      resourceId: String(discount.id),
+      payload: discount,
+      webhookId: webhookId || undefined,
+      delayMs: 0, // Process immediately for deletes
+    });
+
+    console.log(`[StoreGuard] Queued ${topic} for discount ${discount.id}`);
+  } catch (error) {
+    console.error(`[StoreGuard] Failed to queue job:`, error);
+  }
+
+  return new Response();
+};
diff --git a/insightops/app/routes/webhooks.discounts.update.tsx b/insightops/app/routes/webhooks.discounts.update.tsx
new file mode 100644
index 0000000..cbd6320
--- /dev/null
+++ b/insightops/app/routes/webhooks.discounts.update.tsx
@@ -0,0 +1,54 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob, isWebhookProcessed } from "../services/jobQueue.server";
+
+interface DiscountWebhookPayload {
+  id: number;
+  title: string;
+  code?: string;
+  value_type?: string;
+  value?: string;
+  usage_limit?: number | null;
+  ends_at?: string | null;
+  starts_at?: string | null;
+  status?: string;
+  discount_type?: string;
+}
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    console.log(`No session found for ${shop}, skipping`);
+    return new Response();
+  }
+
+  if (webhookId && await isWebhookProcessed(webhookId)) {
+    console.log(`[StoreGuard] Duplicate webhook ${webhookId}, skipping`);
+    return new Response();
+  }
+
+  const discount = payload as DiscountWebhookPayload;
+
+  try {
+    await queueWebhookJob({
+      shop,
+      topic,
+      resourceId: String(discount.id),
+      payload: discount,
+      webhookId: webhookId || undefined,
+      delayMs: 2000,
+    });
+
+    console.log(`[StoreGuard] Queued ${topic} for discount ${discount.id}`);
+  } catch (error) {
+    console.error(`[StoreGuard] Failed to queue job:`, error);
+  }
+
+  return new Response();
+};
diff --git a/insightops/app/services/changeDetection.server.ts b/insightops/app/services/changeDetection.server.ts
index 8d0a946..49cccbc 100644
--- a/insightops/app/services/changeDetection.server.ts
+++ b/insightops/app/services/changeDetection.server.ts
@@ -8,6 +8,8 @@ import {
   shouldAlertInventoryZero as checkInventoryZero,
   shouldAlertLowStock as checkLowStock,
   formatVariantLabel,
+  calculateDiscountImportance,
+  buildDiscountContext,
 } from "./changeDetection.utils";
 
 /**
@@ -104,9 +106,9 @@ async function updateProductSnapshot(
  */
 async function createChangeEvent(data: {
   shop: string;
-  entityType: "product" | "variant" | "theme";
+  entityType: "product" | "variant" | "theme" | "discount";
   entityId: string;
-  eventType: "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish";
+  eventType: "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish" | "discount_created" | "discount_changed" | "discount_deleted";
   resourceName: string;
   beforeValue: string | null;
   afterValue: string | null;
@@ -498,3 +500,151 @@ export async function deleteProductSnapshot(shop: string, productId: string): Pr
     // Snapshot may not exist
   }
 }
+
+// ============================================
+// DISCOUNT MONITORING
+// ============================================
+
+// Discount payload from Shopify webhook
+interface DiscountPayload {
+  id: number;
+  title: string;
+  code?: string;
+  value_type?: string; // "percentage" | "fixed_amount"
+  value?: string; // "-10.0" for percentage or amount
+  usage_limit?: number | null;
+  ends_at?: string | null;
+  starts_at?: string | null;
+  status?: string;
+  discount_type?: string; // "code_discount" | "automatic_discount"
+}
+
+/**
+ * Parse the discount value from Shopify's format.
+ * Shopify sends values as negative strings (e.g., "-10.0" for 10%).
+ */
+function parseDiscountValue(value: string | undefined | null): number | null {
+  if (!value) return null;
+  const parsed = parseFloat(value);
+  if (isNaN(parsed)) return null;
+  return Math.abs(parsed);
+}
+
+/**
+ * Record a discount creation event (Pro only)
+ */
+export async function recordDiscountCreated(
+  shop: string,
+  discount: DiscountPayload,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "discounts")) {
+    console.log(`[StoreGuard] Discount tracking disabled for ${shop}`);
+    return false;
+  }
+
+  const discountValue = parseDiscountValue(discount.value);
+  const importance = calculateDiscountImportance(
+    discountValue,
+    discount.value_type ?? null,
+    discount.usage_limit ?? null
+  );
+
+  const context = buildDiscountContext({
+    title: discount.title,
+    code: discount.code,
+    value: discountValue,
+    valueType: discount.value_type,
+    usageLimit: discount.usage_limit ?? null,
+    endsAt: discount.ends_at,
+  });
+
+  await createChangeEvent({
+    shop,
+    entityType: "discount",
+    entityId: String(discount.id),
+    eventType: "discount_created",
+    resourceName: discount.title,
+    beforeValue: null,
+    afterValue: context,
+    webhookId: `${webhookId}-discount-created`,
+    importance,
+  });
+
+  return true;
+}
+
+/**
+ * Record a discount change event (Pro only)
+ */
+export async function recordDiscountChanged(
+  shop: string,
+  discount: DiscountPayload,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "discounts")) {
+    console.log(`[StoreGuard] Discount tracking disabled for ${shop}`);
+    return false;
+  }
+
+  const discountValue = parseDiscountValue(discount.value);
+  const importance = calculateDiscountImportance(
+    discountValue,
+    discount.value_type ?? null,
+    discount.usage_limit ?? null
+  );
+
+  const context = buildDiscountContext({
+    title: discount.title,
+    code: discount.code,
+    value: discountValue,
+    valueType: discount.value_type,
+    usageLimit: discount.usage_limit ?? null,
+    endsAt: discount.ends_at,
+  });
+
+  await createChangeEvent({
+    shop,
+    entityType: "discount",
+    entityId: String(discount.id),
+    eventType: "discount_changed",
+    resourceName: discount.title,
+    beforeValue: null, // We don't have the previous state from webhook
+    afterValue: context,
+    webhookId: `${webhookId}-discount-changed`,
+    importance,
+  });
+
+  return true;
+}
+
+/**
+ * Record a discount deletion event (Pro only)
+ * Always high importance â€” deleted discounts may have been in active use.
+ */
+export async function recordDiscountDeleted(
+  shop: string,
+  discount: DiscountPayload,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "discounts")) {
+    console.log(`[StoreGuard] Discount tracking disabled for ${shop}`);
+    return false;
+  }
+
+  const displayName = discount.title || `Discount #${discount.id}`;
+
+  await createChangeEvent({
+    shop,
+    entityType: "discount",
+    entityId: String(discount.id),
+    eventType: "discount_deleted",
+    resourceName: displayName,
+    beforeValue: displayName,
+    afterValue: "deleted",
+    webhookId: `${webhookId}-discount-deleted`,
+    importance: "high", // Deleted discounts are always high importance
+  });
+
+  return true;
+}
diff --git a/insightops/app/services/changeDetection.utils.ts b/insightops/app/services/changeDetection.utils.ts
index cf64cce..53c3f59 100644
--- a/insightops/app/services/changeDetection.utils.ts
+++ b/insightops/app/services/changeDetection.utils.ts
@@ -102,3 +102,82 @@ export function formatVariantLabel(
   }
   return `${productTitle} - ${variantTitle}`;
 }
+
+/**
+ * Determine importance for a discount event.
+ * High importance: >50% discount or unlimited usage.
+ * Medium importance: everything else.
+ */
+export function calculateDiscountImportance(
+  discountValue: number | null,
+  discountType: string | null,
+  usageLimit: number | null
+): "high" | "medium" {
+  // Unlimited usage = high importance
+  if (usageLimit === null || usageLimit === 0) {
+    return "high";
+  }
+
+  // Percentage discount >50% = high importance
+  if (discountType === "percentage" && discountValue !== null && discountValue > 50) {
+    return "high";
+  }
+
+  return "medium";
+}
+
+/**
+ * Format a discount value for human-readable display.
+ * e.g., "50%" for percentage, "$10.00" for fixed_amount
+ */
+export function formatDiscountValue(
+  value: number | string | null,
+  type: string | null
+): string {
+  if (value === null || value === undefined) return "unknown";
+  const numValue = typeof value === "string" ? parseFloat(value) : value;
+  if (isNaN(numValue)) return String(value);
+
+  if (type === "percentage") {
+    return `${numValue}%`;
+  }
+  return `$${numValue.toFixed(2)}`;
+}
+
+/**
+ * Build a concise context string for discount events.
+ * e.g., "50% off, code: SUMMER50, no usage limit, expires 2026-03-01"
+ */
+export function buildDiscountContext(info: {
+  title: string;
+  code?: string | null;
+  value?: number | string | null;
+  valueType?: string | null;
+  usageLimit?: number | null;
+  endsAt?: string | null;
+}): string {
+  const parts: string[] = [];
+
+  if (info.value !== null && info.value !== undefined && info.valueType) {
+    parts.push(`${formatDiscountValue(info.value, info.valueType)} off`);
+  }
+
+  if (info.code) {
+    parts.push(`code: ${info.code}`);
+  }
+
+  if (info.usageLimit === null || info.usageLimit === 0) {
+    parts.push("no usage limit");
+  } else if (info.usageLimit) {
+    parts.push(`limit: ${info.usageLimit} uses`);
+  }
+
+  if (info.endsAt) {
+    const date = new Date(info.endsAt);
+    if (!isNaN(date.getTime())) {
+      parts.push(`expires ${date.toLocaleDateString("en-US", { month: "short", day: "numeric", year: "numeric" })}`);
+    }
+  }
+
+  return parts.join(", ");
+}
diff --git a/insightops/app/services/dailyDigest.server.ts b/insightops/app/services/dailyDigest.server.ts
index 5120737..081539d 100644
--- a/insightops/app/services/dailyDigest.server.ts
+++ b/insightops/app/services/dailyDigest.server.ts
@@ -33,6 +33,9 @@ export interface DigestSummary {
     inventory_low: DigestEvent[];
     inventory_zero: DigestEvent[];
     theme_publish: DigestEvent[];
+    discount_created: DigestEvent[];
+    discount_changed: DigestEvent[];
+    discount_deleted: DigestEvent[];
   };
 }
 
@@ -116,6 +119,9 @@ export async function generateDigestForShop(shopDomain: string): Promise<DigestS
     inventory_low: [] as DigestEvent[],
     inventory_zero: [] as DigestEvent[],
     theme_publish: [] as DigestEvent[],
+    discount_created: [] as DigestEvent[],
+    discount_changed: [] as DigestEvent[],
+    discount_deleted: [] as DigestEvent[],
   };
 
   let highPriorityCount = 0;
@@ -185,6 +191,9 @@ export function getEventIdsFromDigest(digest: DigestSummary): string[] {
     ...digest.eventsByType.inventory_low,
     ...digest.eventsByType.inventory_zero,
     ...digest.eventsByType.theme_publish,
+    ...digest.eventsByType.discount_created,
+    ...digest.eventsByType.discount_changed,
+    ...digest.eventsByType.discount_deleted,
   ];
 
   return allEvents.map((e) => e.id);
@@ -205,6 +214,12 @@ export function formatEventType(eventType: string): string {
       return "Out of Stock";
     case "theme_publish":
       return "Theme Published";
+    case "discount_created":
+      return "Discount Created";
+    case "discount_changed":
+      return "Discount Changed";
+    case "discount_deleted":
+      return "Discount Deleted";
     default:
       return eventType;
   }
@@ -231,6 +246,12 @@ export function formatEventForEmail(event: DigestEvent): string {
       return `${event.resourceName}: now out of stock (was ${event.beforeValue} units) (${time})`;
     case "theme_publish":
       return `"${event.resourceName}" is now your live theme (${time})`;
+    case "discount_created":
+      return `"${event.resourceName}" created â€” ${event.afterValue} (${time})`;
+    case "discount_changed":
+      return `"${event.resourceName}" modified â€” ${event.afterValue} (${time})`;
+    case "discount_deleted":
+      return `"${event.resourceName}" was deleted (${time})`;
     default:
       return `${event.resourceName}: ${event.beforeValue} â†’ ${event.afterValue} (${time})`;
   }
diff --git a/insightops/app/services/dailyDigest.test.ts b/insightops/app/services/dailyDigest.test.ts
index 3341142..f1b1aa7 100644
--- a/insightops/app/services/dailyDigest.test.ts
+++ b/insightops/app/services/dailyDigest.test.ts
@@ -37,6 +37,9 @@ function makeDigest(overrides: Partial<DigestSummary> = {}): DigestSummary {
       inventory_low: [],
       inventory_zero: [],
       theme_publish: [],
+      discount_created: [],
+      discount_changed: [],
+      discount_deleted: [],
     },
     ...overrides,
   };
@@ -56,6 +59,9 @@ describe("getEventIdsFromDigest", () => {
         inventory_low: [],
         inventory_zero: [makeEvent({ id: "iz-1" })],
         theme_publish: [makeEvent({ id: "tp-1" })],
+        discount_created: [],
+        discount_changed: [],
+        discount_deleted: [],
       },
     });
 
@@ -76,6 +82,9 @@ describe("getEventIdsFromDigest", () => {
         inventory_low: [],
         inventory_zero: [],
         theme_publish: [],
+        discount_created: [],
+        discount_changed: [],
+        discount_deleted: [],
       },
     });
 
diff --git a/insightops/app/services/emailService.server.ts b/insightops/app/services/emailService.server.ts
index caada3b..3467ef7 100644
--- a/insightops/app/services/emailService.server.ts
+++ b/insightops/app/services/emailService.server.ts
@@ -127,6 +127,33 @@ export function generateDigestEmailHtml(digest: DigestSummary): string {
     ));
   }
 
+  // Discount created
+  if (digest.eventsByType.discount_created.length > 0) {
+    sections.push(buildEventSection(
+      "ðŸ·ï¸ Discount Created",
+      digest.eventsByType.discount_created,
+      "#10b981" // emerald
+    ));
+  }
+
+  // Discount changed
+  if (digest.eventsByType.discount_changed.length > 0) {
+    sections.push(buildEventSection(
+      "ðŸ·ï¸ Discount Changed",
+      digest.eventsByType.discount_changed,
+      "#f59e0b" // amber
+    ));
+  }
+
+  // Discount deleted
+  if (digest.eventsByType.discount_deleted.length > 0) {
+    sections.push(buildEventSection(
+      "ðŸ·ï¸ Discount Deleted",
+      digest.eventsByType.discount_deleted,
+      "#ef4444" // red
+    ));
+  }
+
   const sectionsHtml = sections.join("");
 
   // Summary stats
@@ -238,6 +265,12 @@ function formatChangeDescription(event: DigestSummary["eventsByType"]["price_cha
       return `Now out of stock (was ${event.beforeValue} units) â€¢ ${time}`;
     case "theme_publish":
       return `Now your live theme â€¢ ${time}`;
+    case "discount_created":
+      return `Created â€” ${event.afterValue} â€¢ ${time}`;
+    case "discount_changed":
+      return `Modified â€” ${event.afterValue} â€¢ ${time}`;
+    case "discount_deleted":
+      return `Deleted â€¢ ${time}`;
     default:
       return `${event.beforeValue} â†’ ${event.afterValue} â€¢ ${time}`;
   }
@@ -283,6 +316,12 @@ function getInstantAlertSubject(event: InstantAlertEvent, shopName: string): str
       return `ðŸš¨ Out of stock: ${event.resourceName} - ${shopName}`;
     case "theme_publish":
       return `ðŸŽ¨ Theme published: ${event.resourceName} - ${shopName}`;
+    case "discount_created":
+      return `ðŸ·ï¸ Discount created: ${event.resourceName} - ${shopName}`;
+    case "discount_changed":
+      return `ðŸ·ï¸ Discount changed: ${event.resourceName} - ${shopName}`;
+    case "discount_deleted":
+      return `ðŸš¨ Discount deleted: ${event.resourceName} - ${shopName}`;
     default:
       return `âš¡ Change detected: ${event.resourceName} - ${shopName}`;
   }
@@ -298,6 +337,9 @@ function getAlertIcon(eventType: string): string {
     case "inventory_low": return "âš ï¸";
     case "inventory_zero": return "ðŸš¨";
     case "theme_publish": return "ðŸŽ¨";
+    case "discount_created": return "ðŸ·ï¸";
+    case "discount_changed": return "ðŸ·ï¸";
+    case "discount_deleted": return "ðŸš¨";
     default: return "âš¡";
   }
 }
@@ -312,6 +354,9 @@ function getAlertColor(eventType: string): string {
     case "inventory_low": return "#f97316";
     case "inventory_zero": return "#ef4444";
     case "theme_publish": return "#06b6d4";
+    case "discount_created": return "#10b981";
+    case "discount_changed": return "#f59e0b";
+    case "discount_deleted": return "#ef4444";
     default: return "#6b7280";
   }
 }
@@ -353,6 +398,15 @@ function generateInstantAlertHtml(
     case "theme_publish":
       changeDescription = `"${event.resourceName}" is now your live theme`;
       break;
+    case "discount_created":
+      changeDescription = `Discount "${event.resourceName}" was created â€” ${event.afterValue || ""}`;
+      break;
+    case "discount_changed":
+      changeDescription = `Discount "${event.resourceName}" was modified â€” ${event.afterValue || ""}`;
+      break;
+    case "discount_deleted":
+      changeDescription = `Discount "${event.resourceName}" was deleted`;
+      break;
     default:
       changeDescription = `${event.beforeValue || ""} â†’ ${event.afterValue || ""}`;
   }
diff --git a/insightops/app/services/jobProcessor.server.ts b/insightops/app/services/jobProcessor.server.ts
index 7068c66..5e85592 100644
--- a/insightops/app/services/jobProcessor.server.ts
+++ b/insightops/app/services/jobProcessor.server.ts
@@ -11,6 +11,9 @@ import {
   detectInventoryZero,
   detectLowStock,
   deleteProductSnapshot,
+  recordDiscountCreated,
+  recordDiscountChanged,
+  recordDiscountDeleted,
 } from "./changeDetection.server";
 
 // Full product payload from Shopify webhook
@@ -68,6 +71,19 @@ interface CollectionPayload {
   } | null;
 }
 
+interface DiscountPayload {
+  id: number;
+  title: string;
+  code?: string;
+  value_type?: string;
+  value?: string;
+  usage_limit?: number | null;
+  ends_at?: string | null;
+  starts_at?: string | null;
+  status?: string;
+  discount_type?: string;
+}
+
 interface InventoryLevelPayload {
   inventory_item_id: number;
   location_id: number;
@@ -824,6 +840,31 @@ async function processInventoryUpdate(
   console.log(`[StoreGuard] âœ… Logged: ${message}`);
 }
 
+/**
+ * Process a discount webhook job
+ */
+async function processDiscount(
+  shop: string,
+  topic: string,
+  payload: DiscountPayload,
+  webhookId: string | null
+): Promise<void> {
+  if (!webhookId) {
+    console.log(`[StoreGuard] No webhookId for discount event, skipping`);
+    return;
+  }
+
+  if (topic.includes("create")) {
+    await recordDiscountCreated(shop, payload, webhookId);
+  } else if (topic.includes("update")) {
+    await recordDiscountChanged(shop, payload, webhookId);
+  } else if (topic.includes("delete")) {
+    await recordDiscountDeleted(shop, payload, webhookId);
+  }
+
+  console.log(`[StoreGuard] Processed discount ${topic} for ${payload.title || payload.id}`);
+}
+
 /**
  * Process a single job
  */
@@ -867,6 +908,11 @@ async function processJob(job: {
     case "inventory/levels/update":
       await processInventoryUpdate(job.shop, session.accessToken, payload, job.webhookId);
       break;
+    case "discounts/create":
+    case "discounts/update":
+    case "discounts/delete":
+      await processDiscount(job.shop, normalizedTopic, payload, job.webhookId);
+      break;
     default:
       console.log(`[StoreGuard] Unknown topic: ${job.topic} (normalized: ${normalizedTopic})`);
   }
diff --git a/insightops/app/services/shopService.server.ts b/insightops/app/services/shopService.server.ts
index a11cccd..897a9b4 100644
--- a/insightops/app/services/shopService.server.ts
+++ b/insightops/app/services/shopService.server.ts
@@ -7,6 +7,7 @@ export interface ShopSettings {
   trackVisibility: boolean;
   trackInventory: boolean;
   trackThemes: boolean;
+  trackDiscounts: boolean;
   lowStockThreshold: number;
   instantAlerts: boolean;
 }
@@ -27,6 +28,7 @@ export async function getOrCreateShop(shopDomain: string): Promise<ShopSettings>
       trackVisibility: true,
       trackInventory: true,
       trackThemes: false, // Pro only by default
+      trackDiscounts: false, // Pro only by default
       installedAt: new Date(),
     },
     update: {
@@ -44,6 +46,7 @@ export async function getOrCreateShop(shopDomain: string): Promise<ShopSettings>
     trackVisibility: shop.trackVisibility,
     trackInventory: shop.trackInventory,
     trackThemes: shop.trackThemes,
+    trackDiscounts: shop.trackDiscounts,
     lowStockThreshold: shop.lowStockThreshold,
     instantAlerts: shop.instantAlerts,
   };
@@ -67,6 +70,7 @@ export async function getShopSettings(shopDomain: string): Promise<ShopSettings
     trackVisibility: shop.trackVisibility,
     trackInventory: shop.trackInventory,
     trackThemes: shop.trackThemes,
+    trackDiscounts: shop.trackDiscounts,
     lowStockThreshold: shop.lowStockThreshold,
     instantAlerts: shop.instantAlerts,
   };
@@ -95,6 +99,13 @@ export async function updateShopSettings(
     trackThemes = false;
   }
 
+  // Discount tracking is Pro-only
+  let trackDiscounts = settings.trackDiscounts ?? shop.trackDiscounts;
+  if (shop.plan !== "pro" && trackDiscounts) {
+    console.log(`[StoreGuard] Blocking trackDiscounts for free plan: ${shopDomain}`);
+    trackDiscounts = false;
+  }
+
   // Instant alerts are Pro-only
   let instantAlerts = settings.instantAlerts ?? shop.instantAlerts;
   if (shop.plan !== "pro" && instantAlerts) {
@@ -115,6 +126,7 @@ export async function updateShopSettings(
       trackVisibility: settings.trackVisibility ?? shop.trackVisibility,
       trackInventory: settings.trackInventory ?? shop.trackInventory,
       trackThemes,
+      trackDiscounts,
       lowStockThreshold,
       instantAlerts,
     },
@@ -129,6 +141,7 @@ export async function updateShopSettings(
     trackVisibility: updated.trackVisibility,
     trackInventory: updated.trackInventory,
     trackThemes: updated.trackThemes,
+    trackDiscounts: updated.trackDiscounts,
     lowStockThreshold: updated.lowStockThreshold,
     instantAlerts: updated.instantAlerts,
   };
@@ -173,6 +186,7 @@ export async function downgradeShopToFree(shopDomain: string): Promise<void> {
     data: {
       plan: "free",
       trackThemes: false, // Disable Pro-only features
+      trackDiscounts: false, // Disable Pro-only features
       instantAlerts: false, // Disable Pro-only features
     },
   });
@@ -195,7 +209,7 @@ export async function isProPlan(shopDomain: string): Promise<boolean> {
  */
 export async function canTrackFeature(
   shopDomain: string,
-  feature: "prices" | "visibility" | "inventory" | "themes"
+  feature: "prices" | "visibility" | "inventory" | "themes" | "discounts"
 ): Promise<boolean> {
   const shop = await db.shop.findUnique({
     where: { shopifyDomain: shopDomain },
@@ -212,6 +226,8 @@ export async function canTrackFeature(
       return shop.trackInventory;
     case "themes":
       return shop.plan === "pro" && shop.trackThemes;
+    case "discounts":
+      return shop.plan === "pro" && shop.trackDiscounts;
     default:
       return false;
   }
diff --git a/insightops/prisma/schema.prisma b/insightops/prisma/schema.prisma
index 72a2545..d126aa0 100644
--- a/insightops/prisma/schema.prisma
+++ b/insightops/prisma/schema.prisma
@@ -41,6 +41,7 @@ model Shop {
   trackVisibility Boolean   @default(true)
   trackInventory  Boolean   @default(true)
   trackThemes     Boolean   @default(false) // Pro only
+  trackDiscounts  Boolean   @default(false) // Pro only
   lowStockThreshold Int     @default(5) // Alert when inventory drops below this
   instantAlerts   Boolean   @default(false) // Send alerts immediately (Pro only)
   installedAt     DateTime  @default(now())
diff --git a/insightops/shopify.app.toml b/insightops/shopify.app.toml
index 62dc11a..cd53bba 100644
--- a/insightops/shopify.app.toml
+++ b/insightops/shopify.app.toml
@@ -43,10 +43,22 @@ api_version = "2025-10"
   topics = [ "themes/publish" ]
   uri = "/webhooks/themes/publish"
 
+  [[webhooks.subscriptions]]
+  topics = [ "discounts/create" ]
+  uri = "/webhooks/discounts/create"
+
+  [[webhooks.subscriptions]]
+  topics = [ "discounts/update" ]
+  uri = "/webhooks/discounts/update"
+
+  [[webhooks.subscriptions]]
+  topics = [ "discounts/delete" ]
+  uri = "/webhooks/discounts/delete"
+
 [access_scopes]
 # Learn more at https://shopify.dev/docs/apps/tools/cli/configuration#access_scopes
-# StoreGuard scopes: products for change detection, inventory for stock alerts, themes for publish tracking
-scopes = "read_inventory,read_products,read_themes"
+# StoreGuard scopes: products for change detection, inventory for stock alerts, themes for publish tracking, discounts for discount monitoring
+scopes = "read_inventory,read_products,read_themes,read_discounts"
 optional_scopes = [ ]
 use_legacy_install_flow = false
 

==========================================
BRANCH: v2/p1-app-permissions
==========================================
diff --git a/insightops/app/routes/app.changes.tsx b/insightops/app/routes/app.changes.tsx
index 26d7faf..56d9c95 100644
--- a/insightops/app/routes/app.changes.tsx
+++ b/insightops/app/routes/app.changes.tsx
@@ -41,6 +41,7 @@ const eventConfig: Record<string, { label: string; color: string }> = {
   inventory_low: { label: "Low Stock", color: "#f97316" },
   inventory_zero: { label: "Out of Stock", color: "#e74c3c" },
   theme_publish: { label: "Theme Published", color: "#3498db" },
+  app_permissions_changed: { label: "App Permissions", color: "#e67e22" },
 };
 
 const importanceConfig: Record<string, { label: string; color: string }> = {
diff --git a/insightops/app/routes/app.settings.tsx b/insightops/app/routes/app.settings.tsx
index 1ec2a02..1045f32 100644
--- a/insightops/app/routes/app.settings.tsx
+++ b/insightops/app/routes/app.settings.tsx
@@ -28,6 +28,7 @@ export const action = async ({ request }: ActionFunctionArgs): Promise<ActionRes
   const trackVisibility = formData.get("trackVisibility") === "on";
   const trackInventory = formData.get("trackInventory") === "on";
   const trackThemes = formData.get("trackThemes") === "on";
+  const trackAppPermissions = formData.get("trackAppPermissions") === "on";
   const lowStockThreshold = parseInt(formData.get("lowStockThreshold") as string) || 5;
   const instantAlerts = formData.get("instantAlerts") === "on";
 
@@ -50,6 +51,7 @@ export const action = async ({ request }: ActionFunctionArgs): Promise<ActionRes
       trackVisibility,
       trackInventory,
       trackThemes,
+      trackAppPermissions,
       lowStockThreshold,
       instantAlerts,
     });
@@ -208,6 +210,14 @@ export default function Settings() {
             disabled={settings.plan !== "pro"}
             proOnly
           />
+          <Toggle
+            name="trackAppPermissions"
+            label="App permission changes"
+            description="Track when installed apps change their access permissions"
+            defaultChecked={settings.trackAppPermissions}
+            disabled={settings.plan !== "pro"}
+            proOnly
+          />
         </Section>
 
         {/* 2. Your Plan */}
diff --git a/insightops/app/routes/webhooks.app.scopes_update.tsx b/insightops/app/routes/webhooks.app.scopes_update.tsx
index b1610b8..f53d601 100644
--- a/insightops/app/routes/webhooks.app.scopes_update.tsx
+++ b/insightops/app/routes/webhooks.app.scopes_update.tsx
@@ -1,21 +1,36 @@
 import type { ActionFunctionArgs } from "react-router";
 import { authenticate } from "../shopify.server";
 import db from "../db.server";
+import { recordAppPermissionsChange } from "../services/changeDetection.server";
 
 export const action = async ({ request }: ActionFunctionArgs) => {
-    const { payload, session, topic, shop } = await authenticate.webhook(request);
-    console.log(`Received ${topic} webhook for ${shop}`);
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+  const { payload, session, topic, shop } = await authenticate.webhook(request);
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
 
-    const current = payload.current as string[];
-    if (session) {
-        await db.session.update({   
-            where: {
-                id: session.id
-            },
-            data: {
-                scope: current.toString(),
-            },
-        });
+  const current = (payload.current ?? []) as string[];
+  const previous = (payload.previous ?? []) as string[];
+
+  // Always update session scopes (existing behavior)
+  if (session) {
+    await db.session.update({
+      where: { id: session.id },
+      data: { scope: current.toString() },
+    });
+  }
+
+  // Record app permission change event (new behavior)
+  if (webhookId) {
+    const recorded = await recordAppPermissionsChange(
+      shop,
+      previous,
+      current,
+      webhookId
+    );
+    if (recorded) {
+      console.log(`[StoreGuard] App permission change alert created for ${shop}`);
     }
-    return new Response();
+  }
+
+  return new Response();
 };
diff --git a/insightops/app/services/changeDetection.server.ts b/insightops/app/services/changeDetection.server.ts
index 8d0a946..aacf9f2 100644
--- a/insightops/app/services/changeDetection.server.ts
+++ b/insightops/app/services/changeDetection.server.ts
@@ -8,6 +8,9 @@ import {
   shouldAlertInventoryZero as checkInventoryZero,
   shouldAlertLowStock as checkLowStock,
   formatVariantLabel,
+  diffScopes,
+  getScopeChangeImportance,
+  formatScopeChanges,
 } from "./changeDetection.utils";
 
 /**
@@ -104,9 +107,9 @@ async function updateProductSnapshot(
  */
 async function createChangeEvent(data: {
   shop: string;
-  entityType: "product" | "variant" | "theme";
+  entityType: "product" | "variant" | "theme" | "app";
   entityId: string;
-  eventType: "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish";
+  eventType: "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish" | "app_permissions_changed";
   resourceName: string;
   beforeValue: string | null;
   afterValue: string | null;
@@ -471,6 +474,55 @@ export async function recordThemePublish(
   return true;
 }
 
+/**
+ * Record an app permission (scope) change event.
+ * The app/scopes_update webhook fires when any installed app changes its permissions.
+ * Importance: HIGH for scope expansions (new permissions), MEDIUM for reductions.
+ */
+export async function recordAppPermissionsChange(
+  shop: string,
+  previousScopes: string[],
+  currentScopes: string[],
+  webhookId: string
+): Promise<boolean> {
+  // Check if shop wants to track app permissions (Pro only)
+  if (!await canTrackFeature(shop, "appPermissions")) {
+    console.log(`[StoreGuard] App permission tracking disabled for ${shop} (Free plan or disabled)`);
+    return false;
+  }
+
+  const { added, removed } = diffScopes(previousScopes, currentScopes);
+
+  // No actual change â€” Shopify may send no-op updates
+  if (added.length === 0 && removed.length === 0) {
+    console.log(`[StoreGuard] No scope changes detected for ${shop}, skipping`);
+    return false;
+  }
+
+  const importance = getScopeChangeImportance(added, removed);
+  const { beforeValue, afterValue } = formatScopeChanges(added, removed);
+
+  // Build a human-readable resource name
+  const parts: string[] = [];
+  if (added.length > 0) parts.push(`+${added.length} added`);
+  if (removed.length > 0) parts.push(`${removed.length} removed`);
+  const resourceName = `App permissions changed (${parts.join(", ")})`;
+
+  await createChangeEvent({
+    shop,
+    entityType: "app",
+    entityId: "app-scopes",
+    eventType: "app_permissions_changed",
+    resourceName,
+    beforeValue,
+    afterValue,
+    webhookId: `${webhookId}-app-scopes`,
+    importance,
+  });
+
+  return true;
+}
+
 /**
  * Process a product update and detect all relevant changes
  * This is the main entry point called from jobProcessor
diff --git a/insightops/app/services/changeDetection.test.ts b/insightops/app/services/changeDetection.test.ts
index 22e5097..3565f79 100644
--- a/insightops/app/services/changeDetection.test.ts
+++ b/insightops/app/services/changeDetection.test.ts
@@ -6,6 +6,9 @@ import {
   shouldAlertInventoryZero,
   shouldAlertLowStock,
   formatVariantLabel,
+  diffScopes,
+  getScopeChangeImportance,
+  formatScopeChanges,
 } from "./changeDetection.utils";
 
 describe("calculatePriceImportance", () => {
@@ -155,3 +158,113 @@ describe("formatVariantLabel", () => {
     expect(formatVariantLabel("Widget", null)).toBe("Widget");
   });
 });
+
+describe("diffScopes", () => {
+  it("should detect added scopes", () => {
+    const result = diffScopes(
+      ["read_products"],
+      ["read_products", "read_orders"]
+    );
+    expect(result.added).toEqual(["read_orders"]);
+    expect(result.removed).toEqual([]);
+  });
+
+  it("should detect removed scopes", () => {
+    const result = diffScopes(
+      ["read_products", "read_orders"],
+      ["read_products"]
+    );
+    expect(result.added).toEqual([]);
+    expect(result.removed).toEqual(["read_orders"]);
+  });
+
+  it("should detect both added and removed scopes", () => {
+    const result = diffScopes(
+      ["read_products", "read_themes"],
+      ["read_products", "write_orders"]
+    );
+    expect(result.added).toEqual(["write_orders"]);
+    expect(result.removed).toEqual(["read_themes"]);
+  });
+
+  it("should return empty arrays when scopes are identical", () => {
+    const result = diffScopes(
+      ["read_products", "read_orders"],
+      ["read_products", "read_orders"]
+    );
+    expect(result.added).toEqual([]);
+    expect(result.removed).toEqual([]);
+  });
+
+  it("should handle empty previous scopes", () => {
+    const result = diffScopes([], ["read_products", "read_orders"]);
+    expect(result.added).toEqual(["read_orders", "read_products"]);
+    expect(result.removed).toEqual([]);
+  });
+
+  it("should handle empty current scopes", () => {
+    const result = diffScopes(["read_products", "read_orders"], []);
+    expect(result.added).toEqual([]);
+    expect(result.removed).toEqual(["read_orders", "read_products"]);
+  });
+
+  it("should handle whitespace in scope strings", () => {
+    const result = diffScopes(
+      [" read_products ", "read_orders"],
+      ["read_products", " write_themes "]
+    );
+    expect(result.added).toEqual(["write_themes"]);
+    expect(result.removed).toEqual(["read_orders"]);
+  });
+
+  it("should ignore empty strings", () => {
+    const result = diffScopes(
+      ["read_products", ""],
+      ["read_products", "", "read_orders"]
+    );
+    expect(result.added).toEqual(["read_orders"]);
+    expect(result.removed).toEqual([]);
+  });
+
+  it("should sort results alphabetically", () => {
+    const result = diffScopes(
+      [],
+      ["write_orders", "read_products", "read_customers"]
+    );
+    expect(result.added).toEqual(["read_customers", "read_products", "write_orders"]);
+  });
+});
+
+describe("getScopeChangeImportance", () => {
+  it("should return high when scopes are added (expansion)", () => {
+    expect(getScopeChangeImportance(["read_orders"], [])).toBe("high");
+  });
+
+  it("should return high when both added and removed", () => {
+    expect(getScopeChangeImportance(["read_orders"], ["read_themes"])).toBe("high");
+  });
+
+  it("should return medium when only scopes are removed (reduction)", () => {
+    expect(getScopeChangeImportance([], ["read_orders"])).toBe("medium");
+  });
+});
+
+describe("formatScopeChanges", () => {
+  it("should format added scopes", () => {
+    const result = formatScopeChanges(["read_orders", "write_products"], []);
+    expect(result.beforeValue).toBe("(none)");
+    expect(result.afterValue).toBe("read_orders, write_products");
+  });
+
+  it("should format removed scopes", () => {
+    const result = formatScopeChanges([], ["read_themes"]);
+    expect(result.beforeValue).toBe("read_themes");
+    expect(result.afterValue).toBe("(none)");
+  });
+
+  it("should format both added and removed", () => {
+    const result = formatScopeChanges(["write_orders"], ["read_themes"]);
+    expect(result.beforeValue).toBe("read_themes");
+    expect(result.afterValue).toBe("write_orders");
+  });
+});
diff --git a/insightops/app/services/changeDetection.utils.ts b/insightops/app/services/changeDetection.utils.ts
index cf64cce..5beff8b 100644
--- a/insightops/app/services/changeDetection.utils.ts
+++ b/insightops/app/services/changeDetection.utils.ts
@@ -102,3 +102,45 @@ export function formatVariantLabel(
   }
   return `${productTitle} - ${variantTitle}`;
 }
+
+/**
+ * Diff two sets of scopes and return added/removed.
+ * Scopes are strings like "read_products", "write_orders", etc.
+ */
+export function diffScopes(
+  previousScopes: string[],
+  currentScopes: string[]
+): { added: string[]; removed: string[] } {
+  const prevSet = new Set(previousScopes.map((s) => s.trim()).filter(Boolean));
+  const currSet = new Set(currentScopes.map((s) => s.trim()).filter(Boolean));
+
+  const added = [...currSet].filter((s) => !prevSet.has(s)).sort();
+  const removed = [...prevSet].filter((s) => !currSet.has(s)).sort();
+
+  return { added, removed };
+}
+
+/**
+ * Determine importance of a scope change.
+ * Expansions (new permissions granted) are HIGH â€” potential security concern.
+ * Reductions (permissions removed) are MEDIUM â€” usually intentional cleanup.
+ */
+export function getScopeChangeImportance(
+  added: string[],
+  removed: string[]
+): "high" | "medium" {
+  return added.length > 0 ? "high" : "medium";
+}
+
+/**
+ * Format scope changes for human-readable display.
+ * Returns a concise summary like "+read_orders, +write_products, -read_themes"
+ */
+export function formatScopeChanges(
+  added: string[],
+  removed: string[]
+): { beforeValue: string; afterValue: string } {
+  const beforeValue = removed.length > 0 ? removed.join(", ") : "(none)";
+  const afterValue = added.length > 0 ? added.join(", ") : "(none)";
+  return { beforeValue, afterValue };
+}
diff --git a/insightops/app/services/dailyDigest.server.ts b/insightops/app/services/dailyDigest.server.ts
index 5120737..fb11dd7 100644
--- a/insightops/app/services/dailyDigest.server.ts
+++ b/insightops/app/services/dailyDigest.server.ts
@@ -33,6 +33,7 @@ export interface DigestSummary {
     inventory_low: DigestEvent[];
     inventory_zero: DigestEvent[];
     theme_publish: DigestEvent[];
+    app_permissions_changed: DigestEvent[];
   };
 }
 
@@ -116,6 +117,7 @@ export async function generateDigestForShop(shopDomain: string): Promise<DigestS
     inventory_low: [] as DigestEvent[],
     inventory_zero: [] as DigestEvent[],
     theme_publish: [] as DigestEvent[],
+    app_permissions_changed: [] as DigestEvent[],
   };
 
   let highPriorityCount = 0;
@@ -185,6 +187,7 @@ export function getEventIdsFromDigest(digest: DigestSummary): string[] {
     ...digest.eventsByType.inventory_low,
     ...digest.eventsByType.inventory_zero,
     ...digest.eventsByType.theme_publish,
+    ...digest.eventsByType.app_permissions_changed,
   ];
 
   return allEvents.map((e) => e.id);
@@ -205,6 +208,8 @@ export function formatEventType(eventType: string): string {
       return "Out of Stock";
     case "theme_publish":
       return "Theme Published";
+    case "app_permissions_changed":
+      return "App Permissions";
     default:
       return eventType;
   }
@@ -231,6 +236,12 @@ export function formatEventForEmail(event: DigestEvent): string {
       return `${event.resourceName}: now out of stock (was ${event.beforeValue} units) (${time})`;
     case "theme_publish":
       return `"${event.resourceName}" is now your live theme (${time})`;
+    case "app_permissions_changed": {
+      const parts: string[] = [];
+      if (event.afterValue && event.afterValue !== "(none)") parts.push(`Added: ${event.afterValue}`);
+      if (event.beforeValue && event.beforeValue !== "(none)") parts.push(`Removed: ${event.beforeValue}`);
+      return `${parts.join("; ")} (${time})`;
+    }
     default:
       return `${event.resourceName}: ${event.beforeValue} â†’ ${event.afterValue} (${time})`;
   }
diff --git a/insightops/app/services/dailyDigest.test.ts b/insightops/app/services/dailyDigest.test.ts
index 3341142..e914f6f 100644
--- a/insightops/app/services/dailyDigest.test.ts
+++ b/insightops/app/services/dailyDigest.test.ts
@@ -37,6 +37,7 @@ function makeDigest(overrides: Partial<DigestSummary> = {}): DigestSummary {
       inventory_low: [],
       inventory_zero: [],
       theme_publish: [],
+      app_permissions_changed: [],
     },
     ...overrides,
   };
@@ -56,16 +57,18 @@ describe("getEventIdsFromDigest", () => {
         inventory_low: [],
         inventory_zero: [makeEvent({ id: "iz-1" })],
         theme_publish: [makeEvent({ id: "tp-1" })],
+        app_permissions_changed: [makeEvent({ id: "ap-1" })],
       },
     });
 
     const ids = getEventIdsFromDigest(digest);
-    expect(ids).toHaveLength(5);
+    expect(ids).toHaveLength(6);
     expect(ids).toContain("pc-1");
     expect(ids).toContain("pc-2");
     expect(ids).toContain("vc-1");
     expect(ids).toContain("iz-1");
     expect(ids).toContain("tp-1");
+    expect(ids).toContain("ap-1");
   });
 
   it("should handle digest with events in only one category", () => {
@@ -76,6 +79,7 @@ describe("getEventIdsFromDigest", () => {
         inventory_low: [],
         inventory_zero: [],
         theme_publish: [],
+        app_permissions_changed: [],
       },
     });
 
@@ -181,4 +185,50 @@ describe("formatEventForEmail", () => {
     expect(result).toContain("Dawn 2.0");
     expect(result).toContain("live theme");
   });
+
+  it("should format app permissions changed event with added scopes", () => {
+    const event = makeEvent({
+      eventType: "app_permissions_changed",
+      entityType: "app",
+      resourceName: "App permissions changed (+2 added)",
+      beforeValue: "(none)",
+      afterValue: "read_orders, write_products",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("Added: read_orders, write_products");
+  });
+
+  it("should format app permissions changed event with removed scopes", () => {
+    const event = makeEvent({
+      eventType: "app_permissions_changed",
+      entityType: "app",
+      resourceName: "App permissions changed (1 removed)",
+      beforeValue: "read_themes",
+      afterValue: "(none)",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("Removed: read_themes");
+  });
+
+  it("should format app permissions changed event with both added and removed", () => {
+    const event = makeEvent({
+      eventType: "app_permissions_changed",
+      entityType: "app",
+      resourceName: "App permissions changed (+1 added, 1 removed)",
+      beforeValue: "read_themes",
+      afterValue: "write_orders",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("Added: write_orders");
+    expect(result).toContain("Removed: read_themes");
+  });
+});
+
+describe("formatEventType - app permissions", () => {
+  it("should format app_permissions_changed", () => {
+    expect(formatEventType("app_permissions_changed")).toBe("App Permissions");
+  });
 });
diff --git a/insightops/app/services/emailService.server.ts b/insightops/app/services/emailService.server.ts
index caada3b..cfd2351 100644
--- a/insightops/app/services/emailService.server.ts
+++ b/insightops/app/services/emailService.server.ts
@@ -127,6 +127,15 @@ export function generateDigestEmailHtml(digest: DigestSummary): string {
     ));
   }
 
+  // App permission changes
+  if (digest.eventsByType.app_permissions_changed.length > 0) {
+    sections.push(buildEventSection(
+      "ðŸ” App Permissions",
+      digest.eventsByType.app_permissions_changed,
+      "#e67e22" // orange
+    ));
+  }
+
   const sectionsHtml = sections.join("");
 
   // Summary stats
@@ -238,6 +247,12 @@ function formatChangeDescription(event: DigestSummary["eventsByType"]["price_cha
       return `Now out of stock (was ${event.beforeValue} units) â€¢ ${time}`;
     case "theme_publish":
       return `Now your live theme â€¢ ${time}`;
+    case "app_permissions_changed": {
+      const parts: string[] = [];
+      if (event.afterValue && event.afterValue !== "(none)") parts.push(`Added: ${event.afterValue}`);
+      if (event.beforeValue && event.beforeValue !== "(none)") parts.push(`Removed: ${event.beforeValue}`);
+      return `${parts.join(" Â· ")} â€¢ ${time}`;
+    }
     default:
       return `${event.beforeValue} â†’ ${event.afterValue} â€¢ ${time}`;
   }
@@ -283,6 +298,8 @@ function getInstantAlertSubject(event: InstantAlertEvent, shopName: string): str
       return `ðŸš¨ Out of stock: ${event.resourceName} - ${shopName}`;
     case "theme_publish":
       return `ðŸŽ¨ Theme published: ${event.resourceName} - ${shopName}`;
+    case "app_permissions_changed":
+      return `ðŸ” App permissions changed - ${shopName}`;
     default:
       return `âš¡ Change detected: ${event.resourceName} - ${shopName}`;
   }
@@ -298,6 +315,7 @@ function getAlertIcon(eventType: string): string {
     case "inventory_low": return "âš ï¸";
     case "inventory_zero": return "ðŸš¨";
     case "theme_publish": return "ðŸŽ¨";
+    case "app_permissions_changed": return "ðŸ”";
     default: return "âš¡";
   }
 }
@@ -312,6 +330,7 @@ function getAlertColor(eventType: string): string {
     case "inventory_low": return "#f97316";
     case "inventory_zero": return "#ef4444";
     case "theme_publish": return "#06b6d4";
+    case "app_permissions_changed": return "#e67e22";
     default: return "#6b7280";
   }
 }
@@ -353,6 +372,13 @@ function generateInstantAlertHtml(
     case "theme_publish":
       changeDescription = `"${event.resourceName}" is now your live theme`;
       break;
+    case "app_permissions_changed": {
+      const parts: string[] = [];
+      if (event.afterValue && event.afterValue !== "(none)") parts.push(`Added: ${event.afterValue}`);
+      if (event.beforeValue && event.beforeValue !== "(none)") parts.push(`Removed: ${event.beforeValue}`);
+      changeDescription = parts.join(". ") || "Permissions updated";
+      break;
+    }
     default:
       changeDescription = `${event.beforeValue || ""} â†’ ${event.afterValue || ""}`;
   }
diff --git a/insightops/app/services/shopService.server.ts b/insightops/app/services/shopService.server.ts
index a11cccd..a00e556 100644
--- a/insightops/app/services/shopService.server.ts
+++ b/insightops/app/services/shopService.server.ts
@@ -7,6 +7,7 @@ export interface ShopSettings {
   trackVisibility: boolean;
   trackInventory: boolean;
   trackThemes: boolean;
+  trackAppPermissions: boolean;
   lowStockThreshold: number;
   instantAlerts: boolean;
 }
@@ -44,6 +45,7 @@ export async function getOrCreateShop(shopDomain: string): Promise<ShopSettings>
     trackVisibility: shop.trackVisibility,
     trackInventory: shop.trackInventory,
     trackThemes: shop.trackThemes,
+    trackAppPermissions: shop.trackAppPermissions,
     lowStockThreshold: shop.lowStockThreshold,
     instantAlerts: shop.instantAlerts,
   };
@@ -67,6 +69,7 @@ export async function getShopSettings(shopDomain: string): Promise<ShopSettings
     trackVisibility: shop.trackVisibility,
     trackInventory: shop.trackInventory,
     trackThemes: shop.trackThemes,
+    trackAppPermissions: shop.trackAppPermissions,
     lowStockThreshold: shop.lowStockThreshold,
     instantAlerts: shop.instantAlerts,
   };
@@ -95,6 +98,13 @@ export async function updateShopSettings(
     trackThemes = false;
   }
 
+  // App permission tracking is Pro-only
+  let trackAppPermissions = settings.trackAppPermissions ?? shop.trackAppPermissions;
+  if (shop.plan !== "pro" && trackAppPermissions) {
+    console.log(`[StoreGuard] Blocking trackAppPermissions for free plan: ${shopDomain}`);
+    trackAppPermissions = false;
+  }
+
   // Instant alerts are Pro-only
   let instantAlerts = settings.instantAlerts ?? shop.instantAlerts;
   if (shop.plan !== "pro" && instantAlerts) {
@@ -115,6 +125,7 @@ export async function updateShopSettings(
       trackVisibility: settings.trackVisibility ?? shop.trackVisibility,
       trackInventory: settings.trackInventory ?? shop.trackInventory,
       trackThemes,
+      trackAppPermissions,
       lowStockThreshold,
       instantAlerts,
     },
@@ -129,6 +140,7 @@ export async function updateShopSettings(
     trackVisibility: updated.trackVisibility,
     trackInventory: updated.trackInventory,
     trackThemes: updated.trackThemes,
+    trackAppPermissions: updated.trackAppPermissions,
     lowStockThreshold: updated.lowStockThreshold,
     instantAlerts: updated.instantAlerts,
   };
@@ -173,6 +185,7 @@ export async function downgradeShopToFree(shopDomain: string): Promise<void> {
     data: {
       plan: "free",
       trackThemes: false, // Disable Pro-only features
+      trackAppPermissions: false, // Disable Pro-only features
       instantAlerts: false, // Disable Pro-only features
     },
   });
@@ -195,7 +208,7 @@ export async function isProPlan(shopDomain: string): Promise<boolean> {
  */
 export async function canTrackFeature(
   shopDomain: string,
-  feature: "prices" | "visibility" | "inventory" | "themes"
+  feature: "prices" | "visibility" | "inventory" | "themes" | "appPermissions"
 ): Promise<boolean> {
   const shop = await db.shop.findUnique({
     where: { shopifyDomain: shopDomain },
@@ -212,6 +225,8 @@ export async function canTrackFeature(
       return shop.trackInventory;
     case "themes":
       return shop.plan === "pro" && shop.trackThemes;
+    case "appPermissions":
+      return shop.plan === "pro" && shop.trackAppPermissions;
     default:
       return false;
   }
diff --git a/insightops/prisma/schema.prisma b/insightops/prisma/schema.prisma
index 72a2545..973c491 100644
--- a/insightops/prisma/schema.prisma
+++ b/insightops/prisma/schema.prisma
@@ -41,6 +41,7 @@ model Shop {
   trackVisibility Boolean   @default(true)
   trackInventory  Boolean   @default(true)
   trackThemes     Boolean   @default(false) // Pro only
+  trackAppPermissions Boolean @default(false) // Pro only - track app scope changes
   lowStockThreshold Int     @default(5) // Alert when inventory drops below this
   instantAlerts   Boolean   @default(false) // Send alerts immediately (Pro only)
   installedAt     DateTime  @default(now())
@@ -54,9 +55,9 @@ model Shop {
 model ChangeEvent {
   id           String    @id @default(uuid())
   shop         String    // Store URL
-  entityType   String    // "product" | "variant" | "theme"
+  entityType   String    // "product" | "variant" | "theme" | "app"
   entityId     String    // Shopify ID of the entity
-  eventType    String    // "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish"
+  eventType    String    // "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish" | "app_permissions_changed"
   resourceName String    // Product/Theme title for display (human-readable)
   beforeValue  String?   // Previous value (JSON or simple string)
   afterValue   String?   // New value (JSON or simple string)

==========================================
BRANCH: v2/p1-domain-monitoring
==========================================
diff --git a/insightops/app/routes/app.changes.tsx b/insightops/app/routes/app.changes.tsx
index 26d7faf..ccf0033 100644
--- a/insightops/app/routes/app.changes.tsx
+++ b/insightops/app/routes/app.changes.tsx
@@ -41,6 +41,8 @@ const eventConfig: Record<string, { label: string; color: string }> = {
   inventory_low: { label: "Low Stock", color: "#f97316" },
   inventory_zero: { label: "Out of Stock", color: "#e74c3c" },
   theme_publish: { label: "Theme Published", color: "#3498db" },
+  domain_changed: { label: "Domain Changed", color: "#0ea5e9" },
+  domain_removed: { label: "Domain Removed", color: "#dc2626" },
 };
 
 const importanceConfig: Record<string, { label: string; color: string }> = {
diff --git a/insightops/app/routes/app.settings.tsx b/insightops/app/routes/app.settings.tsx
index 1ec2a02..e0d9c34 100644
--- a/insightops/app/routes/app.settings.tsx
+++ b/insightops/app/routes/app.settings.tsx
@@ -28,6 +28,7 @@ export const action = async ({ request }: ActionFunctionArgs): Promise<ActionRes
   const trackVisibility = formData.get("trackVisibility") === "on";
   const trackInventory = formData.get("trackInventory") === "on";
   const trackThemes = formData.get("trackThemes") === "on";
+  const trackDomains = formData.get("trackDomains") === "on";
   const lowStockThreshold = parseInt(formData.get("lowStockThreshold") as string) || 5;
   const instantAlerts = formData.get("instantAlerts") === "on";
 
@@ -50,6 +51,7 @@ export const action = async ({ request }: ActionFunctionArgs): Promise<ActionRes
       trackVisibility,
       trackInventory,
       trackThemes,
+      trackDomains,
       lowStockThreshold,
       instantAlerts,
     });
@@ -208,6 +210,14 @@ export default function Settings() {
             disabled={settings.plan !== "pro"}
             proOnly
           />
+          <Toggle
+            name="trackDomains"
+            label="Domain changes"
+            description="Track when domains are added, changed, or removed"
+            defaultChecked={settings.trackDomains}
+            disabled={settings.plan !== "pro"}
+            proOnly
+          />
         </Section>
 
         {/* 2. Your Plan */}
diff --git a/insightops/app/routes/webhooks.domains.create.tsx b/insightops/app/routes/webhooks.domains.create.tsx
new file mode 100644
index 0000000..4160a6b
--- /dev/null
+++ b/insightops/app/routes/webhooks.domains.create.tsx
@@ -0,0 +1,43 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { recordDomainChange } from "../services/changeDetection.server";
+
+interface DomainPayload {
+  id: number;
+  host: string;
+  ssl_enabled: boolean;
+  localization?: {
+    country: string | null;
+    default_locale: string;
+    alternate_locales: string[];
+  };
+}
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    console.log(`[StoreGuard] No session found for ${shop}, skipping`);
+    return new Response();
+  }
+
+  if (!webhookId) {
+    console.log(`[StoreGuard] No webhookId, skipping`);
+    return new Response();
+  }
+
+  const domain = payload as DomainPayload;
+
+  const recorded = await recordDomainChange(shop, domain, webhookId, "added");
+
+  if (recorded) {
+    console.log(`[StoreGuard] Domain added alert created for "${domain.host}"`);
+  }
+
+  return new Response();
+};
diff --git a/insightops/app/routes/webhooks.domains.destroy.tsx b/insightops/app/routes/webhooks.domains.destroy.tsx
new file mode 100644
index 0000000..be7fcde
--- /dev/null
+++ b/insightops/app/routes/webhooks.domains.destroy.tsx
@@ -0,0 +1,43 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { recordDomainRemoval } from "../services/changeDetection.server";
+
+interface DomainPayload {
+  id: number;
+  host: string;
+  ssl_enabled: boolean;
+  localization?: {
+    country: string | null;
+    default_locale: string;
+    alternate_locales: string[];
+  };
+}
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    console.log(`[StoreGuard] No session found for ${shop}, skipping`);
+    return new Response();
+  }
+
+  if (!webhookId) {
+    console.log(`[StoreGuard] No webhookId, skipping`);
+    return new Response();
+  }
+
+  const domain = payload as DomainPayload;
+
+  const recorded = await recordDomainRemoval(shop, domain, webhookId);
+
+  if (recorded) {
+    console.log(`[StoreGuard] Domain removed alert created for "${domain.host}"`);
+  }
+
+  return new Response();
+};
diff --git a/insightops/app/routes/webhooks.domains.update.tsx b/insightops/app/routes/webhooks.domains.update.tsx
new file mode 100644
index 0000000..1fad245
--- /dev/null
+++ b/insightops/app/routes/webhooks.domains.update.tsx
@@ -0,0 +1,43 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { recordDomainChange } from "../services/changeDetection.server";
+
+interface DomainPayload {
+  id: number;
+  host: string;
+  ssl_enabled: boolean;
+  localization?: {
+    country: string | null;
+    default_locale: string;
+    alternate_locales: string[];
+  };
+}
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    console.log(`[StoreGuard] No session found for ${shop}, skipping`);
+    return new Response();
+  }
+
+  if (!webhookId) {
+    console.log(`[StoreGuard] No webhookId, skipping`);
+    return new Response();
+  }
+
+  const domain = payload as DomainPayload;
+
+  const recorded = await recordDomainChange(shop, domain, webhookId, "updated");
+
+  if (recorded) {
+    console.log(`[StoreGuard] Domain updated alert created for "${domain.host}"`);
+  }
+
+  return new Response();
+};
diff --git a/insightops/app/services/changeDetection.server.ts b/insightops/app/services/changeDetection.server.ts
index 8d0a946..2d0fac7 100644
--- a/insightops/app/services/changeDetection.server.ts
+++ b/insightops/app/services/changeDetection.server.ts
@@ -104,9 +104,9 @@ async function updateProductSnapshot(
  */
 async function createChangeEvent(data: {
   shop: string;
-  entityType: "product" | "variant" | "theme";
+  entityType: "product" | "variant" | "theme" | "domain";
   entityId: string;
-  eventType: "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish";
+  eventType: "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish" | "domain_changed" | "domain_removed";
   resourceName: string;
   beforeValue: string | null;
   afterValue: string | null;
@@ -486,6 +486,81 @@ export async function processProductChanges(
   return { priceChanges, statusChange };
 }
 
+// Domain payload from Shopify webhook
+interface DomainPayload {
+  id: number;
+  host: string;
+  ssl_enabled: boolean;
+  localization?: {
+    country: string | null;
+    default_locale: string;
+    alternate_locales: string[];
+  };
+}
+
+/**
+ * Record a domain change event (domains/create or domains/update)
+ * Domain changes are HIGH importance â€” can break SEO, links, and customer access
+ */
+export async function recordDomainChange(
+  shop: string,
+  domain: DomainPayload,
+  webhookId: string,
+  action: "added" | "updated"
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "domains")) {
+    console.log(`[StoreGuard] Domain tracking disabled for ${shop} (Free plan or disabled)`);
+    return false;
+  }
+
+  const afterValue = action === "added"
+    ? `Domain "${domain.host}" added`
+    : `Domain "${domain.host}" updated`;
+
+  await createChangeEvent({
+    shop,
+    entityType: "domain",
+    entityId: String(domain.id),
+    eventType: "domain_changed",
+    resourceName: domain.host,
+    beforeValue: null,
+    afterValue,
+    webhookId: `${webhookId}-domain`,
+    importance: "high",
+  });
+
+  return true;
+}
+
+/**
+ * Record a domain removal event (domains/destroy)
+ * Domain removal is HIGH importance â€” breaks SEO, bookmarks, and customer access
+ */
+export async function recordDomainRemoval(
+  shop: string,
+  domain: DomainPayload,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "domains")) {
+    console.log(`[StoreGuard] Domain tracking disabled for ${shop} (Free plan or disabled)`);
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "domain",
+    entityId: String(domain.id),
+    eventType: "domain_removed",
+    resourceName: domain.host,
+    beforeValue: domain.host,
+    afterValue: null,
+    webhookId: `${webhookId}-domain`,
+    importance: "high",
+  });
+
+  return true;
+}
+
 /**
  * Delete ProductSnapshot when product is deleted
  */
diff --git a/insightops/app/services/dailyDigest.server.ts b/insightops/app/services/dailyDigest.server.ts
index 5120737..2ec7515 100644
--- a/insightops/app/services/dailyDigest.server.ts
+++ b/insightops/app/services/dailyDigest.server.ts
@@ -33,6 +33,8 @@ export interface DigestSummary {
     inventory_low: DigestEvent[];
     inventory_zero: DigestEvent[];
     theme_publish: DigestEvent[];
+    domain_changed: DigestEvent[];
+    domain_removed: DigestEvent[];
   };
 }
 
@@ -116,6 +118,8 @@ export async function generateDigestForShop(shopDomain: string): Promise<DigestS
     inventory_low: [] as DigestEvent[],
     inventory_zero: [] as DigestEvent[],
     theme_publish: [] as DigestEvent[],
+    domain_changed: [] as DigestEvent[],
+    domain_removed: [] as DigestEvent[],
   };
 
   let highPriorityCount = 0;
@@ -185,6 +189,8 @@ export function getEventIdsFromDigest(digest: DigestSummary): string[] {
     ...digest.eventsByType.inventory_low,
     ...digest.eventsByType.inventory_zero,
     ...digest.eventsByType.theme_publish,
+    ...digest.eventsByType.domain_changed,
+    ...digest.eventsByType.domain_removed,
   ];
 
   return allEvents.map((e) => e.id);
@@ -205,6 +211,10 @@ export function formatEventType(eventType: string): string {
       return "Out of Stock";
     case "theme_publish":
       return "Theme Published";
+    case "domain_changed":
+      return "Domain Changed";
+    case "domain_removed":
+      return "Domain Removed";
     default:
       return eventType;
   }
@@ -231,6 +241,10 @@ export function formatEventForEmail(event: DigestEvent): string {
       return `${event.resourceName}: now out of stock (was ${event.beforeValue} units) (${time})`;
     case "theme_publish":
       return `"${event.resourceName}" is now your live theme (${time})`;
+    case "domain_changed":
+      return `${event.resourceName}: ${event.afterValue} (${time})`;
+    case "domain_removed":
+      return `${event.resourceName}: domain removed (${time})`;
     default:
       return `${event.resourceName}: ${event.beforeValue} â†’ ${event.afterValue} (${time})`;
   }
diff --git a/insightops/app/services/dailyDigest.test.ts b/insightops/app/services/dailyDigest.test.ts
index 3341142..4cb30ac 100644
--- a/insightops/app/services/dailyDigest.test.ts
+++ b/insightops/app/services/dailyDigest.test.ts
@@ -37,6 +37,8 @@ function makeDigest(overrides: Partial<DigestSummary> = {}): DigestSummary {
       inventory_low: [],
       inventory_zero: [],
       theme_publish: [],
+      domain_changed: [],
+      domain_removed: [],
     },
     ...overrides,
   };
@@ -56,16 +58,20 @@ describe("getEventIdsFromDigest", () => {
         inventory_low: [],
         inventory_zero: [makeEvent({ id: "iz-1" })],
         theme_publish: [makeEvent({ id: "tp-1" })],
+        domain_changed: [makeEvent({ id: "dc-1" })],
+        domain_removed: [makeEvent({ id: "dr-1" })],
       },
     });
 
     const ids = getEventIdsFromDigest(digest);
-    expect(ids).toHaveLength(5);
+    expect(ids).toHaveLength(7);
     expect(ids).toContain("pc-1");
     expect(ids).toContain("pc-2");
     expect(ids).toContain("vc-1");
     expect(ids).toContain("iz-1");
     expect(ids).toContain("tp-1");
+    expect(ids).toContain("dc-1");
+    expect(ids).toContain("dr-1");
   });
 
   it("should handle digest with events in only one category", () => {
@@ -76,6 +82,8 @@ describe("getEventIdsFromDigest", () => {
         inventory_low: [],
         inventory_zero: [],
         theme_publish: [],
+        domain_changed: [],
+        domain_removed: [],
       },
     });
 
@@ -104,6 +112,14 @@ describe("formatEventType", () => {
     expect(formatEventType("theme_publish")).toBe("Theme Published");
   });
 
+  it("should format domain_changed", () => {
+    expect(formatEventType("domain_changed")).toBe("Domain Changed");
+  });
+
+  it("should format domain_removed", () => {
+    expect(formatEventType("domain_removed")).toBe("Domain Removed");
+  });
+
   it("should return raw event type for unknown types", () => {
     expect(formatEventType("unknown_event")).toBe("unknown_event");
   });
@@ -181,4 +197,32 @@ describe("formatEventForEmail", () => {
     expect(result).toContain("Dawn 2.0");
     expect(result).toContain("live theme");
   });
+
+  it("should format domain changed event", () => {
+    const event = makeEvent({
+      eventType: "domain_changed",
+      entityType: "domain",
+      resourceName: "shop.example.com",
+      beforeValue: null,
+      afterValue: 'Domain "shop.example.com" added',
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("shop.example.com");
+    expect(result).toContain("added");
+  });
+
+  it("should format domain removed event", () => {
+    const event = makeEvent({
+      eventType: "domain_removed",
+      entityType: "domain",
+      resourceName: "old.example.com",
+      beforeValue: "old.example.com",
+      afterValue: null,
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("old.example.com");
+    expect(result).toContain("domain removed");
+  });
 });
diff --git a/insightops/app/services/emailService.server.ts b/insightops/app/services/emailService.server.ts
index caada3b..2c9cff3 100644
--- a/insightops/app/services/emailService.server.ts
+++ b/insightops/app/services/emailService.server.ts
@@ -127,6 +127,24 @@ export function generateDigestEmailHtml(digest: DigestSummary): string {
     ));
   }
 
+  // Domain changes
+  if (digest.eventsByType.domain_changed.length > 0) {
+    sections.push(buildEventSection(
+      "ðŸŒ Domain Changed",
+      digest.eventsByType.domain_changed,
+      "#0ea5e9" // sky blue
+    ));
+  }
+
+  // Domain removals
+  if (digest.eventsByType.domain_removed.length > 0) {
+    sections.push(buildEventSection(
+      "ðŸŒ Domain Removed",
+      digest.eventsByType.domain_removed,
+      "#dc2626" // red
+    ));
+  }
+
   const sectionsHtml = sections.join("");
 
   // Summary stats
@@ -238,6 +256,10 @@ function formatChangeDescription(event: DigestSummary["eventsByType"]["price_cha
       return `Now out of stock (was ${event.beforeValue} units) â€¢ ${time}`;
     case "theme_publish":
       return `Now your live theme â€¢ ${time}`;
+    case "domain_changed":
+      return `${event.afterValue} â€¢ ${time}`;
+    case "domain_removed":
+      return `Domain removed â€” may break SEO and customer links â€¢ ${time}`;
     default:
       return `${event.beforeValue} â†’ ${event.afterValue} â€¢ ${time}`;
   }
@@ -283,6 +305,10 @@ function getInstantAlertSubject(event: InstantAlertEvent, shopName: string): str
       return `ðŸš¨ Out of stock: ${event.resourceName} - ${shopName}`;
     case "theme_publish":
       return `ðŸŽ¨ Theme published: ${event.resourceName} - ${shopName}`;
+    case "domain_changed":
+      return `ðŸŒ Domain changed: ${event.resourceName} - ${shopName}`;
+    case "domain_removed":
+      return `ðŸš¨ Domain removed: ${event.resourceName} - ${shopName}`;
     default:
       return `âš¡ Change detected: ${event.resourceName} - ${shopName}`;
   }
@@ -298,6 +324,8 @@ function getAlertIcon(eventType: string): string {
     case "inventory_low": return "âš ï¸";
     case "inventory_zero": return "ðŸš¨";
     case "theme_publish": return "ðŸŽ¨";
+    case "domain_changed": return "ðŸŒ";
+    case "domain_removed": return "ðŸŒ";
     default: return "âš¡";
   }
 }
@@ -312,6 +340,8 @@ function getAlertColor(eventType: string): string {
     case "inventory_low": return "#f97316";
     case "inventory_zero": return "#ef4444";
     case "theme_publish": return "#06b6d4";
+    case "domain_changed": return "#0ea5e9";
+    case "domain_removed": return "#dc2626";
     default: return "#6b7280";
   }
 }
@@ -353,6 +383,12 @@ function generateInstantAlertHtml(
     case "theme_publish":
       changeDescription = `"${event.resourceName}" is now your live theme`;
       break;
+    case "domain_changed":
+      changeDescription = event.afterValue || `Domain "${event.resourceName}" was changed`;
+      break;
+    case "domain_removed":
+      changeDescription = `Domain "${event.resourceName}" was removed â€” this may break SEO, bookmarks, and customer access`;
+      break;
     default:
       changeDescription = `${event.beforeValue || ""} â†’ ${event.afterValue || ""}`;
   }
diff --git a/insightops/app/services/shopService.server.ts b/insightops/app/services/shopService.server.ts
index a11cccd..05bd35c 100644
--- a/insightops/app/services/shopService.server.ts
+++ b/insightops/app/services/shopService.server.ts
@@ -7,6 +7,7 @@ export interface ShopSettings {
   trackVisibility: boolean;
   trackInventory: boolean;
   trackThemes: boolean;
+  trackDomains: boolean;
   lowStockThreshold: number;
   instantAlerts: boolean;
 }
@@ -27,6 +28,7 @@ export async function getOrCreateShop(shopDomain: string): Promise<ShopSettings>
       trackVisibility: true,
       trackInventory: true,
       trackThemes: false, // Pro only by default
+      trackDomains: false, // Pro only by default
       installedAt: new Date(),
     },
     update: {
@@ -44,6 +46,7 @@ export async function getOrCreateShop(shopDomain: string): Promise<ShopSettings>
     trackVisibility: shop.trackVisibility,
     trackInventory: shop.trackInventory,
     trackThemes: shop.trackThemes,
+    trackDomains: shop.trackDomains,
     lowStockThreshold: shop.lowStockThreshold,
     instantAlerts: shop.instantAlerts,
   };
@@ -67,6 +70,7 @@ export async function getShopSettings(shopDomain: string): Promise<ShopSettings
     trackVisibility: shop.trackVisibility,
     trackInventory: shop.trackInventory,
     trackThemes: shop.trackThemes,
+    trackDomains: shop.trackDomains,
     lowStockThreshold: shop.lowStockThreshold,
     instantAlerts: shop.instantAlerts,
   };
@@ -95,6 +99,13 @@ export async function updateShopSettings(
     trackThemes = false;
   }
 
+  // Domain tracking is Pro-only
+  let trackDomains = settings.trackDomains ?? shop.trackDomains;
+  if (shop.plan !== "pro" && trackDomains) {
+    console.log(`[StoreGuard] Blocking trackDomains for free plan: ${shopDomain}`);
+    trackDomains = false;
+  }
+
   // Instant alerts are Pro-only
   let instantAlerts = settings.instantAlerts ?? shop.instantAlerts;
   if (shop.plan !== "pro" && instantAlerts) {
@@ -115,6 +126,7 @@ export async function updateShopSettings(
       trackVisibility: settings.trackVisibility ?? shop.trackVisibility,
       trackInventory: settings.trackInventory ?? shop.trackInventory,
       trackThemes,
+      trackDomains,
       lowStockThreshold,
       instantAlerts,
     },
@@ -129,6 +141,7 @@ export async function updateShopSettings(
     trackVisibility: updated.trackVisibility,
     trackInventory: updated.trackInventory,
     trackThemes: updated.trackThemes,
+    trackDomains: updated.trackDomains,
     lowStockThreshold: updated.lowStockThreshold,
     instantAlerts: updated.instantAlerts,
   };
@@ -173,6 +186,7 @@ export async function downgradeShopToFree(shopDomain: string): Promise<void> {
     data: {
       plan: "free",
       trackThemes: false, // Disable Pro-only features
+      trackDomains: false, // Disable Pro-only features
       instantAlerts: false, // Disable Pro-only features
     },
   });
@@ -195,7 +209,7 @@ export async function isProPlan(shopDomain: string): Promise<boolean> {
  */
 export async function canTrackFeature(
   shopDomain: string,
-  feature: "prices" | "visibility" | "inventory" | "themes"
+  feature: "prices" | "visibility" | "inventory" | "themes" | "domains"
 ): Promise<boolean> {
   const shop = await db.shop.findUnique({
     where: { shopifyDomain: shopDomain },
@@ -212,6 +226,8 @@ export async function canTrackFeature(
       return shop.trackInventory;
     case "themes":
       return shop.plan === "pro" && shop.trackThemes;
+    case "domains":
+      return shop.plan === "pro" && shop.trackDomains;
     default:
       return false;
   }
diff --git a/insightops/prisma/schema.prisma b/insightops/prisma/schema.prisma
index 72a2545..238641d 100644
--- a/insightops/prisma/schema.prisma
+++ b/insightops/prisma/schema.prisma
@@ -41,6 +41,7 @@ model Shop {
   trackVisibility Boolean   @default(true)
   trackInventory  Boolean   @default(true)
   trackThemes     Boolean   @default(false) // Pro only
+  trackDomains    Boolean   @default(false) // Pro only
   lowStockThreshold Int     @default(5) // Alert when inventory drops below this
   instantAlerts   Boolean   @default(false) // Send alerts immediately (Pro only)
   installedAt     DateTime  @default(now())
diff --git a/insightops/shopify.app.toml b/insightops/shopify.app.toml
index 62dc11a..e167773 100644
--- a/insightops/shopify.app.toml
+++ b/insightops/shopify.app.toml
@@ -43,6 +43,18 @@ api_version = "2025-10"
   topics = [ "themes/publish" ]
   uri = "/webhooks/themes/publish"
 
+  [[webhooks.subscriptions]]
+  topics = [ "domains/create" ]
+  uri = "/webhooks/domains/create"
+
+  [[webhooks.subscriptions]]
+  topics = [ "domains/update" ]
+  uri = "/webhooks/domains/update"
+
+  [[webhooks.subscriptions]]
+  topics = [ "domains/destroy" ]
+  uri = "/webhooks/domains/destroy"
+
 [access_scopes]
 # Learn more at https://shopify.dev/docs/apps/tools/cli/configuration#access_scopes
 # StoreGuard scopes: products for change detection, inventory for stock alerts, themes for publish tracking

==========================================
BRANCH: v2/p1-unify-events
==========================================
diff --git a/insightops/app/routes/api.test-inventory.tsx b/insightops/app/routes/api.test-inventory.tsx
index e568efd..3e4c89f 100644
--- a/insightops/app/routes/api.test-inventory.tsx
+++ b/insightops/app/routes/api.test-inventory.tsx
@@ -41,12 +41,12 @@ export const loader = async ({ request }: LoaderFunctionArgs) => {
   const result = await processPendingJobs();
 
   // 4. Check if event was created
-  const recentEvent = await db.eventLog.findFirst({
+  const recentEvent = await db.changeEvent.findFirst({
     where: {
       shop,
       topic: "INVENTORY_LEVELS_UPDATE"
     },
-    orderBy: { timestamp: "desc" }
+    orderBy: { detectedAt: "desc" }
   });
 
   return new Response(
diff --git a/insightops/app/routes/app.changes.tsx b/insightops/app/routes/app.changes.tsx
index 26d7faf..3065125 100644
--- a/insightops/app/routes/app.changes.tsx
+++ b/insightops/app/routes/app.changes.tsx
@@ -41,6 +41,14 @@ const eventConfig: Record<string, { label: string; color: string }> = {
   inventory_low: { label: "Low Stock", color: "#f97316" },
   inventory_zero: { label: "Out of Stock", color: "#e74c3c" },
   theme_publish: { label: "Theme Published", color: "#3498db" },
+  product_created: { label: "Product Created", color: "#27ae60" },
+  product_updated: { label: "Product Updated", color: "#2980b9" },
+  product_deleted: { label: "Product Deleted", color: "#c0392b" },
+  collection_created: { label: "Collection Created", color: "#27ae60" },
+  collection_updated: { label: "Collection Updated", color: "#2980b9" },
+  collection_deleted: { label: "Collection Deleted", color: "#c0392b" },
+  inventory_updated: { label: "Inventory", color: "#7f8c8d" },
+  order_placed: { label: "Order", color: "#2ecc71" },
 };
 
 const importanceConfig: Record<string, { label: string; color: string }> = {
diff --git a/insightops/app/routes/webhooks.compliance.tsx b/insightops/app/routes/webhooks.compliance.tsx
index e6ef0e4..a8bf186 100644
--- a/insightops/app/routes/webhooks.compliance.tsx
+++ b/insightops/app/routes/webhooks.compliance.tsx
@@ -37,16 +37,11 @@ export const action = async ({ request }: ActionFunctionArgs) => {
         // Delete all data associated with this shop
         // Using the actual model names from schema.prisma
 
-        // Delete change events
+        // Delete change events (unified event model)
         await db.changeEvent.deleteMany({
           where: { shop },
         });
 
-        // Delete event logs
-        await db.eventLog.deleteMany({
-          where: { shop },
-        });
-
         // Delete product snapshots
         await db.productSnapshot.deleteMany({
           where: { shop },
diff --git a/insightops/app/routes/webhooks.orders.paid.tsx b/insightops/app/routes/webhooks.orders.paid.tsx
index ac39ac4..337633c 100644
--- a/insightops/app/routes/webhooks.orders.paid.tsx
+++ b/insightops/app/routes/webhooks.orders.paid.tsx
@@ -39,7 +39,7 @@ export const action = async ({ request }: ActionFunctionArgs) => {
 
   // Check for duplicate
   if (webhookId) {
-    const existing = await db.eventLog.findFirst({
+    const existing = await db.changeEvent.findFirst({
       where: { webhookId },
     });
     if (existing) {
@@ -64,8 +64,8 @@ export const action = async ({ request }: ActionFunctionArgs) => {
     currency: order.currency || "USD",
   });
 
-  // Create an exciting message (no customer PII)
-  const message = `ðŸ’° Order ${order.name} - ${formattedAmount}`;
+  // Create message (no customer PII)
+  const message = `Order ${order.name} - ${formattedAmount}`;
 
   // Build diff with order details (no customer data)
   const diff = JSON.stringify({
@@ -88,19 +88,22 @@ export const action = async ({ request }: ActionFunctionArgs) => {
   });
 
   // Log the order event
-  await db.eventLog.create({
+  await db.changeEvent.create({
     data: {
       shop,
-      shopifyId: String(order.id),
+      entityType: "order",
+      entityId: String(order.id),
+      eventType: "order_placed",
+      resourceName: message,
       topic: "ORDERS_CREATE",
       author: "Customer", // Generic - no PII
-      message,
       diff,
       webhookId,
+      importance: "low",
     },
   });
 
-  console.log(`[StoreGuard] âœ… Logged order: ${message}`);
+  console.log(`[StoreGuard] Logged order: ${message}`);
 
   return new Response();
 };
diff --git a/insightops/app/services/jobProcessor.server.ts b/insightops/app/services/jobProcessor.server.ts
index 7068c66..a82c976 100644
--- a/insightops/app/services/jobProcessor.server.ts
+++ b/insightops/app/services/jobProcessor.server.ts
@@ -321,21 +321,21 @@ async function processProductUpdate(
     }
   }
 
-  // === Legacy EventLog (for activity timeline) ===
+  // === Activity Timeline (unified ChangeEvent) ===
   // Create new snapshot
   const newSnapshot = createProductSnapshot(payload);
 
   // Get previous snapshot for diff comparison
-  // Look for any event with a snapshot (baseline or previous update)
   let oldSnapshot: ProductSnapshot | null = null;
-  const previousEvents = await db.eventLog.findMany({
+  const previousEvents = await db.changeEvent.findMany({
     where: {
       shop,
-      shopifyId: String(payload.id),
+      entityId: String(payload.id),
+      topic: "products/update",
       diff: { not: null },
     },
-    orderBy: { timestamp: "desc" },
-    take: 5, // Check recent events for a valid snapshot
+    orderBy: { detectedAt: "desc" },
+    take: 5,
   });
 
   for (const prevEvent of previousEvents) {
@@ -344,7 +344,7 @@ async function processProductUpdate(
         const prevDiff = JSON.parse(prevEvent.diff);
         if (prevDiff.snapshot) {
           oldSnapshot = prevDiff.snapshot;
-          break; // Found a valid snapshot
+          break;
         }
       } catch {
         // Invalid JSON, try next event
@@ -364,7 +364,6 @@ async function processProductUpdate(
   if (changeSummary) {
     message += ` - ${changeSummary}`;
   } else if (!oldSnapshot) {
-    // No previous snapshot to compare against - this is first tracked change
     message += ` (first tracked change)`;
   }
 
@@ -381,16 +380,19 @@ async function processProductUpdate(
     update: { title: payload.title },
   });
 
-  // Create event log
-  await db.eventLog.create({
+  // Create unified event
+  await db.changeEvent.create({
     data: {
       shop,
-      shopifyId: String(payload.id),
+      entityType: "product",
+      entityId: String(payload.id),
+      eventType: "product_updated",
+      resourceName: message,
       topic: "products/update",
       author,
-      message,
       diff,
       webhookId,
+      importance: "low",
     },
   });
 
@@ -437,15 +439,18 @@ async function processProductCreate(
     update: { title: payload.title },
   });
 
-  await db.eventLog.create({
+  await db.changeEvent.create({
     data: {
       shop,
-      shopifyId: String(payload.id),
+      entityType: "product",
+      entityId: String(payload.id),
+      eventType: "product_created",
+      resourceName: message,
       topic: "products/create",
       author,
-      message,
       diff,
       webhookId,
+      importance: "low",
     },
   });
 
@@ -480,26 +485,29 @@ async function processProductDelete(
 
   // Fallback to previous events
   if (!productTitle) {
-    const previousEvent = await db.eventLog.findFirst({
-      where: { shop, shopifyId: productId },
-      orderBy: { timestamp: "desc" },
+    const previousEvent = await db.changeEvent.findFirst({
+      where: { shop, entityId: productId },
+      orderBy: { detectedAt: "desc" },
     });
-    const match = previousEvent?.message?.match(/"([^"]+)"/);
+    const match = previousEvent?.resourceName?.match(/"([^"]+)"/);
     if (match) productTitle = match[1];
   }
 
   const displayName = productTitle || `Product #${payload.id}`;
   const message = `Product deleted: "${displayName}"`;
 
-  await db.eventLog.create({
+  await db.changeEvent.create({
     data: {
       shop,
-      shopifyId: productId,
+      entityType: "product",
+      entityId: productId,
+      eventType: "product_deleted",
+      resourceName: message,
       topic: "products/delete",
       author: "System/App",
-      message,
       diff: null,
       webhookId,
+      importance: "medium",
     },
   });
 
@@ -523,25 +531,28 @@ async function processCollection(
     const collectionId = String((payload as { id: number }).id);
     let title: string | null = null;
 
-    const previousEvent = await db.eventLog.findFirst({
-      where: { shop, shopifyId: collectionId, topic: { contains: "collections" } },
-      orderBy: { timestamp: "desc" },
+    const previousEvent = await db.changeEvent.findFirst({
+      where: { shop, entityId: collectionId, entityType: "collection" },
+      orderBy: { detectedAt: "desc" },
     });
-    const match = previousEvent?.message?.match(/"([^"]+)"/);
+    const match = previousEvent?.resourceName?.match(/"([^"]+)"/);
     if (match) title = match[1];
 
     const displayName = title || `Collection #${collectionId}`;
     const message = `Collection deleted: "${displayName}"`;
 
-    await db.eventLog.create({
+    await db.changeEvent.create({
       data: {
         shop,
-        shopifyId: collectionId,
+        entityType: "collection",
+        entityId: collectionId,
+        eventType: "collection_deleted",
+        resourceName: message,
         topic,
         author: "System/App",
-        message,
         diff: null,
         webhookId,
+        importance: "medium",
       },
     });
 
@@ -551,17 +562,21 @@ async function processCollection(
 
   const collection = payload as CollectionPayload;
   const author = (await fetchAuthor(shop, accessToken, "Collection", collection.id, verb)) || "System/App";
+  const eventType = verb === "create" ? "collection_created" : "collection_updated";
   const message = `${author} ${verb}d collection "${collection.title}"`;
 
-  await db.eventLog.create({
+  await db.changeEvent.create({
     data: {
       shop,
-      shopifyId: String(collection.id),
+      entityType: "collection",
+      entityId: String(collection.id),
+      eventType,
+      resourceName: message,
       topic,
       author,
-      message,
       diff: JSON.stringify({ title: collection.title, handle: collection.handle }),
       webhookId,
+      importance: "low",
     },
   });
 
@@ -646,15 +661,15 @@ async function processInventoryUpdate(
   // When orders webhook is enabled, this will hide the "symptom" when we already have the "cause"
   if (productId) {
     try {
-      const recentOrder = await db.eventLog.findFirst({
+      const recentOrder = await db.changeEvent.findFirst({
         where: {
           shop,
           topic: "ORDERS_CREATE",
-          timestamp: {
+          detectedAt: {
             gte: new Date(Date.now() - 30 * 1000), // Within last 30 seconds
           },
         },
-        orderBy: { timestamp: "desc" },
+        orderBy: { detectedAt: "desc" },
       });
 
       if (recentOrder?.diff) {
@@ -671,17 +686,17 @@ async function processInventoryUpdate(
   }
 
   // Get previous inventory level for diff display AND for >0â†’0 detection
-  // Strategy: Check EventLog first (most recent), then fall back to ProductSnapshot
+  // Strategy: Check ChangeEvent first (most recent), then fall back to ProductSnapshot
   let oldAvailable: number | null = null;
   try {
-    // First, try EventLog (recent inventory updates)
-    const previousEvent = await db.eventLog.findFirst({
+    // First, try ChangeEvent (recent inventory updates)
+    const previousEvent = await db.changeEvent.findFirst({
       where: {
         shop,
-        shopifyId: String(payload.inventory_item_id),
+        entityId: String(payload.inventory_item_id),
         topic: "INVENTORY_LEVELS_UPDATE",
       },
-      orderBy: { timestamp: "desc" },
+      orderBy: { detectedAt: "desc" },
     });
 
     if (previousEvent?.diff) {
@@ -689,7 +704,7 @@ async function processInventoryUpdate(
       oldAvailable = prevDiff.available;
     }
 
-    // If no EventLog, fall back to ProductSnapshot
+    // If no ChangeEvent, fall back to ProductSnapshot
     if (oldAvailable === null && productId && variantId) {
       const snapshot = await db.productSnapshot.findUnique({
         where: { shop_id: { shop, id: productId } },
@@ -707,8 +722,8 @@ async function processInventoryUpdate(
         }
       }
     }
-  } catch (prevError) {
-    console.error(`[StoreGuard] Failed to fetch previous inventory:`, prevError);
+  } catch (prevErr) {
+    console.error(`[StoreGuard] Failed to fetch previous inventory:`, prevErr);
   }
 
   // === StoreGuard: Detect inventory changes ===
@@ -807,21 +822,24 @@ async function processInventoryUpdate(
     locationId: payload.location_id,
   });
 
-  await db.eventLog.create({
+  await db.changeEvent.create({
     data: {
       shop,
+      entityType: "inventory",
       // Use inventory_item_id consistently for inventory events
       // This matches the lookup in getPreviousInventory above
-      shopifyId: String(payload.inventory_item_id),
+      entityId: String(payload.inventory_item_id),
+      eventType: "inventory_updated",
+      resourceName: message,
       topic: "INVENTORY_LEVELS_UPDATE",
       author: "System/App",
-      message,
       diff,
       webhookId,
+      importance: "low",
     },
   });
 
-  console.log(`[StoreGuard] âœ… Logged: ${message}`);
+  console.log(`[StoreGuard] Logged: ${message}`);
 }
 
 /**
diff --git a/insightops/app/services/jobQueue.server.ts b/insightops/app/services/jobQueue.server.ts
index 17b4868..2470abc 100644
--- a/insightops/app/services/jobQueue.server.ts
+++ b/insightops/app/services/jobQueue.server.ts
@@ -70,10 +70,10 @@ function scheduleJobProcessing(delayMs: number): void {
  * Check if a webhook has already been processed (deduplication)
  */
 export async function isWebhookProcessed(webhookId: string): Promise<boolean> {
-  // Check both completed jobs and event logs
+  // Check both completed jobs and change events
   const [existingJob, existingEvent] = await Promise.all([
     db.webhookJob.findUnique({ where: { webhookId } }),
-    db.eventLog.findUnique({ where: { webhookId } }),
+    db.changeEvent.findUnique({ where: { webhookId } }),
   ]);
 
   return !!(existingJob || existingEvent);
diff --git a/insightops/app/services/productSync.server.ts b/insightops/app/services/productSync.server.ts
index cf87dd8..1f4e850 100644
--- a/insightops/app/services/productSync.server.ts
+++ b/insightops/app/services/productSync.server.ts
@@ -43,54 +43,6 @@ interface ProductsResponse {
   };
 }
 
-// Snapshot format (matches jobProcessor.server.ts)
-interface ProductSnapshot {
-  title: string;
-  description: string | null;
-  vendor: string | null;
-  productType: string | null;
-  status: string;
-  tags: string[];
-  imageCount: number;
-  variants: Array<{
-    title: string;
-    price: string;
-    compareAtPrice: string | null;
-    sku: string | null;
-    inventory: number;
-  }>;
-  options: Array<{
-    name: string;
-    values: string[];
-  }>;
-}
-
-/**
- * Create a snapshot from GraphQL product data for baseline comparison
- */
-function createSnapshotFromGraphQL(product: ProductNode): ProductSnapshot {
-  return {
-    title: product.title,
-    description: product.descriptionHtml,
-    vendor: product.vendor,
-    productType: product.productType,
-    status: product.status.toLowerCase(),
-    tags: product.tags || [],
-    imageCount: product.images?.edges?.length || 0,
-    variants: product.variants.edges.map((v) => ({
-      title: v.node.title,
-      price: v.node.price,
-      compareAtPrice: v.node.compareAtPrice,
-      sku: v.node.sku,
-      inventory: v.node.inventoryQuantity ?? 0,
-    })),
-    options: product.options?.map((o) => ({
-      name: o.name,
-      values: o.values,
-    })) || [],
-  };
-}
-
 /**
  * Get sync status for a shop
  */
@@ -105,14 +57,13 @@ export async function getSyncStatus(shop: string): Promise<{
   });
 
   if (!syncRecord) {
-    // Legacy installs may have ProductCache entries from webhooks without ever creating baseline snapshots.
-    // Baselines are what make the *first* product update show a diff.
-    const baselineCount = await db.eventLog.count({
-      where: { shop, topic: "products/snapshot" },
+    // Check if we have ProductSnapshot records (from sync or webhooks)
+    const snapshotCount = await db.productSnapshot.count({
+      where: { shop },
     });
 
-    if (baselineCount > 0) {
-      return { status: "completed", syncedProducts: baselineCount, totalProducts: baselineCount, error: null };
+    if (snapshotCount > 0) {
+      return { status: "completed", syncedProducts: snapshotCount, totalProducts: snapshotCount, error: null };
     }
 
     return { status: "not_started", syncedProducts: 0, totalProducts: null, error: null };
@@ -127,11 +78,10 @@ export async function getSyncStatus(shop: string): Promise<{
 }
 
 /**
- * Sync all products from Shopify to our ProductCache and create baseline snapshots.
+ * Sync all products from Shopify to our ProductCache and ProductSnapshot.
  * This ensures we have:
- * 1. Product names available for delete events
- * 2. Baseline snapshots so the first update shows what changed
- * 3. ProductSnapshot records for StoreGuard change detection
+ * 1. Product names available for delete events (ProductCache)
+ * 2. ProductSnapshot records for StoreGuard change detection
  * Uses cursor-based pagination to handle stores with many products.
  */
 export async function syncProducts(
@@ -216,7 +166,7 @@ export async function syncProducts(
         break;
       }
 
-      // Upsert products into cache and create baseline EventLog entries
+      // Upsert products into cache and ProductSnapshot for change detection
       for (const edge of products.edges) {
         const product = edge.node;
         // Extract numeric ID from GID (gid://shopify/Product/123)
@@ -265,50 +215,7 @@ export async function syncProducts(
           },
         });
 
-        // Ensure we have a baseline snapshot for this product (legacy EventLog).
-        // IMPORTANT: ProductCache can exist from webhooks, but that doesn't mean a baseline snapshot exists.
-        // Only `products/snapshot` events count as baselines.
-        const existingBaseline = await db.eventLog.findFirst({
-          where: { shop, shopifyId: numericId, topic: "products/snapshot" },
-        });
-
-        if (!existingBaseline || force) {
-          // Create baseline snapshot so future updates can show diffs
-          const snapshot = createSnapshotFromGraphQL(product);
-          const diff = JSON.stringify({
-            snapshot: snapshot,
-            changes: [], // No changes for baseline
-          });
-
-          // Don't spam multiple baselines unless explicitly forced; even on force, keep it idempotent by upserting a single baseline.
-          // Prisma doesn't support "upsert" without a unique key, so we just create a new baseline when forcing.
-          // (For normal runs, we only create if missing.)
-          if (!existingBaseline) {
-            await db.eventLog.create({
-              data: {
-                shop,
-                shopifyId: numericId,
-                topic: "products/snapshot",
-                author: "StoreGuard",
-                message: `Baseline snapshot for "${product.title}"`,
-                diff,
-                webhookId: null,
-              },
-            });
-          } else if (force) {
-            await db.eventLog.create({
-              data: {
-                shop,
-                shopifyId: numericId,
-                topic: "products/snapshot",
-                author: "StoreGuard",
-                message: `Refreshed baseline snapshot for "${product.title}"`,
-                diff,
-                webhookId: null,
-              },
-            });
-          }
-        }
+        // ProductSnapshot is the canonical baseline (created above via upsert).
 
         synced++;
 
@@ -371,8 +278,7 @@ export async function needsProductSync(shop: string): Promise<boolean> {
   const syncRecord = await db.shopSync.findUnique({ where: { shop } });
   const snapshotCount = await db.productSnapshot.count({ where: { shop } });
   const cacheCount = await db.productCache.count({ where: { shop } });
-  const baselineCount = await db.eventLog.count({ where: { shop, topic: "products/snapshot" } });
-  const expectedCount = Math.max(syncRecord?.syncedProducts ?? 0, cacheCount, baselineCount);
+  const expectedCount = Math.max(syncRecord?.syncedProducts ?? 0, cacheCount);
 
   if (syncRecord) {
     if (syncRecord.status === "completed") {
diff --git a/insightops/prisma/migrations/20260218120000_unify_event_pipeline/migration.sql b/insightops/prisma/migrations/20260218120000_unify_event_pipeline/migration.sql
new file mode 100644
index 0000000..e08f28b
--- /dev/null
+++ b/insightops/prisma/migrations/20260218120000_unify_event_pipeline/migration.sql
@@ -0,0 +1,61 @@
+-- Unify EventLog + ChangeEvent into a single event pipeline
+-- ChangeEvent becomes the canonical model, EventLog is dropped
+
+-- Step 1: Add new columns to ChangeEvent (nullable for existing rows)
+ALTER TABLE "ChangeEvent" ADD COLUMN "topic" TEXT;
+ALTER TABLE "ChangeEvent" ADD COLUMN "diff" TEXT;
+ALTER TABLE "ChangeEvent" ADD COLUMN "author" TEXT;
+
+-- Step 2: Make webhookId nullable (baseline snapshots don't have webhookIds)
+ALTER TABLE "ChangeEvent" ALTER COLUMN "webhookId" DROP NOT NULL;
+
+-- Step 3: Migrate EventLog data into ChangeEvent
+-- Map EventLog fields to ChangeEvent fields
+INSERT INTO "ChangeEvent" (
+  "id", "shop", "entityType", "entityId", "eventType", "resourceName",
+  "beforeValue", "afterValue", "detectedAt", "source", "importance",
+  "webhookId", "topic", "diff", "author"
+)
+SELECT
+  "id",
+  "shop",
+  CASE
+    WHEN "topic" LIKE 'products/%' OR "topic" = 'products/snapshot' THEN 'product'
+    WHEN "topic" LIKE 'collections/%' THEN 'collection'
+    WHEN "topic" = 'INVENTORY_LEVELS_UPDATE' THEN 'inventory'
+    WHEN "topic" = 'ORDERS_CREATE' THEN 'order'
+    ELSE 'product'
+  END,
+  "shopifyId",
+  CASE
+    WHEN "topic" = 'products/update' THEN 'product_updated'
+    WHEN "topic" = 'products/create' THEN 'product_created'
+    WHEN "topic" = 'products/delete' THEN 'product_deleted'
+    WHEN "topic" = 'products/snapshot' THEN 'product_updated'
+    WHEN "topic" = 'collections/create' THEN 'collection_created'
+    WHEN "topic" = 'collections/update' THEN 'collection_updated'
+    WHEN "topic" = 'collections/delete' THEN 'collection_deleted'
+    WHEN "topic" = 'INVENTORY_LEVELS_UPDATE' THEN 'inventory_updated'
+    WHEN "topic" = 'ORDERS_CREATE' THEN 'order_placed'
+    ELSE 'product_updated'
+  END,
+  "message",
+  NULL,
+  NULL,
+  "timestamp",
+  'webhook',
+  'low',
+  "webhookId",
+  "topic",
+  "diff",
+  "author"
+FROM "EventLog"
+-- Skip rows that would violate the unique constraint on webhookId
+WHERE "webhookId" IS NULL
+   OR "webhookId" NOT IN (SELECT "webhookId" FROM "ChangeEvent" WHERE "webhookId" IS NOT NULL);
+
+-- Step 4: Create index on topic
+CREATE INDEX "ChangeEvent_shop_topic_idx" ON "ChangeEvent"("shop", "topic");
+
+-- Step 5: Drop EventLog table
+DROP TABLE "EventLog";
diff --git a/insightops/prisma/schema.prisma b/insightops/prisma/schema.prisma
index 72a2545..7b62dce 100644
--- a/insightops/prisma/schema.prisma
+++ b/insightops/prisma/schema.prisma
@@ -50,14 +50,14 @@ model Shop {
   stripeSubscriptionId String?  // Active subscription ID (sub_xxx)
 }
 
-// Change events for alerting (core of StoreGuard)
+// Unified event model â€” single pipeline for all store monitoring
 model ChangeEvent {
   id           String    @id @default(uuid())
   shop         String    // Store URL
-  entityType   String    // "product" | "variant" | "theme"
+  entityType   String    // "product" | "variant" | "theme" | "collection" | "order" | "inventory"
   entityId     String    // Shopify ID of the entity
-  eventType    String    // "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish"
-  resourceName String    // Product/Theme title for display (human-readable)
+  eventType    String    // "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish" | "product_created" | "product_deleted" | "product_updated" | "collection_created" | "collection_updated" | "collection_deleted" | "inventory_updated" | "order_placed"
+  resourceName String    // Human-readable name for display
   beforeValue  String?   // Previous value (JSON or simple string)
   afterValue   String?   // New value (JSON or simple string)
   detectedAt   DateTime  @default(now())
@@ -65,13 +65,17 @@ model ChangeEvent {
   source       String    @default("webhook") // "webhook" | "sync_job" | "manual"
   importance   String    @default("medium") // "high" | "medium" | "low"
   groupId      String?   // For grouping related changes (e.g. bulk edit session)
-  webhookId    String    @unique // Deduplication
+  webhookId    String?   @unique // Deduplication (null for baseline snapshots)
+  topic        String?   // Webhook topic (e.g., "products/update") for filtering
+  diff         String?   // JSON snapshot data for diff comparison (migrated from EventLog)
+  author       String?   // Who made the change (from Shopify Events API)
 
   @@index([shop])
   @@index([shop, detectedAt])
   @@index([shop, eventType])
   @@index([digestedAt])
   @@index([shop, entityType, entityId])
+  @@index([shop, topic])
 }
 
 // Product state snapshot for change detection
@@ -87,22 +91,6 @@ model ProductSnapshot {
   @@index([shop])
 }
 
-model EventLog {
-  id          String   @id @default(uuid())
-  shop        String   // The store URL
-  shopifyId   String   // The Resource ID (e.g., Product ID)
-  topic       String   // e.g., "products/update"
-  author      String?  // The "Blame" retrieved via Events API
-  message     String   // Description of change
-  diff        String?  // JSON string: { old: value, new: value }
-  timestamp   DateTime @default(now())
-  webhookId   String?  @unique // Shopify webhook delivery ID for deduplication
-
-  @@index([shop])
-  @@index([shop, timestamp])
-  @@index([shop, shopifyId, topic])
-}
-
 // Lightweight product cache for resolving names on delete
 model ProductCache {
   id        String   @id // Shopify product ID as string
diff --git a/insightops/prisma/seed-demo.ts b/insightops/prisma/seed-demo.ts
index 84480e0..b2ade4a 100644
--- a/insightops/prisma/seed-demo.ts
+++ b/insightops/prisma/seed-demo.ts
@@ -390,8 +390,8 @@ async function seed() {
   console.log("ðŸŒ± Seeding demo data for screenshots & videos...\n");
   console.log(`   Shop: ${SHOP}`);
 
-  // Clear existing data for this shop
-  const deleted = await db.eventLog.deleteMany({
+  // Clear existing demo data for this shop
+  const deleted = await db.changeEvent.deleteMany({
     where: { shop: SHOP },
   });
   console.log(`   Cleared ${deleted.count} existing events\n`);
@@ -401,23 +401,41 @@ async function seed() {
   const allEvents = [...activityEvents, ...orderEvents];
   const now = new Date();
 
+  // Helper: map topic to entityType and eventType for unified model
+  function mapTopicToEvent(topic: string): { entityType: string; eventType: string } {
+    switch (topic) {
+      case "products/update": return { entityType: "product", eventType: "product_updated" };
+      case "products/create": return { entityType: "product", eventType: "product_created" };
+      case "products/delete": return { entityType: "product", eventType: "product_deleted" };
+      case "inventory_levels/update": return { entityType: "inventory", eventType: "inventory_updated" };
+      case "collections/create": return { entityType: "collection", eventType: "collection_created" };
+      case "collections/update": return { entityType: "collection", eventType: "collection_updated" };
+      case "ORDERS_CREATE": return { entityType: "order", eventType: "order_placed" };
+      default: return { entityType: "product", eventType: "product_updated" };
+    }
+  }
+
   console.log("ðŸ“ Creating activity events...\n");
 
   for (const event of activityEvents) {
     const hoursMs = event.hoursAgo * 60 * 60 * 1000;
     const minutesMs = (event.minutesAgo || 0) * 60 * 1000;
-    const timestamp = new Date(now.getTime() - hoursMs - minutesMs);
+    const detectedAt = new Date(now.getTime() - hoursMs - minutesMs);
+    const { entityType, eventType } = mapTopicToEvent(event.topic);
 
-    await db.eventLog.create({
+    await db.changeEvent.create({
       data: {
         shop: SHOP,
-        shopifyId: event.shopifyId,
+        entityType,
+        entityId: event.shopifyId,
+        eventType,
+        resourceName: event.message,
         topic: event.topic,
         author: event.author,
-        message: event.message,
         diff: event.diff,
-        timestamp,
+        detectedAt,
         webhookId: `demo-activity-${Date.now()}-${Math.random().toString(36).slice(2)}`,
+        importance: "low",
       },
     });
 
@@ -435,18 +453,21 @@ async function seed() {
   for (const event of orderEvents) {
     const hoursMs = event.hoursAgo * 60 * 60 * 1000;
     const minutesMs = (event.minutesAgo || 0) * 60 * 1000;
-    const timestamp = new Date(now.getTime() - hoursMs - minutesMs);
+    const detectedAt = new Date(now.getTime() - hoursMs - minutesMs);
 
-    await db.eventLog.create({
+    await db.changeEvent.create({
       data: {
         shop: SHOP,
-        shopifyId: event.shopifyId,
+        entityType: "order",
+        entityId: event.shopifyId,
+        eventType: "order_placed",
+        resourceName: event.message,
         topic: event.topic,
         author: event.author,
-        message: event.message,
         diff: event.diff,
-        timestamp,
+        detectedAt,
         webhookId: `demo-order-${Date.now()}-${Math.random().toString(36).slice(2)}`,
+        importance: "low",
       },
     });
     orderCount++;

==========================================
BRANCH: v2/p1-normalize-snapshots
==========================================
diff --git a/insightops/app/services/changeDetection.server.ts b/insightops/app/services/changeDetection.server.ts
index 8d0a946..dcf3f5f 100644
--- a/insightops/app/services/changeDetection.server.ts
+++ b/insightops/app/services/changeDetection.server.ts
@@ -58,44 +58,71 @@ async function getProductSnapshot(shop: string, productId: string): Promise<{
 } | null> {
   const snapshot = await db.productSnapshot.findUnique({
     where: { shop_id: { shop, id: productId } },
+    include: { variants: true },
   });
 
   if (!snapshot) return null;
 
-  try {
-    const variants = JSON.parse(snapshot.variants) as VariantSnapshot[];
-    return {
-      title: snapshot.title,
-      status: snapshot.status,
-      variants,
-    };
-  } catch {
-    return null;
-  }
+  return {
+    title: snapshot.title,
+    status: snapshot.status,
+    variants: snapshot.variants.map((v) => ({
+      id: v.variantId,
+      title: v.title,
+      price: v.price,
+      inventoryQuantity: v.inventoryQuantity,
+    })),
+  };
 }
 
 /**
- * Update the ProductSnapshot after processing
+ * Update the ProductSnapshot after processing.
+ * Uses a transaction to atomically replace all variant rows.
  */
 async function updateProductSnapshot(
   shop: string,
   productId: string,
   data: { title: string; status: string; variants: VariantSnapshot[] }
 ): Promise<void> {
-  await db.productSnapshot.upsert({
-    where: { shop_id: { shop, id: productId } },
-    create: {
-      id: productId,
-      shop,
-      title: data.title,
-      status: data.status,
-      variants: JSON.stringify(data.variants),
-    },
-    update: {
-      title: data.title,
-      status: data.status,
-      variants: JSON.stringify(data.variants),
-    },
+  await db.$transaction(async (tx) => {
+    // Upsert the product snapshot
+    await tx.productSnapshot.upsert({
+      where: { shop_id: { shop, id: productId } },
+      create: {
+        id: productId,
+        shop,
+        title: data.title,
+        status: data.status,
+      },
+      update: {
+        title: data.title,
+        status: data.status,
+      },
+    });
+
+    // Upsert each variant individually (atomic per-variant)
+    for (const variant of data.variants) {
+      await tx.variantSnapshot.upsert({
+        where: {
+          productSnapshotId_variantId: {
+            productSnapshotId: productId,
+            variantId: variant.id,
+          },
+        },
+        create: {
+          variantId: variant.id,
+          productSnapshotId: productId,
+          title: variant.title,
+          price: variant.price,
+          inventoryQuantity: variant.inventoryQuantity,
+        },
+        update: {
+          title: variant.title,
+          price: variant.price,
+          inventoryQuantity: variant.inventoryQuantity,
+        },
+      });
+    }
   });
 }
 
diff --git a/insightops/app/services/jobProcessor.server.ts b/insightops/app/services/jobProcessor.server.ts
index 7068c66..cfc3149 100644
--- a/insightops/app/services/jobProcessor.server.ts
+++ b/insightops/app/services/jobProcessor.server.ts
@@ -689,22 +689,19 @@ async function processInventoryUpdate(
       oldAvailable = prevDiff.available;
     }
 
-    // If no EventLog, fall back to ProductSnapshot
+    // If no EventLog, fall back to VariantSnapshot
     if (oldAvailable === null && productId && variantId) {
-      const snapshot = await db.productSnapshot.findUnique({
-        where: { shop_id: { shop, id: productId } },
+      const variantSnap = await db.variantSnapshot.findUnique({
+        where: {
+          productSnapshotId_variantId: {
+            productSnapshotId: productId,
+            variantId: variantId,
+          },
+        },
       });
-      if (snapshot?.variants) {
-        try {
-          const variants = JSON.parse(snapshot.variants) as Array<{ id: string; inventoryQuantity: number }>;
-          const matchingVariant = variants.find(v => v.id === variantId);
-          if (matchingVariant && matchingVariant.inventoryQuantity !== undefined) {
-            oldAvailable = matchingVariant.inventoryQuantity;
-            console.log(`[StoreGuard] Got previous inventory ${oldAvailable} from ProductSnapshot for ${productTitle}`);
-          }
-        } catch {
-          // Invalid JSON in snapshot
-        }
+      if (variantSnap) {
+        oldAvailable = variantSnap.inventoryQuantity;
+        console.log(`[StoreGuard] Got previous inventory ${oldAvailable} from VariantSnapshot for ${productTitle}`);
       }
     }
   } catch (prevError) {
@@ -741,45 +738,55 @@ async function processInventoryUpdate(
     }
   }
 
-  // Update or create ProductSnapshot with inventory (keeps snapshot current for future comparisons)
+  // Update or create VariantSnapshot with inventory (keeps snapshot current for future comparisons)
   if (productId && variantId) {
     try {
       const snapshot = await db.productSnapshot.findUnique({
         where: { shop_id: { shop, id: productId } },
       });
-      if (snapshot?.variants) {
-        // Update existing snapshot
-        const variants = JSON.parse(snapshot.variants) as Array<{ id: string; title: string; price: string; inventoryQuantity: number }>;
-        const variantIndex = variants.findIndex(v => v.id === variantId);
-        if (variantIndex >= 0) {
-          variants[variantIndex].inventoryQuantity = payload.available;
-          await db.productSnapshot.update({
-            where: { shop_id: { shop, id: productId } },
-            data: { variants: JSON.stringify(variants) },
-          });
-          console.log(`[StoreGuard] Updated ProductSnapshot inventory for ${productTitle}: ${payload.available}`);
-        }
-      } else if (!snapshot) {
-        // No snapshot exists - create a minimal one for future tracking
-        // This ensures the NEXT inventory change can be detected
+      if (snapshot) {
+        // Atomic single-variant update â€” no read-modify-write race condition
+        await db.variantSnapshot.upsert({
+          where: {
+            productSnapshotId_variantId: {
+              productSnapshotId: productId,
+              variantId: variantId,
+            },
+          },
+          create: {
+            productSnapshotId: productId,
+            variantId: variantId,
+            title: variantTitle || "Default Title",
+            price: "0.00",
+            inventoryQuantity: payload.available,
+          },
+          update: {
+            inventoryQuantity: payload.available,
+          },
+        });
+        console.log(`[StoreGuard] Updated VariantSnapshot inventory for ${productTitle}: ${payload.available}`);
+      } else {
+        // No snapshot exists - create product + variant for future tracking
         await db.productSnapshot.create({
           data: {
             id: productId,
             shop,
             title: productTitle,
             status: "active", // Default assumption
-            variants: JSON.stringify([{
-              id: variantId,
-              title: variantTitle || "Default Title",
-              price: "0.00",
-              inventoryQuantity: payload.available,
-            }]),
+            variants: {
+              create: {
+                variantId: variantId,
+                title: variantTitle || "Default Title",
+                price: "0.00",
+                inventoryQuantity: payload.available,
+              },
+            },
           },
         });
         console.log(`[StoreGuard] Created ProductSnapshot from inventory webhook for ${productTitle}`);
       }
     } catch (snapshotError) {
-      console.error(`[StoreGuard] Failed to update ProductSnapshot inventory:`, snapshotError);
+      console.error(`[StoreGuard] Failed to update VariantSnapshot inventory:`, snapshotError);
     }
   }
 
diff --git a/insightops/app/services/productSync.server.ts b/insightops/app/services/productSync.server.ts
index cf87dd8..2afbbdc 100644
--- a/insightops/app/services/productSync.server.ts
+++ b/insightops/app/services/productSync.server.ts
@@ -240,29 +240,52 @@ export async function syncProducts(
           },
         });
 
-        // === StoreGuard: Create ProductSnapshot for change detection ===
+        // === StoreGuard: Create ProductSnapshot + VariantSnapshots for change detection ===
         // This is what changeDetection.server.ts uses to compare before/after
-        const productSnapshotVariants = product.variants.edges.map((v) => ({
-          id: v.node.id.split("/").pop() || v.node.id,
+        const variantData = product.variants.edges.map((v) => ({
+          variantId: v.node.id.split("/").pop() || v.node.id,
           title: v.node.title,
           price: v.node.price,
           inventoryQuantity: v.node.inventoryQuantity ?? 0,
         }));
 
-        await db.productSnapshot.upsert({
-          where: { shop_id: { shop, id: numericId } },
-          create: {
-            id: numericId,
-            shop,
-            title: product.title,
-            status: product.status.toLowerCase(),
-            variants: JSON.stringify(productSnapshotVariants),
-          },
-          update: {
-            title: product.title,
-            status: product.status.toLowerCase(),
-            variants: JSON.stringify(productSnapshotVariants),
-          },
+        await db.$transaction(async (tx) => {
+          await tx.productSnapshot.upsert({
+            where: { shop_id: { shop, id: numericId } },
+            create: {
+              id: numericId,
+              shop,
+              title: product.title,
+              status: product.status.toLowerCase(),
+            },
+            update: {
+              title: product.title,
+              status: product.status.toLowerCase(),
+            },
+          });
+
+          for (const v of variantData) {
+            await tx.variantSnapshot.upsert({
+              where: {
+                productSnapshotId_variantId: {
+                  productSnapshotId: numericId,
+                  variantId: v.variantId,
+                },
+              },
+              create: {
+                productSnapshotId: numericId,
+                variantId: v.variantId,
+                title: v.title,
+                price: v.price,
+                inventoryQuantity: v.inventoryQuantity,
+              },
+              update: {
+                title: v.title,
+                price: v.price,
+                inventoryQuantity: v.inventoryQuantity,
+              },
+            });
+          }
         });
 
         // Ensure we have a baseline snapshot for this product (legacy EventLog).
diff --git a/insightops/prisma/migrations/20260218120000_normalize_variant_snapshots/migration.sql b/insightops/prisma/migrations/20260218120000_normalize_variant_snapshots/migration.sql
new file mode 100644
index 0000000..760b5f6
--- /dev/null
+++ b/insightops/prisma/migrations/20260218120000_normalize_variant_snapshots/migration.sql
@@ -0,0 +1,36 @@
+-- CreateTable
+CREATE TABLE "VariantSnapshot" (
+    "id" TEXT NOT NULL,
+    "variantId" TEXT NOT NULL,
+    "productSnapshotId" TEXT NOT NULL,
+    "title" TEXT NOT NULL,
+    "price" TEXT NOT NULL,
+    "inventoryQuantity" INTEGER NOT NULL DEFAULT 0,
+
+    CONSTRAINT "VariantSnapshot_pkey" PRIMARY KEY ("id")
+);
+
+-- Migrate existing JSON variant data into VariantSnapshot rows
+INSERT INTO "VariantSnapshot" ("id", "variantId", "productSnapshotId", "title", "price", "inventoryQuantity")
+SELECT
+    gen_random_uuid()::text,
+    v->>'id',
+    ps."id",
+    COALESCE(v->>'title', 'Default Title'),
+    COALESCE(v->>'price', '0.00'),
+    COALESCE((v->>'inventoryQuantity')::integer, 0)
+FROM "ProductSnapshot" ps,
+     json_array_elements(ps."variants"::json) AS v
+WHERE ps."variants" IS NOT NULL AND ps."variants" != '' AND ps."variants" != '[]';
+
+-- Drop the old JSON column
+ALTER TABLE "ProductSnapshot" DROP COLUMN "variants";
+
+-- CreateIndex
+CREATE INDEX "VariantSnapshot_productSnapshotId_idx" ON "VariantSnapshot"("productSnapshotId");
+
+-- CreateIndex
+CREATE UNIQUE INDEX "VariantSnapshot_productSnapshotId_variantId_key" ON "VariantSnapshot"("productSnapshotId", "variantId");
+
+-- AddForeignKey
+ALTER TABLE "VariantSnapshot" ADD CONSTRAINT "VariantSnapshot_productSnapshotId_fkey" FOREIGN KEY ("productSnapshotId") REFERENCES "ProductSnapshot"("id") ON DELETE CASCADE ON UPDATE CASCADE;
diff --git a/insightops/prisma/schema.prisma b/insightops/prisma/schema.prisma
index 72a2545..4e48d3c 100644
--- a/insightops/prisma/schema.prisma
+++ b/insightops/prisma/schema.prisma
@@ -76,17 +76,31 @@ model ChangeEvent {
 
 // Product state snapshot for change detection
 model ProductSnapshot {
-  id        String   @id // Shopify product ID
+  id        String            @id // Shopify product ID
   shop      String
   title     String
-  status    String   // "active" | "draft" | "archived"
-  variants  String   // JSON: [{id, title, price, inventoryQuantity}]
-  updatedAt DateTime @updatedAt
+  status    String            // "active" | "draft" | "archived"
+  updatedAt DateTime          @updatedAt
+  variants  VariantSnapshot[]
 
   @@unique([shop, id])
   @@index([shop])
 }
 
+// Normalized variant state â€” one row per variant, atomic updates
+model VariantSnapshot {
+  id                 String          @id @default(uuid())
+  variantId          String          // Shopify variant ID (numeric string)
+  productSnapshotId  String          // FK to ProductSnapshot.id
+  title              String
+  price              String
+  inventoryQuantity  Int             @default(0)
+  product            ProductSnapshot @relation(fields: [productSnapshotId], references: [id], onDelete: Cascade)
+
+  @@unique([productSnapshotId, variantId])
+  @@index([productSnapshotId])
+}
+
 model EventLog {
   id          String   @id @default(uuid())
   shop        String   // The store URL

