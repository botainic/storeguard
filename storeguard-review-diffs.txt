diff --git a/insightops/app/routes/app._index.tsx b/insightops/app/routes/app._index.tsx
index 29b647c..b179925 100644
--- a/insightops/app/routes/app._index.tsx
+++ b/insightops/app/routes/app._index.tsx
@@ -1,17 +1,585 @@
-import type { LoaderFunctionArgs, HeadersFunction } from "react-router";
-import { redirect, useRouteError } from "react-router";
+import type { LoaderFunctionArgs, ActionFunctionArgs, HeadersFunction } from "react-router";
+import { redirect, useLoaderData, useActionData, useNavigation, useRouteError } from "react-router";
 import { boundary } from "@shopify/shopify-app-react-router/server";
+import { useState } from "react";
 import { authenticate } from "../shopify.server";
+import { isOnboarded, completeOnboarding, getOrCreateShop } from "../services/shopService.server";
+import { getSyncStatus } from "../services/productSync.server";
+import {
+  ONBOARDING_STEPS,
+  type OnboardingStep,
+  type MonitorSelections,
+  DEFAULT_MONITORS,
+  validateEmailStep,
+  validateMonitorStep,
+} from "../services/onboarding.utils";
 
-// StoreGuard: Redirect to Changes page (the main view)
-// Uses server-side redirect to preserve all Shopify URL params
 export const loader = async ({ request }: LoaderFunctionArgs) => {
-  await authenticate.admin(request);
+  const { session } = await authenticate.admin(request);
 
-  // Preserve all query params when redirecting to /app/changes
-  const url = new URL(request.url);
-  const params = url.searchParams.toString();
-  throw redirect(`/app/changes${params ? `?${params}` : ""}`);
+  await getOrCreateShop(session.shop);
+
+  const onboarded = await isOnboarded(session.shop);
+
+  if (onboarded) {
+    const url = new URL(request.url);
+    const params = url.searchParams.toString();
+    throw redirect(`/app/changes${params ? `?${params}` : ""}`);
+  }
+
+  const syncStatus = await getSyncStatus(session.shop);
+
+  return { shop: session.shop, syncStatus };
+};
+
+interface ActionResponse {
+  success: boolean;
+  error?: string;
+}
+
+export const action = async ({ request }: ActionFunctionArgs): Promise<ActionResponse> => {
+  const { session } = await authenticate.admin(request);
+  const formData = await request.formData();
+  const intent = formData.get("intent") as string;
+
+  if (intent === "complete") {
+    const alertEmail = (formData.get("alertEmail") as string)?.trim() || null;
+    const trackPrices = formData.get("trackPrices") === "true";
+    const trackVisibility = formData.get("trackVisibility") === "true";
+    const trackInventory = formData.get("trackInventory") === "true";
+    const trackCollections = formData.get("trackCollections") === "true";
+
+    try {
+      await completeOnboarding(session.shop, {
+        alertEmail,
+        trackPrices,
+        trackVisibility,
+        trackInventory,
+        trackCollections,
+      });
+      return { success: true };
+    } catch (error) {
+      console.error("[StoreGuard] Onboarding completion failed:", error);
+      return { success: false, error: "Failed to save. Please try again." };
+    }
+  }
+
+  return { success: false, error: "Unknown action" };
+};
+
+export default function Onboarding() {
+  const { syncStatus } = useLoaderData<typeof loader>();
+  const actionData = useActionData<ActionResponse>();
+  const navigation = useNavigation();
+  const isSubmitting = navigation.state === "submitting";
+
+  const [step, setStep] = useState<OnboardingStep>("welcome");
+  const [email, setEmail] = useState("");
+  const [emailError, setEmailError] = useState<string | null>(null);
+  const [monitors, setMonitors] = useState<MonitorSelections>(DEFAULT_MONITORS);
+  const [monitorError, setMonitorError] = useState<string | null>(null);
+
+  const stepIndex = ONBOARDING_STEPS.indexOf(step);
+
+  const goNext = () => {
+    if (step === "email") {
+      const err = validateEmailStep(email);
+      if (err) {
+        setEmailError(err);
+        return;
+      }
+    }
+    if (step === "monitors") {
+      const err = validateMonitorStep(monitors);
+      if (err) {
+        setMonitorError(err);
+        return;
+      }
+    }
+    const nextIdx = stepIndex + 1;
+    if (nextIdx < ONBOARDING_STEPS.length) {
+      setStep(ONBOARDING_STEPS[nextIdx]);
+    }
+  };
+
+  const goBack = () => {
+    const prevIdx = stepIndex - 1;
+    if (prevIdx >= 0) {
+      setStep(ONBOARDING_STEPS[prevIdx]);
+    }
+  };
+
+  // After action succeeds, redirect
+  if (actionData?.success) {
+    window.location.href = "/app/changes";
+    return (
+      <div style={{ ...containerStyle, textAlign: "center", paddingTop: 120 }}>
+        <p style={{ fontSize: 14, color: "#6b7280" }}>Redirecting to your dashboard...</p>
+      </div>
+    );
+  }
+
+  return (
+    <div style={containerStyle}>
+      {/* Progress dots */}
+      <div style={{ display: "flex", justifyContent: "center", gap: 8, marginBottom: 32 }}>
+        {ONBOARDING_STEPS.map((s, i) => (
+          <div
+            key={s}
+            style={{
+              width: 8,
+              height: 8,
+              borderRadius: "50%",
+              background: i <= stepIndex ? "#000" : "#d1d5db",
+              transition: "background 0.2s",
+            }}
+          />
+        ))}
+      </div>
+
+      {step === "welcome" && <WelcomeStep onNext={goNext} />}
+      {step === "email" && (
+        <EmailStep
+          email={email}
+          setEmail={(v) => { setEmail(v); setEmailError(null); }}
+          error={emailError}
+          onNext={goNext}
+          onBack={goBack}
+        />
+      )}
+      {step === "monitors" && (
+        <MonitorStep
+          monitors={monitors}
+          setMonitors={(v) => { setMonitors(v); setMonitorError(null); }}
+          error={monitorError}
+          onNext={goNext}
+          onBack={goBack}
+        />
+      )}
+      {step === "sync" && (
+        <SyncStep
+          syncStatus={syncStatus}
+          onNext={goNext}
+          onBack={goBack}
+        />
+      )}
+      {step === "done" && (
+        <DoneStep
+          email={email}
+          monitors={monitors}
+          isSubmitting={isSubmitting}
+          error={actionData?.error ?? null}
+          onBack={goBack}
+        />
+      )}
+    </div>
+  );
+}
+
+// --- Step Components ---
+
+function WelcomeStep({ onNext }: { onNext: () => void }) {
+  return (
+    <div style={cardStyle}>
+      <div style={{ textAlign: "center" }}>
+        <div style={{ marginBottom: 16 }}>
+          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#000" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
+            <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" />
+          </svg>
+        </div>
+        <h1 style={{ fontSize: 22, fontWeight: 600, color: "#111827", marginBottom: 8 }}>
+          Welcome to StoreGuard
+        </h1>
+        <p style={{ fontSize: 14, color: "#6b7280", lineHeight: 1.6, maxWidth: 360, margin: "0 auto 24px" }}>
+          StoreGuard monitors your store for changes that cost you money — price errors, hidden
+          products, stockouts, and more. {"Let's"} get you set up in under a minute.
+        </p>
+        <button type="button" onClick={onNext} style={primaryButtonStyle}>
+          Get started
+        </button>
+      </div>
+    </div>
+  );
+}
+
+function EmailStep({
+  email,
+  setEmail,
+  error,
+  onNext,
+  onBack,
+}: {
+  email: string;
+  setEmail: (v: string) => void;
+  error: string | null;
+  onNext: () => void;
+  onBack: () => void;
+}) {
+  return (
+    <div style={cardStyle}>
+      <h2 style={headingStyle}>Where should we send alerts?</h2>
+      <p style={subStyle}>
+        {"You'll"} receive a daily digest of all detected changes, plus instant alerts if you upgrade later.
+      </p>
+
+      <input
+        type="email"
+        value={email}
+        onChange={(e) => setEmail(e.target.value)}
+        onKeyDown={(e) => { if (e.key === "Enter") { e.preventDefault(); onNext(); } }}
+        placeholder="you@example.com"
+        style={{
+          width: "100%",
+          padding: "10px 12px",
+          fontSize: 14,
+          border: error ? "1px solid #dc2626" : "1px solid #d1d5db",
+          borderRadius: 8,
+          outline: "none",
+          boxSizing: "border-box",
+          marginBottom: error ? 4 : 0,
+        }}
+      />
+      {error && <p style={{ color: "#dc2626", fontSize: 12, marginTop: 4 }}>{error}</p>}
+
+      <div style={buttonRowStyle}>
+        <button type="button" onClick={onBack} style={secondaryButtonStyle}>Back</button>
+        <button type="button" onClick={onNext} style={primaryButtonStyle}>Continue</button>
+      </div>
+    </div>
+  );
+}
+
+function MonitorStep({
+  monitors,
+  setMonitors,
+  error,
+  onNext,
+  onBack,
+}: {
+  monitors: MonitorSelections;
+  setMonitors: (v: MonitorSelections) => void;
+  error: string | null;
+  onNext: () => void;
+  onBack: () => void;
+}) {
+  const toggle = (key: keyof MonitorSelections) => {
+    setMonitors({ ...monitors, [key]: !monitors[key] });
+  };
+
+  return (
+    <div style={cardStyle}>
+      <h2 style={headingStyle}>What should we watch?</h2>
+      <p style={subStyle}>
+        Choose which changes to monitor. You can adjust these later in Settings.
+      </p>
+
+      <div style={{ display: "flex", flexDirection: "column", gap: 2, marginBottom: 16 }}>
+        <MonitorOption
+          checked={monitors.trackPrices}
+          onChange={() => toggle("trackPrices")}
+          label="Price changes"
+          description="Alert when variant prices are modified"
+        />
+        <MonitorOption
+          checked={monitors.trackVisibility}
+          onChange={() => toggle("trackVisibility")}
+          label="Visibility changes"
+          description="Alert when products are published, hidden, or archived"
+        />
+        <MonitorOption
+          checked={monitors.trackInventory}
+          onChange={() => toggle("trackInventory")}
+          label="Inventory alerts"
+          description="Alert on low stock and out of stock"
+        />
+        <MonitorOption
+          checked={monitors.trackCollections}
+          onChange={() => toggle("trackCollections")}
+          label="Collection changes"
+          description="Alert when collections are created, updated, or deleted"
+        />
+      </div>
+
+      {error && <p style={{ color: "#dc2626", fontSize: 12, marginBottom: 8 }}>{error}</p>}
+
+      <div style={buttonRowStyle}>
+        <button type="button" onClick={onBack} style={secondaryButtonStyle}>Back</button>
+        <button type="button" onClick={onNext} style={primaryButtonStyle}>Continue</button>
+      </div>
+    </div>
+  );
+}
+
+function MonitorOption({
+  checked,
+  onChange,
+  label,
+  description,
+}: {
+  checked: boolean;
+  onChange: () => void;
+  label: string;
+  description: string;
+}) {
+  return (
+    <label
+      aria-label={label}
+      style={{
+        display: "flex",
+        alignItems: "flex-start",
+        gap: 10,
+        padding: "10px 0",
+        borderBottom: "1px solid #f3f4f6",
+        cursor: "pointer",
+      }}
+    >
+      <input
+        type="checkbox"
+        checked={checked}
+        onChange={onChange}
+        style={{ width: 18, height: 18, marginTop: 1, accentColor: "#000", cursor: "pointer" }}
+      />
+      <div>
+        <div style={{ fontSize: 13, fontWeight: 500, color: "#111827" }}>{label}</div>
+        <div style={{ fontSize: 12, color: "#6b7280", marginTop: 1 }}>{description}</div>
+      </div>
+    </label>
+  );
+}
+
+function SyncStep({
+  syncStatus,
+  onNext,
+  onBack,
+}: {
+  syncStatus: { status: string; syncedProducts: number; totalProducts: number | null };
+  onNext: () => void;
+  onBack: () => void;
+}) {
+  const isSyncing = syncStatus.status === "syncing" || syncStatus.status === "pending";
+  const isCompleted = syncStatus.status === "completed";
+  const isFailed = syncStatus.status === "failed";
+
+  return (
+    <div style={cardStyle}>
+      <h2 style={headingStyle}>Syncing your products</h2>
+      <p style={subStyle}>
+        StoreGuard is creating baseline snapshots of your products so it can detect future changes.
+      </p>
+
+      <div style={{
+        padding: 16,
+        background: "#f9fafb",
+        borderRadius: 8,
+        textAlign: "center",
+        marginBottom: 16,
+      }}>
+        {isSyncing && (
+          <>
+            <div style={spinnerStyle} />
+            <p style={{ fontSize: 14, fontWeight: 500, color: "#111827", marginTop: 12 }}>
+              Syncing products...
+            </p>
+            <p style={{ fontSize: 13, color: "#6b7280", marginTop: 4 }}>
+              {syncStatus.syncedProducts} products synced
+              {syncStatus.totalProducts ? ` of ${syncStatus.totalProducts}` : ""}
+            </p>
+          </>
+        )}
+        {isCompleted && (
+          <>
+            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#16a34a" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
+              <path d="M20 6L9 17l-5-5" />
+            </svg>
+            <p style={{ fontSize: 14, fontWeight: 500, color: "#111827", marginTop: 8 }}>
+              Sync complete
+            </p>
+            <p style={{ fontSize: 13, color: "#6b7280", marginTop: 4 }}>
+              {syncStatus.syncedProducts} products ready for monitoring
+            </p>
+          </>
+        )}
+        {isFailed && (
+          <>
+            <p style={{ fontSize: 14, fontWeight: 500, color: "#dc2626" }}>
+              Sync encountered an issue
+            </p>
+            <p style={{ fontSize: 13, color: "#6b7280", marginTop: 4 }}>
+              {"Don't"} worry — StoreGuard will retry automatically. You can continue setup.
+            </p>
+          </>
+        )}
+        {syncStatus.status === "not_started" && (
+          <>
+            <p style={{ fontSize: 14, fontWeight: 500, color: "#111827" }}>
+              Sync will start automatically
+            </p>
+            <p style={{ fontSize: 13, color: "#6b7280", marginTop: 4 }}>
+              Your products will be synced in the background. You can continue setup.
+            </p>
+          </>
+        )}
+      </div>
+
+      <div style={buttonRowStyle}>
+        <button type="button" onClick={onBack} style={secondaryButtonStyle}>Back</button>
+        <button type="button" onClick={onNext} style={primaryButtonStyle}>
+          Continue
+        </button>
+      </div>
+    </div>
+  );
+}
+
+function DoneStep({
+  email,
+  monitors,
+  isSubmitting,
+  error,
+  onBack,
+}: {
+  email: string;
+  monitors: MonitorSelections;
+  isSubmitting: boolean;
+  error: string | null;
+  onBack: () => void;
+}) {
+  const activeMonitors = [
+    monitors.trackPrices && "Price changes",
+    monitors.trackVisibility && "Visibility changes",
+    monitors.trackInventory && "Inventory alerts",
+    monitors.trackCollections && "Collection changes",
+  ].filter(Boolean);
+
+  return (
+    <div style={cardStyle}>
+      <h2 style={headingStyle}>{"You're"} all set</h2>
+      <p style={subStyle}>
+        {"Here's"} a summary of your setup. You can change these anytime in Settings.
+      </p>
+
+      <div style={{ marginBottom: 20 }}>
+        <div style={summaryRowStyle}>
+          <span style={summaryLabelStyle}>Alert email</span>
+          <span style={{ fontSize: 13, color: "#111827" }}>{email}</span>
+        </div>
+        <div style={summaryRowStyle}>
+          <span style={summaryLabelStyle}>Monitors</span>
+          <span style={{ fontSize: 13, color: "#111827" }}>{activeMonitors.join(", ")}</span>
+        </div>
+      </div>
+
+      {error && (
+        <p style={{ color: "#dc2626", fontSize: 12, marginBottom: 8 }}>{error}</p>
+      )}
+
+      <form method="post">
+        <input type="hidden" name="intent" value="complete" />
+        <input type="hidden" name="alertEmail" value={email} />
+        <input type="hidden" name="trackPrices" value={String(monitors.trackPrices)} />
+        <input type="hidden" name="trackVisibility" value={String(monitors.trackVisibility)} />
+        <input type="hidden" name="trackInventory" value={String(monitors.trackInventory)} />
+        <input type="hidden" name="trackCollections" value={String(monitors.trackCollections)} />
+
+        <div style={buttonRowStyle}>
+          <button type="button" onClick={onBack} disabled={isSubmitting} style={secondaryButtonStyle}>
+            Back
+          </button>
+          <button type="submit" disabled={isSubmitting} style={{
+            ...primaryButtonStyle,
+            opacity: isSubmitting ? 0.6 : 1,
+            cursor: isSubmitting ? "not-allowed" : "pointer",
+          }}>
+            {isSubmitting ? "Finishing..." : "Start protecting my store"}
+          </button>
+        </div>
+      </form>
+    </div>
+  );
+}
+
+// --- Styles ---
+
+const containerStyle: React.CSSProperties = {
+  maxWidth: 480,
+  margin: "0 auto",
+  padding: "40px 16px",
+  fontFamily: "system-ui, sans-serif",
+};
+
+const cardStyle: React.CSSProperties = {
+  background: "#fff",
+  border: "1px solid #e5e7eb",
+  borderRadius: 12,
+  padding: "24px 20px",
+};
+
+const headingStyle: React.CSSProperties = {
+  fontSize: 18,
+  fontWeight: 600,
+  color: "#111827",
+  marginBottom: 6,
+};
+
+const subStyle: React.CSSProperties = {
+  fontSize: 13,
+  color: "#6b7280",
+  lineHeight: 1.5,
+  marginBottom: 20,
+};
+
+const buttonRowStyle: React.CSSProperties = {
+  display: "flex",
+  justifyContent: "space-between",
+  gap: 12,
+  marginTop: 20,
+};
+
+const primaryButtonStyle: React.CSSProperties = {
+  background: "#000",
+  color: "#fff",
+  padding: "10px 20px",
+  fontSize: 14,
+  fontWeight: 500,
+  border: "none",
+  borderRadius: 8,
+  cursor: "pointer",
+  minHeight: 44,
+};
+
+const secondaryButtonStyle: React.CSSProperties = {
+  background: "#fff",
+  color: "#374151",
+  padding: "10px 16px",
+  fontSize: 14,
+  fontWeight: 500,
+  border: "1px solid #d1d5db",
+  borderRadius: 8,
+  cursor: "pointer",
+  minHeight: 44,
+};
+
+const summaryRowStyle: React.CSSProperties = {
+  display: "flex",
+  justifyContent: "space-between",
+  padding: "10px 0",
+  borderBottom: "1px solid #f3f4f6",
+};
+
+const summaryLabelStyle: React.CSSProperties = {
+  fontSize: 13,
+  color: "#6b7280",
+  fontWeight: 500,
+};
+
+const spinnerStyle: React.CSSProperties = {
+  width: 24,
+  height: 24,
+  border: "3px solid #e5e7eb",
+  borderTop: "3px solid #000",
+  borderRadius: "50%",
+  animation: "spin 1s linear infinite",
+  margin: "0 auto",
 };
 
 // Required for Shopify to handle exit-iframe redirect via App Bridge
diff --git a/insightops/app/routes/app.changes.test.ts b/insightops/app/routes/app.changes.test.ts
index 69dbc6d..3ad303a 100644
--- a/insightops/app/routes/app.changes.test.ts
+++ b/insightops/app/routes/app.changes.test.ts
@@ -12,6 +12,15 @@ const eventConfig: Record<string, { label: string; color: string }> = {
   inventory_low: { label: "Low Stock", color: "#f97316" },
   inventory_zero: { label: "Out of Stock", color: "#e74c3c" },
   theme_publish: { label: "Theme Published", color: "#3498db" },
+  collection_created: { label: "Collection Created", color: "#10b981" },
+  collection_updated: { label: "Collection Updated", color: "#10b981" },
+  collection_deleted: { label: "Collection Deleted", color: "#e74c3c" },
+  discount_created: { label: "Discount Created", color: "#8b5cf6" },
+  discount_changed: { label: "Discount Changed", color: "#8b5cf6" },
+  discount_deleted: { label: "Discount Deleted", color: "#e74c3c" },
+  app_permissions_changed: { label: "App Permissions", color: "#6366f1" },
+  domain_changed: { label: "Domain Changed", color: "#0891b2" },
+  domain_removed: { label: "Domain Removed", color: "#e74c3c" },
 };
 
 const importanceConfig: Record<string, { label: string; color: string }> = {
@@ -27,6 +36,15 @@ const ALL_EVENT_TYPES = [
   "inventory_low",
   "inventory_zero",
   "theme_publish",
+  "collection_created",
+  "collection_updated",
+  "collection_deleted",
+  "discount_created",
+  "discount_changed",
+  "discount_deleted",
+  "app_permissions_changed",
+  "domain_changed",
+  "domain_removed",
 ];
 
 const ALL_IMPORTANCE_LEVELS = ["high", "medium", "low"];
diff --git a/insightops/app/routes/app.changes.tsx b/insightops/app/routes/app.changes.tsx
index d824c80..a0ef45f 100644
--- a/insightops/app/routes/app.changes.tsx
+++ b/insightops/app/routes/app.changes.tsx
@@ -42,6 +42,15 @@ const eventConfig: Record<string, { label: string; color: string }> = {
   inventory_low: { label: "Low Stock", color: "#f97316" },
   inventory_zero: { label: "Out of Stock", color: "#e74c3c" },
   theme_publish: { label: "Theme Published", color: "#3498db" },
+  collection_created: { label: "Collection Created", color: "#10b981" },
+  collection_updated: { label: "Collection Updated", color: "#10b981" },
+  collection_deleted: { label: "Collection Deleted", color: "#e74c3c" },
+  discount_created: { label: "Discount Created", color: "#8b5cf6" },
+  discount_changed: { label: "Discount Changed", color: "#8b5cf6" },
+  discount_deleted: { label: "Discount Deleted", color: "#e74c3c" },
+  app_permissions_changed: { label: "App Permissions", color: "#6366f1" },
+  domain_changed: { label: "Domain Changed", color: "#0891b2" },
+  domain_removed: { label: "Domain Removed", color: "#e74c3c" },
 };
 
 const importanceConfig: Record<string, { label: string; color: string }> = {
@@ -197,10 +206,14 @@ export default function RecentChanges() {
                     const ctx = JSON.parse(event.contextData) as {
                       velocityContext?: string | null;
                       revenueImpact?: number | null;
+                      locationContext?: string | null;
                     };
-                    if (!ctx.velocityContext && ctx.revenueImpact === null) return null;
+                    if (!ctx.velocityContext && ctx.revenueImpact === null && !ctx.locationContext) return null;
                     return (
                       <div style={{ marginTop: 6, fontSize: 12, color: "#6b7280" }}>
+                        {ctx.locationContext && (
+                          <span style={{ marginRight: 8 }}>{ctx.locationContext}</span>
+                        )}
                         {ctx.velocityContext && (
                           <span style={{ marginRight: 8 }}>{ctx.velocityContext}</span>
                         )}
diff --git a/insightops/app/routes/app.settings.tsx b/insightops/app/routes/app.settings.tsx
index 1ec2a02..0c82ff7 100644
--- a/insightops/app/routes/app.settings.tsx
+++ b/insightops/app/routes/app.settings.tsx
@@ -28,6 +28,10 @@ export const action = async ({ request }: ActionFunctionArgs): Promise<ActionRes
   const trackVisibility = formData.get("trackVisibility") === "on";
   const trackInventory = formData.get("trackInventory") === "on";
   const trackThemes = formData.get("trackThemes") === "on";
+  const trackCollections = formData.get("trackCollections") === "on";
+  const trackDiscounts = formData.get("trackDiscounts") === "on";
+  const trackAppPermissions = formData.get("trackAppPermissions") === "on";
+  const trackDomains = formData.get("trackDomains") === "on";
   const lowStockThreshold = parseInt(formData.get("lowStockThreshold") as string) || 5;
   const instantAlerts = formData.get("instantAlerts") === "on";
 
@@ -50,6 +54,10 @@ export const action = async ({ request }: ActionFunctionArgs): Promise<ActionRes
       trackVisibility,
       trackInventory,
       trackThemes,
+      trackCollections,
+      trackDiscounts,
+      trackAppPermissions,
+      trackDomains,
       lowStockThreshold,
       instantAlerts,
     });
@@ -200,6 +208,20 @@ export default function Settings() {
               </label>
             </div>
           )}
+          <Toggle
+            name="trackCollections"
+            label="Collection changes"
+            description="Track when collections are created, updated, or deleted"
+            defaultChecked={settings.trackCollections}
+          />
+          <Toggle
+            name="trackDiscounts"
+            label="Discount changes"
+            description="Track when discounts are created, modified, or deleted"
+            defaultChecked={settings.trackDiscounts}
+            disabled={settings.plan !== "pro"}
+            proOnly
+          />
           <Toggle
             name="trackThemes"
             label="Theme publishes"
@@ -208,6 +230,22 @@ export default function Settings() {
             disabled={settings.plan !== "pro"}
             proOnly
           />
+          <Toggle
+            name="trackAppPermissions"
+            label="App permission changes"
+            description="Track when installed apps expand or change their permissions"
+            defaultChecked={settings.trackAppPermissions}
+            disabled={settings.plan !== "pro"}
+            proOnly
+          />
+          <Toggle
+            name="trackDomains"
+            label="Domain changes"
+            description="Track when domains are added, changed, or removed"
+            defaultChecked={settings.trackDomains}
+            disabled={settings.plan !== "pro"}
+            proOnly
+          />
         </Section>
 
         {/* 2. Your Plan */}
diff --git a/insightops/app/routes/webhooks.compliance.tsx b/insightops/app/routes/webhooks.compliance.tsx
index e6ef0e4..eddb0d6 100644
--- a/insightops/app/routes/webhooks.compliance.tsx
+++ b/insightops/app/routes/webhooks.compliance.tsx
@@ -42,11 +42,6 @@ export const action = async ({ request }: ActionFunctionArgs) => {
           where: { shop },
         });
 
-        // Delete event logs
-        await db.eventLog.deleteMany({
-          where: { shop },
-        });
-
         // Delete product snapshots
         await db.productSnapshot.deleteMany({
           where: { shop },
diff --git a/insightops/app/routes/webhooks.discounts.create.tsx b/insightops/app/routes/webhooks.discounts.create.tsx
new file mode 100644
index 0000000..ae71798
--- /dev/null
+++ b/insightops/app/routes/webhooks.discounts.create.tsx
@@ -0,0 +1,29 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob } from "../services/jobQueue.server";
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    return new Response();
+  }
+
+  const discount = payload as { id: number };
+
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(discount.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
+
+  return new Response();
+};
diff --git a/insightops/app/routes/webhooks.discounts.delete.tsx b/insightops/app/routes/webhooks.discounts.delete.tsx
new file mode 100644
index 0000000..ae71798
--- /dev/null
+++ b/insightops/app/routes/webhooks.discounts.delete.tsx
@@ -0,0 +1,29 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob } from "../services/jobQueue.server";
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    return new Response();
+  }
+
+  const discount = payload as { id: number };
+
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(discount.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
+
+  return new Response();
+};
diff --git a/insightops/app/routes/webhooks.discounts.update.tsx b/insightops/app/routes/webhooks.discounts.update.tsx
new file mode 100644
index 0000000..ae71798
--- /dev/null
+++ b/insightops/app/routes/webhooks.discounts.update.tsx
@@ -0,0 +1,29 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob } from "../services/jobQueue.server";
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    return new Response();
+  }
+
+  const discount = payload as { id: number };
+
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(discount.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
+
+  return new Response();
+};
diff --git a/insightops/app/routes/webhooks.domains.create.tsx b/insightops/app/routes/webhooks.domains.create.tsx
new file mode 100644
index 0000000..1033f84
--- /dev/null
+++ b/insightops/app/routes/webhooks.domains.create.tsx
@@ -0,0 +1,29 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob } from "../services/jobQueue.server";
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    return new Response();
+  }
+
+  const domain = payload as { id: number };
+
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(domain.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
+
+  return new Response();
+};
diff --git a/insightops/app/routes/webhooks.domains.destroy.tsx b/insightops/app/routes/webhooks.domains.destroy.tsx
new file mode 100644
index 0000000..1033f84
--- /dev/null
+++ b/insightops/app/routes/webhooks.domains.destroy.tsx
@@ -0,0 +1,29 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob } from "../services/jobQueue.server";
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    return new Response();
+  }
+
+  const domain = payload as { id: number };
+
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(domain.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
+
+  return new Response();
+};
diff --git a/insightops/app/routes/webhooks.domains.update.tsx b/insightops/app/routes/webhooks.domains.update.tsx
new file mode 100644
index 0000000..1033f84
--- /dev/null
+++ b/insightops/app/routes/webhooks.domains.update.tsx
@@ -0,0 +1,29 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob } from "../services/jobQueue.server";
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    return new Response();
+  }
+
+  const domain = payload as { id: number };
+
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(domain.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
+
+  return new Response();
+};
diff --git a/insightops/app/services/changeDetection.server.ts b/insightops/app/services/changeDetection.server.ts
index b1f1c7c..ca3c714 100644
--- a/insightops/app/services/changeDetection.server.ts
+++ b/insightops/app/services/changeDetection.server.ts
@@ -8,6 +8,7 @@ import {
   shouldAlertInventoryZero as checkInventoryZero,
   shouldAlertLowStock as checkLowStock,
   formatVariantLabel,
+  isCriticalInstantAlert,
 } from "./changeDetection.utils";
 import { getProductSalesVelocity } from "./salesVelocity.server";
 import { formatVelocityContext, estimateRevenueImpact } from "./salesVelocity.utils";
@@ -60,20 +61,21 @@ async function getProductSnapshot(shop: string, productId: string): Promise<{
 } | null> {
   const snapshot = await db.productSnapshot.findUnique({
     where: { shop_id: { shop, id: productId } },
+    include: { variants: true },
   });
 
   if (!snapshot) return null;
 
-  try {
-    const variants = JSON.parse(snapshot.variants) as VariantSnapshot[];
-    return {
-      title: snapshot.title,
-      status: snapshot.status,
-      variants,
-    };
-  } catch {
-    return null;
-  }
+  return {
+    title: snapshot.title,
+    status: snapshot.status,
+    variants: snapshot.variants.map(v => ({
+      id: v.shopifyVariantId,
+      title: v.title,
+      price: v.price,
+      inventoryQuantity: v.inventoryQuantity,
+    })),
+  };
 }
 
 /**
@@ -84,21 +86,83 @@ async function updateProductSnapshot(
   productId: string,
   data: { title: string; status: string; variants: VariantSnapshot[] }
 ): Promise<void> {
-  await db.productSnapshot.upsert({
-    where: { shop_id: { shop, id: productId } },
-    create: {
-      id: productId,
+  await db.$transaction(async (tx) => {
+    await tx.productSnapshot.upsert({
+      where: { shop_id: { shop, id: productId } },
+      create: {
+        id: productId,
+        shop,
+        title: data.title,
+        status: data.status,
+      },
+      update: {
+        title: data.title,
+        status: data.status,
+      },
+    });
+
+    for (const v of data.variants) {
+      await tx.variantSnapshot.upsert({
+        where: {
+          productSnapshotId_shopifyVariantId: {
+            productSnapshotId: productId,
+            shopifyVariantId: String(v.id),
+          },
+        },
+        create: {
+          productSnapshotId: productId,
+          shop,
+          shopifyVariantId: String(v.id),
+          title: v.title,
+          price: String(v.price),
+          inventoryQuantity: v.inventoryQuantity,
+        },
+        update: {
+          title: v.title,
+          price: String(v.price),
+          inventoryQuantity: v.inventoryQuantity,
+        },
+      });
+    }
+  });
+}
+
+/** Max instant alert emails per shop per hour */
+const INSTANT_ALERT_RATE_LIMIT = 10;
+
+/**
+ * Decide whether to send an instant alert for a change event.
+ * Returns true only when:
+ * 1. The shop has instant alerts enabled (Pro + toggle on + email set)
+ * 2. The event is critical (price drop >50%, out of stock, visibility hidden, domain removed, permissions expanded)
+ * 3. The shop has not exceeded the rate limit (max 10 per hour)
+ */
+export async function shouldSendInstantAlert(
+  shop: string,
+  event: { eventType: string; importance: string; afterValue?: string | null }
+): Promise<boolean> {
+  // 1. Feature gate: Pro plan + instant alerts enabled + email configured
+  const enabled = await hasInstantAlerts(shop);
+  if (!enabled) return false;
+
+  // 2. Severity check: only critical events
+  if (!isCriticalInstantAlert(event)) return false;
+
+  // 3. Rate limit: max 10 instant alert emails per shop per hour
+  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
+  const recentAlertCount = await db.changeEvent.count({
+    where: {
       shop,
-      title: data.title,
-      status: data.status,
-      variants: JSON.stringify(data.variants),
-    },
-    update: {
-      title: data.title,
-      status: data.status,
-      variants: JSON.stringify(data.variants),
+      instantAlertSentAt: { not: null, gte: oneHourAgo },
     },
   });
+
+  if (recentAlertCount >= INSTANT_ALERT_RATE_LIMIT) {
+    console.log(`[StoreGuard] Rate limit reached for ${shop}: ${recentAlertCount} instant alerts in last hour`);
+    return false;
+  }
+
+  return true;
 }
 
 /**
@@ -106,9 +170,9 @@ async function updateProductSnapshot(
  */
 async function createChangeEvent(data: {
   shop: string;
-  entityType: "product" | "variant" | "theme";
+  entityType: string;
   entityId: string;
-  eventType: "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish";
+  eventType: string;
   resourceName: string;
   beforeValue: string | null;
   afterValue: string | null;
@@ -119,6 +183,15 @@ async function createChangeEvent(data: {
   contextData?: string | null;
 }): Promise<void> {
   try {
+    const importance = data.importance ?? "medium";
+
+    // Check instant alert eligibility BEFORE creating the event (for rate limit accuracy)
+    const sendInstant = await shouldSendInstantAlert(data.shop, {
+      eventType: data.eventType,
+      importance,
+      afterValue: data.afterValue,
+    });
+
     const event = await db.changeEvent.create({
       data: {
         shop: data.shop,
@@ -130,16 +203,16 @@ async function createChangeEvent(data: {
         afterValue: data.afterValue,
         webhookId: data.webhookId,
         source: data.source ?? "webhook",
-        importance: data.importance ?? "medium",
+        importance,
         groupId: data.groupId,
         contextData: data.contextData ?? null,
+        instantAlertSentAt: sendInstant ? new Date() : null,
       },
     });
     console.log(`[StoreGuard] Created ${data.eventType} event for "${data.resourceName}"`);
 
-    // Send instant alert if enabled (Pro feature)
-    const shouldSendInstant = await hasInstantAlerts(data.shop);
-    if (shouldSendInstant) {
+    // Send instant alert for critical events only
+    if (sendInstant) {
       const alertEmail = await getShopAlertEmail(data.shop);
       if (alertEmail) {
         // Fire and forget - don't block on email sending
@@ -149,7 +222,7 @@ async function createChangeEvent(data: {
             resourceName: data.resourceName,
             beforeValue: data.beforeValue,
             afterValue: data.afterValue,
-            importance: data.importance ?? "medium",
+            importance,
             detectedAt: event.detectedAt,
             contextData: data.contextData ?? null,
           },
@@ -368,7 +441,8 @@ export async function detectInventoryZero(
   variantTitle: string,
   newQuantity: number,
   previousQuantity: number | null, // Must be provided from webhook processing
-  webhookId: string
+  webhookId: string,
+  locationContext?: string | null
 ): Promise<boolean> {
   // Check if shop wants to track inventory
   if (!await canTrackFeature(shop, "inventory")) {
@@ -406,9 +480,11 @@ export async function detectInventoryZero(
 
   const velocityContext = formatVelocityContext(velocity);
   const revenueImpact = estimateRevenueImpact(velocity, "stockout", {});
-  const contextData = (velocityContext || revenueImpact !== null)
-    ? JSON.stringify({ velocityContext, revenueImpact })
-    : null;
+  const ctxObj: Record<string, unknown> = {};
+  if (velocityContext) ctxObj.velocityContext = velocityContext;
+  if (revenueImpact !== null) ctxObj.revenueImpact = revenueImpact;
+  if (locationContext) ctxObj.locationContext = locationContext;
+  const contextData = Object.keys(ctxObj).length > 0 ? JSON.stringify(ctxObj) : null;
 
   await createChangeEvent({
     shop,
@@ -439,7 +515,8 @@ export async function detectLowStock(
   variantTitle: string,
   newQuantity: number,
   previousQuantity: number | null,
-  webhookId: string
+  webhookId: string,
+  locationContext?: string | null
 ): Promise<boolean> {
   // Get the shop's low stock threshold
   const threshold = await getLowStockThreshold(shop);
@@ -480,9 +557,11 @@ export async function detectLowStock(
 
   const velocityContext = formatVelocityContext(velocity);
   const revenueImpact = estimateRevenueImpact(velocity, "stockout", {});
-  const contextData = (velocityContext || revenueImpact !== null)
-    ? JSON.stringify({ velocityContext, revenueImpact })
-    : null;
+  const ctxObj: Record<string, unknown> = {};
+  if (velocityContext) ctxObj.velocityContext = velocityContext;
+  if (revenueImpact !== null) ctxObj.revenueImpact = revenueImpact;
+  if (locationContext) ctxObj.locationContext = locationContext;
+  const contextData = Object.keys(ctxObj).length > 0 ? JSON.stringify(ctxObj) : null;
 
   await createChangeEvent({
     shop,
@@ -540,6 +619,315 @@ export async function recordThemePublish(
   return true;
 }
 
+// ============================================
+// COLLECTION CHANGE DETECTION
+// ============================================
+
+/**
+ * Record a collection created event
+ */
+export async function recordCollectionCreated(
+  shop: string,
+  collectionId: string,
+  collectionTitle: string,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "collections")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "collection",
+    entityId: collectionId,
+    eventType: "collection_created",
+    resourceName: collectionTitle,
+    beforeValue: null,
+    afterValue: collectionTitle,
+    webhookId: `${webhookId}-collection-created`,
+    importance: "low",
+  });
+
+  return true;
+}
+
+/**
+ * Record a collection updated event
+ */
+export async function recordCollectionUpdated(
+  shop: string,
+  collectionId: string,
+  collectionTitle: string,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "collections")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "collection",
+    entityId: collectionId,
+    eventType: "collection_updated",
+    resourceName: collectionTitle,
+    beforeValue: null,
+    afterValue: collectionTitle,
+    webhookId: `${webhookId}-collection-updated`,
+    importance: "medium",
+  });
+
+  return true;
+}
+
+/**
+ * Record a collection deleted event
+ * HIGH importance — deleting a collection breaks links and navigation
+ */
+export async function recordCollectionDeleted(
+  shop: string,
+  collectionId: string,
+  collectionTitle: string,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "collections")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "collection",
+    entityId: collectionId,
+    eventType: "collection_deleted",
+    resourceName: collectionTitle,
+    beforeValue: collectionTitle,
+    afterValue: null,
+    webhookId: `${webhookId}-collection-deleted`,
+    importance: "high",
+  });
+
+  return true;
+}
+
+// ============================================
+// DISCOUNT CHANGE DETECTION (Pro only)
+// ============================================
+
+/**
+ * Record a discount created event
+ */
+export async function recordDiscountCreated(
+  shop: string,
+  discountId: string,
+  discountTitle: string,
+  discountValue: string | null,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "discounts")) {
+    return false;
+  }
+
+  // Large discounts (>=50%) are high importance
+  let importance: "high" | "medium" | "low" = "medium";
+  if (discountValue) {
+    const numericValue = parseFloat(discountValue);
+    if (!isNaN(numericValue) && numericValue >= 50) {
+      importance = "high";
+    }
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "discount",
+    entityId: discountId,
+    eventType: "discount_created",
+    resourceName: discountTitle,
+    beforeValue: null,
+    afterValue: discountValue ? `${discountValue}% off` : discountTitle,
+    webhookId: `${webhookId}-discount-created`,
+    importance,
+  });
+
+  return true;
+}
+
+/**
+ * Record a discount updated event
+ */
+export async function recordDiscountUpdated(
+  shop: string,
+  discountId: string,
+  discountTitle: string,
+  discountValue: string | null,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "discounts")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "discount",
+    entityId: discountId,
+    eventType: "discount_changed",
+    resourceName: discountTitle,
+    beforeValue: null,
+    afterValue: discountValue ? `${discountValue}% off` : discountTitle,
+    webhookId: `${webhookId}-discount-changed`,
+    importance: "medium",
+  });
+
+  return true;
+}
+
+/**
+ * Record a discount deleted event
+ * HIGH importance — deleting a discount can break promotions
+ */
+export async function recordDiscountDeleted(
+  shop: string,
+  discountId: string,
+  discountTitle: string,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "discounts")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "discount",
+    entityId: discountId,
+    eventType: "discount_deleted",
+    resourceName: discountTitle,
+    beforeValue: discountTitle,
+    afterValue: null,
+    webhookId: `${webhookId}-discount-deleted`,
+    importance: "high",
+  });
+
+  return true;
+}
+
+// ============================================
+// APP PERMISSION CHANGE DETECTION (Pro only)
+// ============================================
+
+/**
+ * Record an app permissions changed event.
+ * Diffs previous vs current scopes.
+ * HIGH importance for scope expansions (new permissions added).
+ */
+export async function recordAppPermissionsChanged(
+  shop: string,
+  previousScopes: string[],
+  currentScopes: string[],
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "app_permissions")) {
+    return false;
+  }
+
+  // Diff scopes
+  const added = currentScopes.filter(s => !previousScopes.includes(s));
+  const removed = previousScopes.filter(s => !currentScopes.includes(s));
+
+  // No actual change
+  if (added.length === 0 && removed.length === 0) {
+    return false;
+  }
+
+  // Scope expansions are HIGH importance (security risk)
+  const importance: "high" | "medium" | "low" = added.length > 0 ? "high" : "medium";
+
+  let resourceName = "App permissions";
+  if (added.length > 0 && removed.length === 0) {
+    resourceName = `${added.length} scope${added.length > 1 ? "s" : ""} added`;
+  } else if (removed.length > 0 && added.length === 0) {
+    resourceName = `${removed.length} scope${removed.length > 1 ? "s" : ""} removed`;
+  } else {
+    resourceName = `${added.length} added, ${removed.length} removed`;
+  }
+
+  const contextData = JSON.stringify({ added, removed });
+
+  await createChangeEvent({
+    shop,
+    entityType: "app",
+    entityId: shop,
+    eventType: "app_permissions_changed",
+    resourceName,
+    beforeValue: previousScopes.join(", "),
+    afterValue: currentScopes.join(", "),
+    webhookId: `${webhookId}-app-permissions`,
+    importance,
+    contextData,
+  });
+
+  return true;
+}
+
+// ============================================
+// DOMAIN CHANGE DETECTION (Pro only)
+// ============================================
+
+/**
+ * Record a domain changed event (created or updated)
+ * HIGH importance — domain changes affect SEO and store access
+ */
+export async function recordDomainChanged(
+  shop: string,
+  domainId: string,
+  domainHost: string,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "domains")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "domain",
+    entityId: domainId,
+    eventType: "domain_changed",
+    resourceName: domainHost,
+    beforeValue: null,
+    afterValue: domainHost,
+    webhookId: `${webhookId}-domain-changed`,
+    importance: "high",
+  });
+
+  return true;
+}
+
+/**
+ * Record a domain removed event
+ * HIGH importance — removing a domain breaks store access
+ */
+export async function recordDomainRemoved(
+  shop: string,
+  domainId: string,
+  domainHost: string,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "domains")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "domain",
+    entityId: domainId,
+    eventType: "domain_removed",
+    resourceName: domainHost,
+    beforeValue: domainHost,
+    afterValue: null,
+    webhookId: `${webhookId}-domain-removed`,
+    importance: "high",
+  });
+
+  return true;
+}
+
 /**
  * Process a product update and detect all relevant changes
  * This is the main entry point called from jobProcessor
diff --git a/insightops/app/services/changeDetection.test.ts b/insightops/app/services/changeDetection.test.ts
index 22e5097..050e6ee 100644
--- a/insightops/app/services/changeDetection.test.ts
+++ b/insightops/app/services/changeDetection.test.ts
@@ -6,6 +6,7 @@ import {
   shouldAlertInventoryZero,
   shouldAlertLowStock,
   formatVariantLabel,
+  isCriticalInstantAlert,
 } from "./changeDetection.utils";
 
 describe("calculatePriceImportance", () => {
@@ -155,3 +156,85 @@ describe("formatVariantLabel", () => {
     expect(formatVariantLabel("Widget", null)).toBe("Widget");
   });
 });
+
+describe("isCriticalInstantAlert", () => {
+  // Price changes: only high importance (>50% drop) triggers instant alert
+  it("should return true for high-importance price changes (>50% drop)", () => {
+    expect(isCriticalInstantAlert({ eventType: "price_change", importance: "high" })).toBe(true);
+  });
+
+  it("should return false for medium-importance price changes", () => {
+    expect(isCriticalInstantAlert({ eventType: "price_change", importance: "medium" })).toBe(false);
+  });
+
+  it("should return false for low-importance price changes", () => {
+    expect(isCriticalInstantAlert({ eventType: "price_change", importance: "low" })).toBe(false);
+  });
+
+  // Inventory zero: always critical
+  it("should return true for inventory_zero events", () => {
+    expect(isCriticalInstantAlert({ eventType: "inventory_zero", importance: "high" })).toBe(true);
+  });
+
+  // Visibility: only when product becomes hidden
+  it("should return true when product is hidden (active -> draft)", () => {
+    expect(isCriticalInstantAlert({
+      eventType: "visibility_change",
+      importance: "high",
+      afterValue: "draft",
+    })).toBe(true);
+  });
+
+  it("should return true when product is archived (active -> archived)", () => {
+    expect(isCriticalInstantAlert({
+      eventType: "visibility_change",
+      importance: "high",
+      afterValue: "archived",
+    })).toBe(true);
+  });
+
+  it("should return false when product becomes visible (draft -> active)", () => {
+    expect(isCriticalInstantAlert({
+      eventType: "visibility_change",
+      importance: "medium",
+      afterValue: "active",
+    })).toBe(false);
+  });
+
+  // Domain removed: always critical
+  it("should return true for domain_removed events", () => {
+    expect(isCriticalInstantAlert({ eventType: "domain_removed", importance: "high" })).toBe(true);
+  });
+
+  // App permissions expanded: only high importance (scopes added)
+  it("should return true for high-importance app_permissions_changed (scopes expanded)", () => {
+    expect(isCriticalInstantAlert({ eventType: "app_permissions_changed", importance: "high" })).toBe(true);
+  });
+
+  it("should return false for medium-importance app_permissions_changed (scopes removed only)", () => {
+    expect(isCriticalInstantAlert({ eventType: "app_permissions_changed", importance: "medium" })).toBe(false);
+  });
+
+  // Non-critical event types should never trigger
+  it("should return false for inventory_low events", () => {
+    expect(isCriticalInstantAlert({ eventType: "inventory_low", importance: "medium" })).toBe(false);
+  });
+
+  it("should return false for theme_publish events", () => {
+    expect(isCriticalInstantAlert({ eventType: "theme_publish", importance: "high" })).toBe(false);
+  });
+
+  it("should return false for collection events", () => {
+    expect(isCriticalInstantAlert({ eventType: "collection_created", importance: "low" })).toBe(false);
+    expect(isCriticalInstantAlert({ eventType: "collection_deleted", importance: "high" })).toBe(false);
+  });
+
+  it("should return false for discount events", () => {
+    expect(isCriticalInstantAlert({ eventType: "discount_created", importance: "medium" })).toBe(false);
+    expect(isCriticalInstantAlert({ eventType: "discount_deleted", importance: "high" })).toBe(false);
+  });
+
+  it("should return false for domain_changed events", () => {
+    expect(isCriticalInstantAlert({ eventType: "domain_changed", importance: "high" })).toBe(false);
+  });
+});
diff --git a/insightops/app/services/changeDetection.utils.ts b/insightops/app/services/changeDetection.utils.ts
index cf64cce..bf8c4ae 100644
--- a/insightops/app/services/changeDetection.utils.ts
+++ b/insightops/app/services/changeDetection.utils.ts
@@ -102,3 +102,66 @@ export function formatVariantLabel(
   }
   return `${productTitle} - ${variantTitle}`;
 }
+
+/**
+ * Determine if a change event is critical enough for an immediate instant alert.
+ *
+ * Critical events:
+ * - Price drop >50% (importance "high" on price_change)
+ * - Out of stock across all locations (inventory_zero)
+ * - Product hidden from store (visibility_change to draft/archived)
+ * - Domain removed (domain_removed)
+ * - App permissions expanded (app_permissions_changed with importance "high")
+ */
+export function isCriticalInstantAlert(event: {
+  eventType: string;
+  importance: string;
+  afterValue?: string | null;
+}): boolean {
+  switch (event.eventType) {
+    case "price_change":
+      return event.importance === "high";
+    case "inventory_zero":
+      return true;
+    case "visibility_change":
+      return event.afterValue === "draft" || event.afterValue === "archived";
+    case "domain_removed":
+      return true;
+    case "app_permissions_changed":
+      return event.importance === "high";
+    default:
+      return false;
+  }
+}
+
+/** Shape of each inventory level node returned by Shopify GraphQL */
+export interface InventoryLevelNode {
+  quantities: Array<{ quantity: number }>;
+  location: { id: string; name: string } | null;
+}
+
+/**
+ * Aggregate inventory level nodes into a total quantity and trigger location name.
+ * Used by fetchTotalInventory after paginating through all inventory levels.
+ */
+export function aggregateInventoryLevels(
+  nodes: InventoryLevelNode[],
+  triggerLocationId: number
+): { totalQuantity: number; locationName: string | null } {
+  let totalQuantity = 0;
+  let locationName: string | null = null;
+
+  for (const level of nodes) {
+    const qty = level.quantities?.[0]?.quantity ?? 0;
+    totalQuantity += qty;
+
+    // Identify the triggering location
+    const locGid: string = level.location?.id ?? "";
+    const locMatch = locGid.match(/\/Location\/(\d+)$/);
+    if (locMatch?.[1] === String(triggerLocationId)) {
+      locationName = level.location?.name ?? null;
+    }
+  }
+
+  return { totalQuantity, locationName };
+}
diff --git a/insightops/app/services/dailyDigest.server.ts b/insightops/app/services/dailyDigest.server.ts
index 02b6584..8950192 100644
--- a/insightops/app/services/dailyDigest.server.ts
+++ b/insightops/app/services/dailyDigest.server.ts
@@ -28,13 +28,7 @@ export interface DigestSummary {
   periodEnd: Date;
   totalChanges: number;
   highPriorityCount: number;
-  eventsByType: {
-    price_change: DigestEvent[];
-    visibility_change: DigestEvent[];
-    inventory_low: DigestEvent[];
-    inventory_zero: DigestEvent[];
-    theme_publish: DigestEvent[];
-  };
+  eventsByType: Record<string, DigestEvent[]>;
 }
 
 /**
@@ -110,14 +104,8 @@ export async function generateDigestForShop(shopDomain: string): Promise<DigestS
     return null;
   }
 
-  // Group events by type
-  const eventsByType = {
-    price_change: [] as DigestEvent[],
-    visibility_change: [] as DigestEvent[],
-    inventory_low: [] as DigestEvent[],
-    inventory_zero: [] as DigestEvent[],
-    theme_publish: [] as DigestEvent[],
-  };
+  // Group events by type dynamically
+  const eventsByType: Record<string, DigestEvent[]> = {};
 
   let highPriorityCount = 0;
 
@@ -139,11 +127,10 @@ export async function generateDigestForShop(shopDomain: string): Promise<DigestS
       highPriorityCount++;
     }
 
-    // Add to appropriate category
-    const eventType = event.eventType as keyof typeof eventsByType;
-    if (eventsByType[eventType]) {
-      eventsByType[eventType].push(digestEvent);
+    if (!eventsByType[event.eventType]) {
+      eventsByType[event.eventType] = [];
     }
+    eventsByType[event.eventType].push(digestEvent);
   }
 
   // Build summary
@@ -181,14 +168,10 @@ export async function markEventsAsDigested(eventIds: string[]): Promise<void> {
  * Get all event IDs from a digest summary
  */
 export function getEventIdsFromDigest(digest: DigestSummary): string[] {
-  const allEvents = [
-    ...digest.eventsByType.price_change,
-    ...digest.eventsByType.visibility_change,
-    ...digest.eventsByType.inventory_low,
-    ...digest.eventsByType.inventory_zero,
-    ...digest.eventsByType.theme_publish,
-  ];
-
+  const allEvents: DigestEvent[] = [];
+  for (const events of Object.values(digest.eventsByType)) {
+    allEvents.push(...events);
+  }
   return allEvents.map((e) => e.id);
 }
 
@@ -207,8 +190,26 @@ export function formatEventType(eventType: string): string {
       return "Out of Stock";
     case "theme_publish":
       return "Theme Published";
+    case "collection_created":
+      return "Collection Created";
+    case "collection_updated":
+      return "Collection Updated";
+    case "collection_deleted":
+      return "Collection Deleted";
+    case "discount_created":
+      return "Discount Created";
+    case "discount_changed":
+      return "Discount Changed";
+    case "discount_deleted":
+      return "Discount Deleted";
+    case "app_permissions_changed":
+      return "App Permissions Changed";
+    case "domain_changed":
+      return "Domain Changed";
+    case "domain_removed":
+      return "Domain Removed";
     default:
-      return eventType;
+      return eventType.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
   }
 }
 
@@ -233,7 +234,25 @@ export function formatEventForEmail(event: DigestEvent): string {
       return `${event.resourceName}: now out of stock (was ${event.beforeValue} units) (${time})`;
     case "theme_publish":
       return `"${event.resourceName}" is now your live theme (${time})`;
+    case "collection_created":
+      return `Collection "${event.resourceName}" was created (${time})`;
+    case "collection_updated":
+      return `Collection "${event.resourceName}" was updated (${time})`;
+    case "collection_deleted":
+      return `Collection "${event.resourceName}" was deleted (${time})`;
+    case "discount_created":
+      return `Discount "${event.resourceName}" was created (${time})`;
+    case "discount_changed":
+      return `Discount "${event.resourceName}" was modified: ${event.beforeValue ?? ""} → ${event.afterValue ?? ""} (${time})`;
+    case "discount_deleted":
+      return `Discount "${event.resourceName}" was deleted (${time})`;
+    case "app_permissions_changed":
+      return `App permissions changed: ${event.resourceName} (${time})`;
+    case "domain_changed":
+      return `Domain "${event.resourceName}" was added or changed (${time})`;
+    case "domain_removed":
+      return `Domain "${event.resourceName}" was removed (${time})`;
     default:
-      return `${event.resourceName}: ${event.beforeValue} → ${event.afterValue} (${time})`;
+      return `${event.resourceName}: ${event.beforeValue ?? ""} → ${event.afterValue ?? ""} (${time})`;
   }
 }
diff --git a/insightops/app/services/dailyDigest.test.ts b/insightops/app/services/dailyDigest.test.ts
index 0723be2..2530eaf 100644
--- a/insightops/app/services/dailyDigest.test.ts
+++ b/insightops/app/services/dailyDigest.test.ts
@@ -105,8 +105,29 @@ describe("formatEventType", () => {
     expect(formatEventType("theme_publish")).toBe("Theme Published");
   });
 
-  it("should return raw event type for unknown types", () => {
-    expect(formatEventType("unknown_event")).toBe("unknown_event");
+  it("should format collection event types", () => {
+    expect(formatEventType("collection_created")).toBe("Collection Created");
+    expect(formatEventType("collection_updated")).toBe("Collection Updated");
+    expect(formatEventType("collection_deleted")).toBe("Collection Deleted");
+  });
+
+  it("should format discount event types", () => {
+    expect(formatEventType("discount_created")).toBe("Discount Created");
+    expect(formatEventType("discount_changed")).toBe("Discount Changed");
+    expect(formatEventType("discount_deleted")).toBe("Discount Deleted");
+  });
+
+  it("should format app permissions event type", () => {
+    expect(formatEventType("app_permissions_changed")).toBe("App Permissions Changed");
+  });
+
+  it("should format domain event types", () => {
+    expect(formatEventType("domain_changed")).toBe("Domain Changed");
+    expect(formatEventType("domain_removed")).toBe("Domain Removed");
+  });
+
+  it("should title-case unknown event types", () => {
+    expect(formatEventType("unknown_event")).toBe("Unknown Event");
   });
 });
 
@@ -182,4 +203,67 @@ describe("formatEventForEmail", () => {
     expect(result).toContain("Dawn 2.0");
     expect(result).toContain("live theme");
   });
+
+  it("should format collection created event", () => {
+    const event = makeEvent({
+      eventType: "collection_created",
+      entityType: "collection",
+      resourceName: "Summer Sale",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("Summer Sale");
+    expect(result).toContain("created");
+  });
+
+  it("should format collection deleted event", () => {
+    const event = makeEvent({
+      eventType: "collection_deleted",
+      entityType: "collection",
+      resourceName: "Old Collection",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("Old Collection");
+    expect(result).toContain("deleted");
+  });
+
+  it("should format discount created event", () => {
+    const event = makeEvent({
+      eventType: "discount_created",
+      entityType: "discount",
+      resourceName: "SUMMER50",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("SUMMER50");
+    expect(result).toContain("created");
+  });
+
+  it("should format discount changed event", () => {
+    const event = makeEvent({
+      eventType: "discount_changed",
+      entityType: "discount",
+      resourceName: "BLACKFRIDAY",
+      beforeValue: "20%",
+      afterValue: "50%",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("BLACKFRIDAY");
+    expect(result).toContain("20%");
+    expect(result).toContain("50%");
+  });
+
+  it("should format discount deleted event", () => {
+    const event = makeEvent({
+      eventType: "discount_deleted",
+      entityType: "discount",
+      resourceName: "EXPIRED10",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("EXPIRED10");
+    expect(result).toContain("deleted");
+  });
 });
diff --git a/insightops/app/services/emailService.server.ts b/insightops/app/services/emailService.server.ts
index 5366b10..b5af624 100644
--- a/insightops/app/services/emailService.server.ts
+++ b/insightops/app/services/emailService.server.ts
@@ -1,17 +1,22 @@
 /**
  * Email Service for StoreGuard
  *
- * Sends emails via Resend API.
+ * Sends emails via Resend API. Template generation is in emailTemplates.server.ts.
  * Environment variables required:
  * - RESEND_API_KEY: Your Resend API key
  * - DIGEST_FROM_EMAIL: Sender email (e.g., alerts@storeguard.app)
  */
 
+import type { DigestSummary } from "./dailyDigest.server";
 import {
-  type DigestSummary,
-  formatEventType,
-  formatEventForEmail,
-} from "./dailyDigest.server";
+  generateDigestEmailHtml,
+  generateInstantAlertHtml,
+  getInstantAlertSubject,
+  type InstantAlertEvent,
+} from "./emailTemplates.server";
+
+// Re-export template functions for consumers that import from here
+export { generateDigestEmailHtml, generateInstantAlertHtml, type InstantAlertEvent };
 
 const RESEND_API_KEY = process.env.RESEND_API_KEY;
 const FROM_EMAIL = process.env.DIGEST_FROM_EMAIL || "StoreGuard <alerts@storeguard.app>";
@@ -67,382 +72,18 @@ async function sendEmail(
   }
 }
 
-/**
- * Generate HTML email for daily digest
- */
-export function generateDigestEmailHtml(digest: DigestSummary): string {
-  const shopName = digest.shop.replace(".myshopify.com", "");
-  const dateStr = digest.generatedAt.toLocaleDateString("en-US", {
-    weekday: "long",
-    year: "numeric",
-    month: "long",
-    day: "numeric",
-  });
-
-  // Build sections for each event type
-  const sections: string[] = [];
-
-  // Price changes
-  if (digest.eventsByType.price_change.length > 0) {
-    sections.push(buildEventSection(
-      "💰 Price Changes",
-      digest.eventsByType.price_change,
-      "#f59e0b" // amber
-    ));
-  }
-
-  // Visibility changes
-  if (digest.eventsByType.visibility_change.length > 0) {
-    sections.push(buildEventSection(
-      "👁️ Visibility Changes",
-      digest.eventsByType.visibility_change,
-      "#8b5cf6" // purple
-    ));
-  }
-
-  // Low stock
-  if (digest.eventsByType.inventory_low && digest.eventsByType.inventory_low.length > 0) {
-    sections.push(buildEventSection(
-      "⚠️ Low Stock",
-      digest.eventsByType.inventory_low,
-      "#f97316" // orange
-    ));
-  }
-
-  // Out of stock
-  if (digest.eventsByType.inventory_zero.length > 0) {
-    sections.push(buildEventSection(
-      "📦 Out of Stock",
-      digest.eventsByType.inventory_zero,
-      "#ef4444" // red
-    ));
-  }
-
-  // Theme publishes
-  if (digest.eventsByType.theme_publish.length > 0) {
-    sections.push(buildEventSection(
-      "🎨 Theme Published",
-      digest.eventsByType.theme_publish,
-      "#06b6d4" // cyan
-    ));
-  }
-
-  const sectionsHtml = sections.join("");
-
-  // Summary stats
-  const highPriorityBadge = digest.highPriorityCount > 0
-    ? `<span style="background: #fef2f2; color: #dc2626; padding: 4px 12px; border-radius: 12px; font-size: 13px; font-weight: 600;">${digest.highPriorityCount} High Priority</span>`
-    : "";
-
-  return `
-<!DOCTYPE html>
-<html>
-<head>
-  <meta charset="utf-8">
-  <meta name="viewport" content="width=device-width, initial-scale=1.0">
-  <title>StoreGuard Daily Digest</title>
-</head>
-<body style="margin: 0; padding: 0; background: #f3f4f6; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
-  <div style="max-width: 600px; margin: 0 auto; padding: 24px;">
-    <!-- Header -->
-    <div style="background: #000; color: #fff; padding: 24px; border-radius: 12px 12px 0 0; text-align: center;">
-      <h1 style="margin: 0; font-size: 24px; font-weight: 600;">🛡️ StoreGuard</h1>
-      <p style="margin: 8px 0 0; opacity: 0.8; font-size: 14px;">Daily Digest for ${shopName}</p>
-    </div>
-
-    <!-- Summary -->
-    <div style="background: #fff; padding: 24px; border-bottom: 1px solid #e5e7eb;">
-      <p style="margin: 0 0 12px; color: #6b7280; font-size: 14px;">${dateStr}</p>
-      <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
-        <span style="background: #f3f4f6; color: #374151; padding: 8px 16px; border-radius: 8px; font-size: 16px; font-weight: 600;">
-          ${digest.totalChanges} Change${digest.totalChanges !== 1 ? "s" : ""} Detected
-        </span>
-        ${highPriorityBadge}
-      </div>
-    </div>
-
-    <!-- Event Sections -->
-    <div style="background: #fff;">
-      ${sectionsHtml}
-    </div>
-
-    <!-- Footer -->
-    <div style="background: #fff; padding: 24px; border-radius: 0 0 12px 12px; border-top: 1px solid #e5e7eb; text-align: center;">
-      <p style="margin: 0 0 8px; color: #6b7280; font-size: 13px;">
-        You're receiving this because you enabled daily digests in StoreGuard.
-      </p>
-      <p style="margin: 0; color: #9ca3af; font-size: 12px;">
-        <a href="https://${digest.shop}/admin/apps/storeguard/settings" style="color: #6b7280;">Manage notification settings</a>
-      </p>
-    </div>
-  </div>
-</body>
-</html>
-`.trim();
-}
-
-/**
- * Build HTML section for a group of events
- */
-function buildEventSection(
-  title: string,
-  events: DigestSummary["eventsByType"]["price_change"],
-  accentColor: string
-): string {
-  const eventItems = events
-    .map((event) => {
-      const importanceDot = event.importance === "high"
-        ? `<span style="display: inline-block; width: 8px; height: 8px; background: #ef4444; border-radius: 50%; margin-right: 8px;"></span>`
-        : "";
-
-      return `
-        <div style="padding: 12px 0; border-bottom: 1px solid #f3f4f6;">
-          ${importanceDot}<strong style="color: #111827;">${event.resourceName}</strong>
-          <div style="margin-top: 4px; color: #6b7280; font-size: 13px;">
-            ${formatChangeDescription(event)}
-          </div>
-        </div>
-      `;
-    })
-    .join("");
-
-  return `
-    <div style="padding: 0 24px;">
-      <div style="padding: 16px 0; border-bottom: 2px solid ${accentColor};">
-        <h2 style="margin: 0; font-size: 16px; font-weight: 600; color: #111827;">${title}</h2>
-        <p style="margin: 4px 0 0; font-size: 13px; color: #6b7280;">${events.length} change${events.length !== 1 ? "s" : ""}</p>
-      </div>
-      ${eventItems}
-    </div>
-  `;
-}
-
-/**
- * Format change description for email
- */
-function formatChangeDescription(event: DigestSummary["eventsByType"]["price_change"][0]): string {
-  const time = event.detectedAt.toLocaleTimeString("en-US", {
-    hour: "numeric",
-    minute: "2-digit",
-    hour12: true,
-  });
-
-  // Parse context data for sales velocity
-  let velocitySuffix = "";
-  if (event.contextData) {
-    try {
-      const ctx = JSON.parse(event.contextData) as {
-        velocityContext?: string | null;
-      };
-      if (ctx.velocityContext) {
-        velocitySuffix = ` — ${ctx.velocityContext}`;
-      }
-    } catch {
-      // Ignore invalid context
-    }
-  }
-
-  switch (event.eventType) {
-    case "price_change":
-      return `${event.beforeValue} → ${event.afterValue}${velocitySuffix} • ${time}`;
-    case "visibility_change":
-      return `${event.beforeValue} → ${event.afterValue}${velocitySuffix} • ${time}`;
-    case "inventory_low":
-      return `Stock dropped to ${event.afterValue} units (was ${event.beforeValue})${velocitySuffix} • ${time}`;
-    case "inventory_zero":
-      return `Now out of stock (was ${event.beforeValue} units)${velocitySuffix} • ${time}`;
-    case "theme_publish":
-      return `Now your live theme • ${time}`;
-    default:
-      return `${event.beforeValue} → ${event.afterValue}${velocitySuffix} • ${time}`;
-  }
-}
-
 /**
  * Send daily digest email for a shop
  */
 export async function sendDigestEmail(digest: DigestSummary): Promise<SendEmailResult> {
   const shopName = digest.shop.replace(".myshopify.com", "");
-  const subject = `🛡️ StoreGuard: ${digest.totalChanges} change${digest.totalChanges !== 1 ? "s" : ""} detected on ${shopName}`;
+  const subject = `StoreGuard: ${digest.totalChanges} change${digest.totalChanges !== 1 ? "s" : ""} detected on ${shopName}`;
 
   const html = generateDigestEmailHtml(digest);
 
   return sendEmail(digest.alertEmail, subject, html);
 }
 
-// ============================================
-// INSTANT ALERTS
-// ============================================
-
-interface InstantAlertEvent {
-  eventType: string;
-  resourceName: string;
-  beforeValue: string | null;
-  afterValue: string | null;
-  importance: string;
-  detectedAt: Date;
-  contextData?: string | null;
-}
-
-/**
- * Get subject line for instant alert based on event type
- */
-function getInstantAlertSubject(event: InstantAlertEvent, shopName: string): string {
-  switch (event.eventType) {
-    case "price_change":
-      return `⚡ Price changed: ${event.resourceName} - ${shopName}`;
-    case "visibility_change":
-      return `⚡ Product ${event.afterValue === "active" ? "published" : "hidden"}: ${event.resourceName} - ${shopName}`;
-    case "inventory_low":
-      return `⚠️ Low stock: ${event.resourceName} (${event.afterValue} left) - ${shopName}`;
-    case "inventory_zero":
-      return `🚨 Out of stock: ${event.resourceName} - ${shopName}`;
-    case "theme_publish":
-      return `🎨 Theme published: ${event.resourceName} - ${shopName}`;
-    default:
-      return `⚡ Change detected: ${event.resourceName} - ${shopName}`;
-  }
-}
-
-/**
- * Get alert icon based on event type
- */
-function getAlertIcon(eventType: string): string {
-  switch (eventType) {
-    case "price_change": return "💰";
-    case "visibility_change": return "👁️";
-    case "inventory_low": return "⚠️";
-    case "inventory_zero": return "🚨";
-    case "theme_publish": return "🎨";
-    default: return "⚡";
-  }
-}
-
-/**
- * Get alert color based on event type
- */
-function getAlertColor(eventType: string): string {
-  switch (eventType) {
-    case "price_change": return "#f59e0b";
-    case "visibility_change": return "#8b5cf6";
-    case "inventory_low": return "#f97316";
-    case "inventory_zero": return "#ef4444";
-    case "theme_publish": return "#06b6d4";
-    default: return "#6b7280";
-  }
-}
-
-/**
- * Generate HTML for instant alert email
- */
-function generateInstantAlertHtml(
-  event: InstantAlertEvent,
-  shop: string
-): string {
-  const shopName = shop.replace(".myshopify.com", "");
-  const icon = getAlertIcon(event.eventType);
-  const color = getAlertColor(event.eventType);
-  const time = event.detectedAt.toLocaleString("en-US", {
-    weekday: "short",
-    month: "short",
-    day: "numeric",
-    hour: "numeric",
-    minute: "2-digit",
-    hour12: true,
-  });
-
-  // Parse context data for sales velocity
-  let velocityContext: string | null = null;
-  let revenueImpact: number | null = null;
-  if (event.contextData) {
-    try {
-      const ctx = JSON.parse(event.contextData) as {
-        velocityContext?: string | null;
-        revenueImpact?: number | null;
-      };
-      velocityContext = ctx.velocityContext ?? null;
-      revenueImpact = ctx.revenueImpact ?? null;
-    } catch {
-      // Invalid context data
-    }
-  }
-
-  // Build change description
-  let changeDescription = "";
-  switch (event.eventType) {
-    case "price_change":
-      changeDescription = `Price changed from ${event.beforeValue} to ${event.afterValue}`;
-      break;
-    case "visibility_change":
-      changeDescription = `Status changed from ${event.beforeValue} to ${event.afterValue}`;
-      break;
-    case "inventory_low":
-      changeDescription = `Stock dropped to ${event.afterValue} units (was ${event.beforeValue})`;
-      break;
-    case "inventory_zero":
-      changeDescription = `Now out of stock (was ${event.beforeValue} units)`;
-      break;
-    case "theme_publish":
-      changeDescription = `"${event.resourceName}" is now your live theme`;
-      break;
-    default:
-      changeDescription = `${event.beforeValue || ""} → ${event.afterValue || ""}`;
-  }
-
-  // Append sales velocity context
-  if (velocityContext) {
-    changeDescription += ` — ${velocityContext}`;
-  }
-
-  return `
-<!DOCTYPE html>
-<html>
-<head>
-  <meta charset="utf-8">
-  <meta name="viewport" content="width=device-width, initial-scale=1.0">
-  <title>StoreGuard Alert</title>
-</head>
-<body style="margin: 0; padding: 0; background: #f3f4f6; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
-  <div style="max-width: 500px; margin: 0 auto; padding: 24px;">
-    <!-- Header -->
-    <div style="background: ${color}; color: #fff; padding: 20px; border-radius: 12px 12px 0 0; text-align: center;">
-      <div style="font-size: 32px; margin-bottom: 8px;">${icon}</div>
-      <h1 style="margin: 0; font-size: 18px; font-weight: 600;">Instant Alert</h1>
-      <p style="margin: 4px 0 0; opacity: 0.9; font-size: 13px;">${shopName}</p>
-    </div>
-
-    <!-- Content -->
-    <div style="background: #fff; padding: 24px; border-radius: 0 0 12px 12px;">
-      <h2 style="margin: 0 0 8px; font-size: 18px; font-weight: 600; color: #111827;">
-        ${event.resourceName}
-      </h2>
-      <p style="margin: 0 0 16px; color: #374151; font-size: 15px;">
-        ${changeDescription}
-      </p>
-      ${revenueImpact !== null ? `<p style="margin: 0 0 16px; color: #dc2626; font-size: 14px; font-weight: 500;">Estimated impact: ~$${revenueImpact.toFixed(2)}/hr until fixed</p>` : ""}
-      <p style="margin: 0; color: #9ca3af; font-size: 13px;">
-        Detected at ${time}
-      </p>
-
-      <!-- Action -->
-      <div style="margin-top: 24px; padding-top: 16px; border-top: 1px solid #e5e7eb;">
-        <a href="https://${shop}/admin"
-           style="display: inline-block; background: #000; color: #fff; padding: 10px 20px; border-radius: 6px; text-decoration: none; font-size: 14px; font-weight: 500;">
-          View in Shopify Admin
-        </a>
-      </div>
-    </div>
-
-    <!-- Footer -->
-    <p style="margin: 16px 0 0; text-align: center; color: #9ca3af; font-size: 12px;">
-      <a href="https://${shop}/admin/apps/storeguard/settings" style="color: #6b7280;">Manage instant alerts</a>
-    </p>
-  </div>
-</body>
-</html>
-`.trim();
-}
-
 /**
  * Send instant alert email for a single change event
  */
diff --git a/insightops/app/services/emailTemplates.server.ts b/insightops/app/services/emailTemplates.server.ts
new file mode 100644
index 0000000..c07da22
--- /dev/null
+++ b/insightops/app/services/emailTemplates.server.ts
@@ -0,0 +1,475 @@
+/**
+ * Email Templates for StoreGuard
+ *
+ * Responsive HTML email templates compatible with Gmail, Apple Mail, and Outlook.
+ * - Table-based layout (Outlook uses Word renderer, no CSS flex/grid)
+ * - All CSS inline (Gmail strips <style> blocks)
+ * - 320px minimum width, single column
+ * - 14px body font, proper line-heights
+ * - StoreGuard branding with shield icon
+ */
+
+import type { DigestSummary, DigestEvent } from "./dailyDigest.server";
+
+// ============================================
+// SHARED CONSTANTS
+// ============================================
+
+const BRAND_COLOR = "#111827";
+const BODY_BG = "#f3f4f6";
+const CARD_BG = "#ffffff";
+const TEXT_PRIMARY = "#111827";
+const TEXT_SECONDARY = "#6b7280";
+const TEXT_MUTED = "#9ca3af";
+const BORDER_COLOR = "#e5e7eb";
+const BORDER_LIGHT = "#f3f4f6";
+const HIGH_PRIORITY_BG = "#fef2f2";
+const HIGH_PRIORITY_TEXT = "#dc2626";
+const FONT_STACK = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif";
+
+/** Shield icon as a simple HTML entity + text (renders consistently across all email clients) */
+const SHIELD_ICON = "&#x1F6E1;&#xFE0F;";
+
+/** Event type display config: title, color, display order */
+export const EVENT_TYPE_CONFIG: Record<string, { title: string; color: string; order: number }> = {
+  price_change: { title: "Price Changes", color: "#f59e0b", order: 1 },
+  visibility_change: { title: "Visibility Changes", color: "#8b5cf6", order: 2 },
+  inventory_low: { title: "Low Stock", color: "#f97316", order: 3 },
+  inventory_zero: { title: "Out of Stock", color: "#ef4444", order: 4 },
+  theme_publish: { title: "Theme Published", color: "#06b6d4", order: 5 },
+  collection_created: { title: "Collection Created", color: "#10b981", order: 6 },
+  collection_updated: { title: "Collection Updated", color: "#10b981", order: 7 },
+  collection_deleted: { title: "Collection Deleted", color: "#ef4444", order: 8 },
+  discount_created: { title: "Discount Created", color: "#8b5cf6", order: 9 },
+  discount_changed: { title: "Discount Changed", color: "#8b5cf6", order: 10 },
+  discount_deleted: { title: "Discount Deleted", color: "#ef4444", order: 11 },
+  app_permissions_changed: { title: "App Permissions Changed", color: "#6366f1", order: 12 },
+  domain_changed: { title: "Domain Changed", color: "#0891b2", order: 13 },
+  domain_removed: { title: "Domain Removed", color: "#ef4444", order: 14 },
+};
+
+// ============================================
+// SHARED HELPERS
+// ============================================
+
+/** Wrap content in the standard email document shell */
+function emailShell(title: string, body: string): string {
+  return `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
+<head>
+  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
+  <title>${title}</title>
+  <!--[if mso]>
+  <style type="text/css">
+    table { border-collapse: collapse; }
+    .button-link { padding: 12px 24px !important; }
+  </style>
+  <![endif]-->
+</head>
+<body style="margin: 0; padding: 0; background-color: ${BODY_BG}; font-family: ${FONT_STACK}; font-size: 14px; line-height: 1.5; color: ${TEXT_PRIMARY}; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%;">
+  <!-- Outer wrapper table for full-width background -->
+  <table role="presentation" cellpadding="0" cellspacing="0" border="0" width="100%" style="background-color: ${BODY_BG};">
+    <tr>
+      <td align="center" style="padding: 24px 16px;">
+        <!-- Inner content table with max-width -->
+        <!--[if mso]><table role="presentation" cellpadding="0" cellspacing="0" border="0" width="600"><tr><td><![endif]-->
+        <table role="presentation" cellpadding="0" cellspacing="0" border="0" width="100%" style="max-width: 600px; min-width: 320px;">
+          ${body}
+        </table>
+        <!--[if mso]></td></tr></table><![endif]-->
+      </td>
+    </tr>
+  </table>
+</body>
+</html>`;
+}
+
+/** Parse contextData JSON safely */
+function parseContextData(contextData: string | null | undefined): {
+  velocityContext: string | null;
+  locationContext: string | null;
+  revenueImpact: number | null;
+} {
+  if (!contextData) return { velocityContext: null, locationContext: null, revenueImpact: null };
+  try {
+    const ctx = JSON.parse(contextData) as {
+      velocityContext?: string | null;
+      locationContext?: string | null;
+      revenueImpact?: number | null;
+    };
+    return {
+      velocityContext: ctx.velocityContext ?? null,
+      locationContext: ctx.locationContext ?? null,
+      revenueImpact: ctx.revenueImpact ?? null,
+    };
+  } catch {
+    return { velocityContext: null, locationContext: null, revenueImpact: null };
+  }
+}
+
+/** Get the accent color for an event type */
+export function getAlertColor(eventType: string): string {
+  return EVENT_TYPE_CONFIG[eventType]?.color ?? "#6b7280";
+}
+
+// ============================================
+// DAILY DIGEST EMAIL
+// ============================================
+
+/** Format a change description for digest email rows */
+export function formatDigestChangeDescription(event: DigestEvent): string {
+  const time = event.detectedAt.toLocaleTimeString("en-US", {
+    hour: "numeric",
+    minute: "2-digit",
+    hour12: true,
+  });
+
+  const { velocityContext, locationContext } = parseContextData(event.contextData);
+  let suffix = "";
+  if (locationContext) suffix += ` &mdash; ${locationContext}`;
+  if (velocityContext) suffix += ` &mdash; ${velocityContext}`;
+
+  switch (event.eventType) {
+    case "price_change":
+      return `${event.beforeValue} &rarr; ${event.afterValue}${suffix} &bull; ${time}`;
+    case "visibility_change":
+      return `${event.beforeValue} &rarr; ${event.afterValue}${suffix} &bull; ${time}`;
+    case "inventory_low":
+      return `Stock dropped to ${event.afterValue} units (was ${event.beforeValue})${suffix} &bull; ${time}`;
+    case "inventory_zero":
+      return `Now out of stock (was ${event.beforeValue} units)${suffix} &bull; ${time}`;
+    case "theme_publish":
+      return `Now your live theme &bull; ${time}`;
+    case "collection_created":
+      return `New collection created &bull; ${time}`;
+    case "collection_updated":
+      return `Collection updated &bull; ${time}`;
+    case "collection_deleted":
+      return `Collection deleted &bull; ${time}`;
+    case "discount_created":
+      return `Discount created &bull; ${time}`;
+    case "discount_changed":
+      return `${event.beforeValue ?? ""} &rarr; ${event.afterValue ?? ""} &bull; ${time}`;
+    case "discount_deleted":
+      return `Discount deleted &bull; ${time}`;
+    case "app_permissions_changed":
+      return `Permissions changed &bull; ${time}`;
+    case "domain_changed":
+      return `Domain added or changed &bull; ${time}`;
+    case "domain_removed":
+      return `Domain removed &bull; ${time}`;
+    default:
+      return `${event.beforeValue ?? ""} &rarr; ${event.afterValue ?? ""}${suffix} &bull; ${time}`;
+  }
+}
+
+/** Build a single event row for the digest */
+function buildEventRow(event: DigestEvent): string {
+  const importanceDot = event.importance === "high"
+    ? `<td width="12" valign="top" style="padding-top: 4px;"><table role="presentation" cellpadding="0" cellspacing="0" border="0"><tr><td width="8" height="8" style="width: 8px; height: 8px; background-color: ${HIGH_PRIORITY_TEXT}; border-radius: 50%; font-size: 1px; line-height: 1px;">&nbsp;</td></tr></table></td>`
+    : `<td width="12" style="font-size: 1px; line-height: 1px;">&nbsp;</td>`;
+
+  return `<tr>
+  <td style="padding: 12px 0; border-bottom: 1px solid ${BORDER_LIGHT};">
+    <table role="presentation" cellpadding="0" cellspacing="0" border="0" width="100%">
+      <tr>
+        ${importanceDot}
+        <td style="font-family: ${FONT_STACK};">
+          <strong style="color: ${TEXT_PRIMARY}; font-size: 14px;">${event.resourceName}</strong>
+          <div style="margin-top: 4px; color: ${TEXT_SECONDARY}; font-size: 13px; line-height: 1.4;">
+            ${formatDigestChangeDescription(event)}
+          </div>
+        </td>
+      </tr>
+    </table>
+  </td>
+</tr>`;
+}
+
+/** Build a section for a group of events (e.g., "Price Changes") */
+function buildEventSection(title: string, events: DigestEvent[], accentColor: string): string {
+  const rows = events.map(buildEventRow).join("");
+
+  return `<tr>
+  <td style="padding: 0 24px;">
+    <table role="presentation" cellpadding="0" cellspacing="0" border="0" width="100%">
+      <tr>
+        <td style="padding: 16px 0; border-bottom: 2px solid ${accentColor};">
+          <h2 style="margin: 0; font-size: 16px; font-weight: 600; color: ${TEXT_PRIMARY}; font-family: ${FONT_STACK};">${title}</h2>
+          <p style="margin: 4px 0 0; font-size: 13px; color: ${TEXT_SECONDARY}; font-family: ${FONT_STACK};">${events.length} change${events.length !== 1 ? "s" : ""}</p>
+        </td>
+      </tr>
+      ${rows}
+    </table>
+  </td>
+</tr>`;
+}
+
+/** Generate the full HTML email for a daily digest */
+export function generateDigestEmailHtml(digest: DigestSummary): string {
+  const shopName = digest.shop.replace(".myshopify.com", "");
+  const dateStr = digest.generatedAt.toLocaleDateString("en-US", {
+    weekday: "long",
+    year: "numeric",
+    month: "long",
+    day: "numeric",
+  });
+
+  // Build sections sorted by display order
+  const sortedTypes = Object.entries(digest.eventsByType)
+    .filter(([, events]) => events.length > 0)
+    .sort(([a], [b]) => {
+      const orderA = EVENT_TYPE_CONFIG[a]?.order ?? 99;
+      const orderB = EVENT_TYPE_CONFIG[b]?.order ?? 99;
+      return orderA - orderB;
+    });
+
+  const sectionRows = sortedTypes
+    .map(([eventType, events]) => {
+      const config = EVENT_TYPE_CONFIG[eventType] ?? {
+        title: eventType.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase()),
+        color: "#6b7280",
+      };
+      return buildEventSection(config.title, events, config.color);
+    })
+    .join("");
+
+  const highPriorityCell = digest.highPriorityCount > 0
+    ? `<td style="padding-left: 8px;">
+        <table role="presentation" cellpadding="0" cellspacing="0" border="0">
+          <tr>
+            <td style="background-color: ${HIGH_PRIORITY_BG}; color: ${HIGH_PRIORITY_TEXT}; padding: 4px 12px; border-radius: 12px; font-size: 13px; font-weight: 600; font-family: ${FONT_STACK};">${digest.highPriorityCount} High Priority</td>
+          </tr>
+        </table>
+      </td>`
+    : "";
+
+  const body = `
+<!-- Header -->
+<tr>
+  <td align="center" bgcolor="${BRAND_COLOR}" style="background-color: ${BRAND_COLOR}; padding: 28px 24px; border-radius: 8px 8px 0 0;">
+    <h1 style="margin: 0; font-size: 22px; font-weight: 700; color: #ffffff; font-family: ${FONT_STACK};">${SHIELD_ICON} StoreGuard</h1>
+    <p style="margin: 8px 0 0; font-size: 14px; color: #a1a1aa; font-family: ${FONT_STACK};">Daily Digest for ${shopName}</p>
+  </td>
+</tr>
+<!-- Summary -->
+<tr>
+  <td bgcolor="${CARD_BG}" style="background-color: ${CARD_BG}; padding: 24px; border-bottom: 1px solid ${BORDER_COLOR};">
+    <p style="margin: 0 0 12px; color: ${TEXT_SECONDARY}; font-size: 14px; font-family: ${FONT_STACK};">${dateStr}</p>
+    <table role="presentation" cellpadding="0" cellspacing="0" border="0">
+      <tr>
+        <td style="background-color: ${BORDER_LIGHT}; color: #374151; padding: 8px 16px; border-radius: 8px; font-size: 16px; font-weight: 600; font-family: ${FONT_STACK};">
+          ${digest.totalChanges} Change${digest.totalChanges !== 1 ? "s" : ""} Detected
+        </td>
+        ${highPriorityCell}
+      </tr>
+    </table>
+  </td>
+</tr>
+<!-- Event Sections -->
+<tr>
+  <td bgcolor="${CARD_BG}" style="background-color: ${CARD_BG};">
+    <table role="presentation" cellpadding="0" cellspacing="0" border="0" width="100%">
+      ${sectionRows}
+    </table>
+  </td>
+</tr>
+<!-- Footer -->
+<tr>
+  <td bgcolor="${CARD_BG}" style="background-color: ${CARD_BG}; padding: 24px; border-radius: 0 0 8px 8px; border-top: 1px solid ${BORDER_COLOR}; text-align: center;">
+    <p style="margin: 0 0 8px; color: ${TEXT_SECONDARY}; font-size: 13px; font-family: ${FONT_STACK};">
+      You're receiving this because you enabled daily digests in StoreGuard.
+    </p>
+    <p style="margin: 0; font-size: 12px; font-family: ${FONT_STACK};">
+      <a href="https://${digest.shop}/admin/apps/storeguard/settings" style="color: ${TEXT_SECONDARY}; text-decoration: underline;">Manage notification settings</a>
+    </p>
+  </td>
+</tr>`;
+
+  return emailShell("StoreGuard Daily Digest", body);
+}
+
+// ============================================
+// INSTANT ALERT EMAIL
+// ============================================
+
+export interface InstantAlertEvent {
+  eventType: string;
+  resourceName: string;
+  beforeValue: string | null;
+  afterValue: string | null;
+  importance: string;
+  detectedAt: Date;
+  contextData?: string | null;
+}
+
+/** Get subject line for instant alert */
+export function getInstantAlertSubject(event: InstantAlertEvent, shopName: string): string {
+  switch (event.eventType) {
+    case "price_change":
+      return `Price changed: ${event.resourceName} - ${shopName}`;
+    case "visibility_change":
+      return `Product ${event.afterValue === "active" ? "published" : "hidden"}: ${event.resourceName} - ${shopName}`;
+    case "inventory_low":
+      return `Low stock: ${event.resourceName} (${event.afterValue} left) - ${shopName}`;
+    case "inventory_zero":
+      return `Out of stock: ${event.resourceName} - ${shopName}`;
+    case "theme_publish":
+      return `Theme published: ${event.resourceName} - ${shopName}`;
+    case "collection_created":
+      return `Collection created: ${event.resourceName} - ${shopName}`;
+    case "collection_updated":
+      return `Collection updated: ${event.resourceName} - ${shopName}`;
+    case "collection_deleted":
+      return `Collection deleted: ${event.resourceName} - ${shopName}`;
+    case "discount_created":
+      return `Discount created: ${event.resourceName} - ${shopName}`;
+    case "discount_changed":
+      return `Discount changed: ${event.resourceName} - ${shopName}`;
+    case "discount_deleted":
+      return `Discount deleted: ${event.resourceName} - ${shopName}`;
+    case "app_permissions_changed":
+      return `App permissions changed: ${event.resourceName} - ${shopName}`;
+    case "domain_changed":
+      return `Domain changed: ${event.resourceName} - ${shopName}`;
+    case "domain_removed":
+      return `Domain removed: ${event.resourceName} - ${shopName}`;
+    default:
+      return `Change detected: ${event.resourceName} - ${shopName}`;
+  }
+}
+
+/** Build the change description for an instant alert */
+export function buildInstantAlertDescription(event: InstantAlertEvent): string {
+  const { velocityContext, locationContext } = parseContextData(event.contextData);
+
+  let description = "";
+  switch (event.eventType) {
+    case "price_change":
+      description = `Price changed from ${event.beforeValue} to ${event.afterValue}`;
+      break;
+    case "visibility_change":
+      description = `Status changed from ${event.beforeValue} to ${event.afterValue}`;
+      break;
+    case "inventory_low":
+      description = `Stock dropped to ${event.afterValue} units total (was ${event.beforeValue})`;
+      break;
+    case "inventory_zero":
+      description = `Now out of stock across all locations (was ${event.beforeValue} units)`;
+      break;
+    case "theme_publish":
+      description = `&quot;${event.resourceName}&quot; is now your live theme`;
+      break;
+    case "collection_created":
+      description = `Collection &quot;${event.resourceName}&quot; was created`;
+      break;
+    case "collection_updated":
+      description = `Collection &quot;${event.resourceName}&quot; was updated`;
+      break;
+    case "collection_deleted":
+      description = `Collection &quot;${event.resourceName}&quot; was deleted`;
+      break;
+    case "discount_created":
+      description = `Discount &quot;${event.resourceName}&quot; was created`;
+      break;
+    case "discount_changed":
+      description = `Discount &quot;${event.resourceName}&quot; was modified: ${event.beforeValue || ""} &rarr; ${event.afterValue || ""}`;
+      break;
+    case "discount_deleted":
+      description = `Discount &quot;${event.resourceName}&quot; was deleted`;
+      break;
+    case "app_permissions_changed":
+      description = `App permissions were changed: ${event.resourceName}`;
+      break;
+    case "domain_changed":
+      description = `Domain &quot;${event.resourceName}&quot; was added or changed`;
+      break;
+    case "domain_removed":
+      description = `Domain &quot;${event.resourceName}&quot; was removed`;
+      break;
+    default:
+      description = `${event.beforeValue || ""} &rarr; ${event.afterValue || ""}`;
+  }
+
+  if (locationContext) description += ` &mdash; ${locationContext}`;
+  if (velocityContext) description += ` &mdash; ${velocityContext}`;
+
+  return description;
+}
+
+/** Generate the full HTML for an instant alert email */
+export function generateInstantAlertHtml(event: InstantAlertEvent, shop: string): string {
+  const shopName = shop.replace(".myshopify.com", "");
+  const color = getAlertColor(event.eventType);
+  const time = event.detectedAt.toLocaleString("en-US", {
+    weekday: "short",
+    month: "short",
+    day: "numeric",
+    hour: "numeric",
+    minute: "2-digit",
+    hour12: true,
+  });
+
+  const { revenueImpact } = parseContextData(event.contextData);
+  const changeDescription = buildInstantAlertDescription(event);
+
+  const impactRow = revenueImpact !== null
+    ? `<tr><td style="padding: 0 0 16px; color: ${HIGH_PRIORITY_TEXT}; font-size: 14px; font-weight: 500; font-family: ${FONT_STACK};">Estimated impact: ~$${revenueImpact.toFixed(2)}/hr until fixed</td></tr>`
+    : "";
+
+  const body = `
+<!-- Header -->
+<tr>
+  <td align="center" bgcolor="${color}" style="background-color: ${color}; padding: 24px; border-radius: 8px 8px 0 0;">
+    <h1 style="margin: 0; font-size: 18px; font-weight: 700; color: #ffffff; font-family: ${FONT_STACK};">${SHIELD_ICON} Instant Alert</h1>
+    <p style="margin: 6px 0 0; font-size: 13px; color: #ffffff; font-family: ${FONT_STACK};">${shopName}</p>
+  </td>
+</tr>
+<!-- Content -->
+<tr>
+  <td bgcolor="${CARD_BG}" style="background-color: ${CARD_BG}; padding: 24px;">
+    <table role="presentation" cellpadding="0" cellspacing="0" border="0" width="100%">
+      <tr>
+        <td style="padding: 0 0 8px;">
+          <h2 style="margin: 0; font-size: 18px; font-weight: 600; color: ${TEXT_PRIMARY}; font-family: ${FONT_STACK};">${event.resourceName}</h2>
+        </td>
+      </tr>
+      <tr>
+        <td style="padding: 0 0 16px; color: #374151; font-size: 14px; line-height: 1.5; font-family: ${FONT_STACK};">
+          ${changeDescription}
+        </td>
+      </tr>
+      ${impactRow}
+      <tr>
+        <td style="padding: 0; color: ${TEXT_MUTED}; font-size: 13px; font-family: ${FONT_STACK};">
+          Detected at ${time}
+        </td>
+      </tr>
+      <tr>
+        <td style="padding: 24px 0 0; border-top: 1px solid ${BORDER_COLOR}; padding-top: 16px; margin-top: 24px;">
+          <!--[if mso]>
+          <v:roundrect xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w="urn:schemas-microsoft-com:office:word" href="https://${shop}/admin" style="height:44px;v-text-anchor:middle;width:200px;" arcsize="14%" stroke="f" fillcolor="${BRAND_COLOR}">
+            <w:anchorlock/>
+            <center style="color:#ffffff;font-family:${FONT_STACK};font-size:14px;font-weight:bold;">View in Shopify Admin</center>
+          </v:roundrect>
+          <![endif]-->
+          <!--[if !mso]><!-->
+          <a href="https://${shop}/admin" style="display: inline-block; background-color: ${BRAND_COLOR}; color: #ffffff; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-size: 14px; font-weight: 600; font-family: ${FONT_STACK}; line-height: 1; mso-hide: all;">View in Shopify Admin</a>
+          <!--<![endif]-->
+        </td>
+      </tr>
+    </table>
+  </td>
+</tr>
+<!-- Footer -->
+<tr>
+  <td bgcolor="${CARD_BG}" style="background-color: ${CARD_BG}; padding: 16px 24px 24px; border-radius: 0 0 8px 8px; border-top: 1px solid ${BORDER_COLOR}; text-align: center;">
+    <p style="margin: 0; font-size: 12px; font-family: ${FONT_STACK};">
+      <a href="https://${shop}/admin/apps/storeguard/settings" style="color: ${TEXT_SECONDARY}; text-decoration: underline;">Manage instant alerts</a>
+    </p>
+  </td>
+</tr>`;
+
+  return emailShell("StoreGuard Alert", body);
+}
diff --git a/insightops/app/services/emailTemplates.test.ts b/insightops/app/services/emailTemplates.test.ts
new file mode 100644
index 0000000..e6a757c
--- /dev/null
+++ b/insightops/app/services/emailTemplates.test.ts
@@ -0,0 +1,560 @@
+import { describe, it, expect } from "vitest";
+import {
+  generateDigestEmailHtml,
+  generateInstantAlertHtml,
+  getInstantAlertSubject,
+  buildInstantAlertDescription,
+  formatDigestChangeDescription,
+  getAlertColor,
+  EVENT_TYPE_CONFIG,
+  type InstantAlertEvent,
+} from "./emailTemplates.server";
+import type { DigestSummary, DigestEvent } from "./dailyDigest.server";
+
+// ============================================
+// HELPERS
+// ============================================
+
+function makeDigestEvent(overrides: Partial<DigestEvent> = {}): DigestEvent {
+  return {
+    id: "evt-1",
+    entityType: "variant",
+    entityId: "gid://shopify/ProductVariant/1",
+    eventType: "price_change",
+    resourceName: "Blue Jacket / M",
+    beforeValue: "$89.00",
+    afterValue: "$8.90",
+    detectedAt: new Date("2026-02-18T14:30:00Z"),
+    importance: "high",
+    contextData: null,
+    ...overrides,
+  };
+}
+
+function makeDigest(overrides: Partial<DigestSummary> = {}): DigestSummary {
+  return {
+    shop: "test-store.myshopify.com",
+    alertEmail: "owner@test-store.com",
+    generatedAt: new Date("2026-02-18T15:00:00Z"),
+    periodStart: new Date("2026-02-17T15:00:00Z"),
+    periodEnd: new Date("2026-02-18T15:00:00Z"),
+    totalChanges: 1,
+    highPriorityCount: 0,
+    eventsByType: {
+      price_change: [makeDigestEvent()],
+    },
+    ...overrides,
+  };
+}
+
+function makeInstantEvent(overrides: Partial<InstantAlertEvent> = {}): InstantAlertEvent {
+  return {
+    eventType: "price_change",
+    resourceName: "Blue Jacket / M",
+    beforeValue: "$89.00",
+    afterValue: "$8.90",
+    importance: "high",
+    detectedAt: new Date("2026-02-18T14:30:00Z"),
+    contextData: null,
+    ...overrides,
+  };
+}
+
+// ============================================
+// DIGEST EMAIL HTML
+// ============================================
+
+describe("generateDigestEmailHtml", () => {
+  it("produces valid XHTML transitional doctype", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"');
+    expect(html).toContain('xmlns="http://www.w3.org/1999/xhtml"');
+  });
+
+  it("includes charset and viewport meta tags", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain('http-equiv="Content-Type"');
+    expect(html).toContain('content="text/html; charset=utf-8"');
+    expect(html).toContain('name="viewport"');
+    expect(html).toContain("width=device-width");
+  });
+
+  it("uses table-based layout (no flex/grid)", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).not.toContain("display: flex");
+    expect(html).not.toContain("display: grid");
+    expect(html).toContain('role="presentation"');
+  });
+
+  it("uses inline styles only (no <style> blocks outside mso conditionals)", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    // Remove MSO conditional comments before checking
+    const withoutMso = html.replace(/<!--\[if mso\]>[\s\S]*?<!\[endif\]-->/g, "");
+    expect(withoutMso).not.toMatch(/<style[\s>]/);
+  });
+
+  it("sets min-width 320px on content table", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("min-width: 320px");
+  });
+
+  it("sets max-width 600px on content table", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("max-width: 600px");
+  });
+
+  it("uses 14px base font size", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("font-size: 14px");
+  });
+
+  it("includes StoreGuard branding with shield", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("StoreGuard");
+    // Shield HTML entity
+    expect(html).toContain("&#x1F6E1;");
+  });
+
+  it("includes shop name without myshopify.com", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("test-store");
+    expect(html).not.toContain("test-store.myshopify.com</");
+  });
+
+  it("includes total changes count", () => {
+    const html = generateDigestEmailHtml(makeDigest({ totalChanges: 5 }));
+    expect(html).toContain("5 Changes Detected");
+  });
+
+  it("shows singular 'Change' for 1 event", () => {
+    const html = generateDigestEmailHtml(makeDigest({ totalChanges: 1 }));
+    expect(html).toContain("1 Change Detected");
+  });
+
+  it("shows high priority badge when highPriorityCount > 0", () => {
+    const html = generateDigestEmailHtml(makeDigest({ highPriorityCount: 3 }));
+    expect(html).toContain("3 High Priority");
+  });
+
+  it("hides high priority badge when highPriorityCount is 0", () => {
+    const html = generateDigestEmailHtml(makeDigest({ highPriorityCount: 0 }));
+    expect(html).not.toContain("High Priority");
+  });
+
+  it("renders event sections with proper titles", () => {
+    const html = generateDigestEmailHtml(makeDigest({
+      eventsByType: {
+        price_change: [makeDigestEvent()],
+        inventory_zero: [makeDigestEvent({ eventType: "inventory_zero", importance: "high" })],
+      },
+    }));
+    expect(html).toContain("Price Changes");
+    expect(html).toContain("Out of Stock");
+  });
+
+  it("renders event sections in display order", () => {
+    const html = generateDigestEmailHtml(makeDigest({
+      eventsByType: {
+        inventory_zero: [makeDigestEvent({ eventType: "inventory_zero" })],
+        price_change: [makeDigestEvent()],
+      },
+    }));
+    const priceIdx = html.indexOf("Price Changes");
+    const stockIdx = html.indexOf("Out of Stock");
+    expect(priceIdx).toBeLessThan(stockIdx);
+  });
+
+  it("renders resource names in event rows", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("Blue Jacket / M");
+  });
+
+  it("shows high-priority dot for high importance events", () => {
+    const html = generateDigestEmailHtml(makeDigest({
+      eventsByType: {
+        price_change: [makeDigestEvent({ importance: "high" })],
+      },
+    }));
+    // Red dot background
+    expect(html).toContain("background-color: #dc2626");
+  });
+
+  it("includes settings link in footer", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("test-store.myshopify.com/admin/apps/storeguard/settings");
+    expect(html).toContain("Manage notification settings");
+  });
+
+  it("includes Outlook conditional comments for fixed-width wrapper", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("<!--[if mso]>");
+    expect(html).toContain("<![endif]-->");
+  });
+
+  it("includes bgcolor attributes for Outlook background colors", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain('bgcolor="');
+  });
+
+  it("handles unknown event types gracefully with fallback title", () => {
+    const html = generateDigestEmailHtml(makeDigest({
+      eventsByType: {
+        mystery_event: [makeDigestEvent({ eventType: "mystery_event" })],
+      },
+    }));
+    expect(html).toContain("Mystery Event");
+  });
+});
+
+// ============================================
+// DIGEST CHANGE DESCRIPTIONS
+// ============================================
+
+describe("formatDigestChangeDescription", () => {
+  it("formats price changes with arrow entity", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent());
+    expect(result).toContain("$89.00");
+    expect(result).toContain("&rarr;");
+    expect(result).toContain("$8.90");
+  });
+
+  it("formats visibility changes", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      eventType: "visibility_change",
+      beforeValue: "active",
+      afterValue: "draft",
+    }));
+    expect(result).toContain("active");
+    expect(result).toContain("draft");
+  });
+
+  it("formats inventory zero", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      eventType: "inventory_zero",
+      beforeValue: "15",
+      afterValue: "0",
+    }));
+    expect(result).toContain("out of stock");
+    expect(result).toContain("15 units");
+  });
+
+  it("formats inventory low", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      eventType: "inventory_low",
+      beforeValue: "20",
+      afterValue: "3",
+    }));
+    expect(result).toContain("3 units");
+    expect(result).toContain("was 20");
+  });
+
+  it("formats theme publish", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      eventType: "theme_publish",
+      resourceName: "Dawn Custom",
+    }));
+    expect(result).toContain("live theme");
+  });
+
+  it("includes velocity context from contextData", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      contextData: JSON.stringify({ velocityContext: "selling 8/day" }),
+    }));
+    expect(result).toContain("selling 8/day");
+  });
+
+  it("includes location context from contextData", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      contextData: JSON.stringify({ locationContext: "Main Warehouse" }),
+    }));
+    expect(result).toContain("Main Warehouse");
+  });
+
+  it("handles invalid contextData gracefully", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      contextData: "not-json",
+    }));
+    // Should still produce a result without crashing
+    expect(result).toContain("$89.00");
+  });
+
+  it("formats collection events", () => {
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "collection_created" }))).toContain("collection created");
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "collection_updated" }))).toContain("Collection updated");
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "collection_deleted" }))).toContain("Collection deleted");
+  });
+
+  it("formats discount events", () => {
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "discount_created" }))).toContain("Discount created");
+    expect(formatDigestChangeDescription(makeDigestEvent({
+      eventType: "discount_changed",
+      beforeValue: "20% off",
+      afterValue: "50% off",
+    }))).toContain("&rarr;");
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "discount_deleted" }))).toContain("Discount deleted");
+  });
+
+  it("formats app permissions changed", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({ eventType: "app_permissions_changed" }));
+    expect(result).toContain("Permissions changed");
+  });
+
+  it("formats domain events", () => {
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "domain_changed" }))).toContain("Domain added or changed");
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "domain_removed" }))).toContain("Domain removed");
+  });
+});
+
+// ============================================
+// INSTANT ALERT HTML
+// ============================================
+
+describe("generateInstantAlertHtml", () => {
+  it("produces valid XHTML transitional doctype", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"');
+  });
+
+  it("uses table-based layout", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).not.toContain("display: flex");
+    expect(html).toContain('role="presentation"');
+  });
+
+  it("sets min-width 320px", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("min-width: 320px");
+  });
+
+  it("uses 14px base font size", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("font-size: 14px");
+  });
+
+  it("includes shield branding", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("&#x1F6E1;");
+  });
+
+  it("uses event-specific accent color in header", () => {
+    const html = generateInstantAlertHtml(
+      makeInstantEvent({ eventType: "inventory_zero" }),
+      "test-store.myshopify.com",
+    );
+    expect(html).toContain(EVENT_TYPE_CONFIG.inventory_zero.color);
+  });
+
+  it("includes resource name", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("Blue Jacket / M");
+  });
+
+  it("includes change description", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("Price changed from $89.00 to $8.90");
+  });
+
+  it("includes Shopify Admin CTA button", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("View in Shopify Admin");
+    expect(html).toContain("test-store.myshopify.com/admin");
+  });
+
+  it("includes Outlook VML button fallback", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("v:roundrect");
+  });
+
+  it("shows revenue impact when present in contextData", () => {
+    const html = generateInstantAlertHtml(
+      makeInstantEvent({ contextData: JSON.stringify({ revenueImpact: 42.50 }) }),
+      "test-store.myshopify.com",
+    );
+    expect(html).toContain("$42.50/hr");
+  });
+
+  it("hides revenue impact when not present", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).not.toContain("Estimated impact");
+  });
+
+  it("includes settings link in footer", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("Manage instant alerts");
+  });
+});
+
+// ============================================
+// INSTANT ALERT SUBJECTS
+// ============================================
+
+describe("getInstantAlertSubject", () => {
+  it("includes resource name and shop name", () => {
+    const subject = getInstantAlertSubject(makeInstantEvent(), "test-store");
+    expect(subject).toContain("Blue Jacket / M");
+    expect(subject).toContain("test-store");
+  });
+
+  it("returns correct subject for each event type", () => {
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "price_change" }), "shop"))
+      .toContain("Price changed");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "inventory_zero" }), "shop"))
+      .toContain("Out of stock");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "inventory_low", afterValue: "3" }), "shop"))
+      .toContain("Low stock");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "theme_publish" }), "shop"))
+      .toContain("Theme published");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "visibility_change", afterValue: "active" }), "shop"))
+      .toContain("published");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "visibility_change", afterValue: "draft" }), "shop"))
+      .toContain("hidden");
+  });
+
+  it("returns correct subject for V2 event types", () => {
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "collection_created" }), "shop"))
+      .toContain("Collection created");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "discount_deleted" }), "shop"))
+      .toContain("Discount deleted");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "app_permissions_changed" }), "shop"))
+      .toContain("App permissions changed");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "domain_removed" }), "shop"))
+      .toContain("Domain removed");
+  });
+
+  it("does not include emojis in subject lines", () => {
+    const types = [
+      "price_change", "visibility_change", "inventory_low", "inventory_zero",
+      "theme_publish", "collection_created", "discount_deleted", "domain_changed",
+    ];
+    for (const eventType of types) {
+      const subject = getInstantAlertSubject(makeInstantEvent({ eventType }), "shop");
+      // Check no emoji characters (common emoji ranges)
+      expect(subject).not.toMatch(/[\u{1F600}-\u{1F64F}]/u);
+      expect(subject).not.toMatch(/[\u{1F300}-\u{1F5FF}]/u);
+      expect(subject).not.toMatch(/[\u{1F680}-\u{1F6FF}]/u);
+      expect(subject).not.toMatch(/[\u{2600}-\u{26FF}]/u);
+      expect(subject).not.toMatch(/[\u{2700}-\u{27BF}]/u);
+    }
+  });
+
+  it("handles unknown event types", () => {
+    const subject = getInstantAlertSubject(makeInstantEvent({ eventType: "unknown_type" }), "shop");
+    expect(subject).toContain("Change detected");
+  });
+});
+
+// ============================================
+// INSTANT ALERT DESCRIPTIONS
+// ============================================
+
+describe("buildInstantAlertDescription", () => {
+  it("describes price changes", () => {
+    const desc = buildInstantAlertDescription(makeInstantEvent());
+    expect(desc).toContain("Price changed from $89.00 to $8.90");
+  });
+
+  it("describes visibility changes", () => {
+    const desc = buildInstantAlertDescription(makeInstantEvent({
+      eventType: "visibility_change",
+      beforeValue: "active",
+      afterValue: "draft",
+    }));
+    expect(desc).toContain("Status changed from active to draft");
+  });
+
+  it("describes inventory zero", () => {
+    const desc = buildInstantAlertDescription(makeInstantEvent({
+      eventType: "inventory_zero",
+      beforeValue: "15",
+    }));
+    expect(desc).toContain("out of stock");
+    expect(desc).toContain("15 units");
+  });
+
+  it("describes inventory low", () => {
+    const desc = buildInstantAlertDescription(makeInstantEvent({
+      eventType: "inventory_low",
+      beforeValue: "20",
+      afterValue: "3",
+    }));
+    expect(desc).toContain("3 units total");
+    expect(desc).toContain("was 20");
+  });
+
+  it("appends velocity context", () => {
+    const desc = buildInstantAlertDescription(makeInstantEvent({
+      contextData: JSON.stringify({ velocityContext: "selling 8/day" }),
+    }));
+    expect(desc).toContain("selling 8/day");
+  });
+
+  it("appends location context", () => {
+    const desc = buildInstantAlertDescription(makeInstantEvent({
+      contextData: JSON.stringify({ locationContext: "Main Warehouse" }),
+    }));
+    expect(desc).toContain("Main Warehouse");
+  });
+
+  it("handles all V2 event types", () => {
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "collection_created" })))
+      .toContain("was created");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "collection_updated" })))
+      .toContain("was updated");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "collection_deleted" })))
+      .toContain("was deleted");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "discount_created" })))
+      .toContain("was created");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "discount_changed", beforeValue: "10%", afterValue: "20%" })))
+      .toContain("was modified");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "discount_deleted" })))
+      .toContain("was deleted");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "app_permissions_changed" })))
+      .toContain("permissions were changed");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "domain_changed" })))
+      .toContain("was added or changed");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "domain_removed" })))
+      .toContain("was removed");
+  });
+});
+
+// ============================================
+// getAlertColor
+// ============================================
+
+describe("getAlertColor", () => {
+  it("returns correct colors for known event types", () => {
+    expect(getAlertColor("price_change")).toBe("#f59e0b");
+    expect(getAlertColor("inventory_zero")).toBe("#ef4444");
+    expect(getAlertColor("theme_publish")).toBe("#06b6d4");
+  });
+
+  it("returns fallback gray for unknown event types", () => {
+    expect(getAlertColor("unknown")).toBe("#6b7280");
+  });
+});
+
+// ============================================
+// EVENT_TYPE_CONFIG
+// ============================================
+
+describe("EVENT_TYPE_CONFIG", () => {
+  it("covers all V1 + V2 event types", () => {
+    const expectedTypes = [
+      "price_change", "visibility_change", "inventory_low", "inventory_zero",
+      "theme_publish", "collection_created", "collection_updated", "collection_deleted",
+      "discount_created", "discount_changed", "discount_deleted",
+      "app_permissions_changed", "domain_changed", "domain_removed",
+    ];
+    for (const type of expectedTypes) {
+      expect(EVENT_TYPE_CONFIG[type]).toBeDefined();
+      expect(EVENT_TYPE_CONFIG[type].title).toBeTruthy();
+      expect(EVENT_TYPE_CONFIG[type].color).toMatch(/^#[0-9a-f]{6}$/);
+      expect(typeof EVENT_TYPE_CONFIG[type].order).toBe("number");
+    }
+  });
+
+  it("has unique display orders", () => {
+    const orders = Object.values(EVENT_TYPE_CONFIG).map((c) => c.order);
+    expect(new Set(orders).size).toBe(orders.length);
+  });
+});
diff --git a/insightops/app/services/jobProcessor.server.ts b/insightops/app/services/jobProcessor.server.ts
index acc4c19..8a1e043 100644
--- a/insightops/app/services/jobProcessor.server.ts
+++ b/insightops/app/services/jobProcessor.server.ts
@@ -12,7 +12,20 @@ import {
   detectLowStock,
   deleteProductSnapshot,
   recordThemePublish,
+  recordCollectionCreated,
+  recordCollectionUpdated,
+  recordCollectionDeleted,
+  recordDiscountCreated,
+  recordDiscountUpdated,
+  recordDiscountDeleted,
+  recordAppPermissionsChanged,
+  recordDomainChanged,
+  recordDomainRemoved,
 } from "./changeDetection.server";
+import {
+  aggregateInventoryLevels,
+  type InventoryLevelNode,
+} from "./changeDetection.utils";
 
 // Full product payload from Shopify webhook
 interface ProductPayload {
@@ -69,6 +82,23 @@ interface CollectionPayload {
   } | null;
 }
 
+interface DiscountPayload {
+  id: number;
+  title: string;
+  value: string;
+  value_type: string; // "percentage" | "fixed_amount"
+  code?: string;
+  starts_at: string | null;
+  ends_at: string | null;
+}
+
+interface DomainPayload {
+  id: number;
+  host: string;
+  ssl_enabled?: boolean;
+  localization?: { country: string | null; default_locale: string };
+}
+
 interface InventoryLevelPayload {
   inventory_item_id: number;
   location_id: number;
@@ -322,20 +352,19 @@ async function processProductUpdate(
     }
   }
 
-  // === Legacy EventLog (for activity timeline) ===
   // Create new snapshot
   const newSnapshot = createProductSnapshot(payload);
 
   // Get previous snapshot for diff comparison
   // Look for any event with a snapshot (baseline or previous update)
   let oldSnapshot: ProductSnapshot | null = null;
-  const previousEvents = await db.eventLog.findMany({
+  const previousEvents = await db.changeEvent.findMany({
     where: {
       shop,
-      shopifyId: String(payload.id),
+      entityId: String(payload.id),
       diff: { not: null },
     },
-    orderBy: { timestamp: "desc" },
+    orderBy: { detectedAt: "desc" },
     take: 5, // Check recent events for a valid snapshot
   });
 
@@ -382,16 +411,20 @@ async function processProductUpdate(
     update: { title: payload.title },
   });
 
-  // Create event log
-  await db.eventLog.create({
+  // Create activity log entry
+  await db.changeEvent.create({
     data: {
       shop,
-      shopifyId: String(payload.id),
+      entityType: "product",
+      entityId: String(payload.id),
+      eventType: "product_updated",
+      resourceName: payload.title,
+      source: "webhook",
+      importance: "low",
       topic: "products/update",
       author,
-      message,
       diff,
-      webhookId,
+      webhookId: webhookId ?? `activity-products-update-${payload.id}-${Date.now()}`,
     },
   });
 
@@ -438,15 +471,19 @@ async function processProductCreate(
     update: { title: payload.title },
   });
 
-  await db.eventLog.create({
+  await db.changeEvent.create({
     data: {
       shop,
-      shopifyId: String(payload.id),
+      entityType: "product",
+      entityId: String(payload.id),
+      eventType: "product_created",
+      resourceName: payload.title,
+      source: "webhook",
+      importance: "low",
       topic: "products/create",
       author,
-      message,
       diff,
-      webhookId,
+      webhookId: webhookId ?? `activity-products-create-${payload.id}-${Date.now()}`,
     },
   });
 
@@ -479,28 +516,33 @@ async function processProductDelete(
   // === StoreGuard: Clean up snapshot for deleted product ===
   await deleteProductSnapshot(shop, productId);
 
-  // Fallback to previous events
+  // Fallback to previous ChangeEvent records
   if (!productTitle) {
-    const previousEvent = await db.eventLog.findFirst({
-      where: { shop, shopifyId: productId },
-      orderBy: { timestamp: "desc" },
+    const previousEvent = await db.changeEvent.findFirst({
+      where: { shop, entityId: productId },
+      orderBy: { detectedAt: "desc" },
     });
-    const match = previousEvent?.message?.match(/"([^"]+)"/);
-    if (match) productTitle = match[1];
+    if (previousEvent) {
+      productTitle = previousEvent.resourceName;
+    }
   }
 
   const displayName = productTitle || `Product #${payload.id}`;
   const message = `Product deleted: "${displayName}"`;
 
-  await db.eventLog.create({
+  await db.changeEvent.create({
     data: {
       shop,
-      shopifyId: productId,
+      entityType: "product",
+      entityId: productId,
+      eventType: "product_deleted",
+      resourceName: displayName,
+      source: "webhook",
+      importance: "low",
       topic: "products/delete",
       author: "System/App",
-      message,
       diff: null,
-      webhookId,
+      webhookId: webhookId ?? `activity-products-delete-${payload.id}-${Date.now()}`,
     },
   });
 
@@ -520,61 +562,229 @@ async function processCollection(
   const verb = topic.includes("create") ? "create" : topic.includes("update") ? "update" : "delete";
 
   if (verb === "delete") {
-    // For deletes, try to get title from previous events
+    // For deletes, try to get title from previous events or ChangeEvents
     const collectionId = String((payload as { id: number }).id);
     let title: string | null = null;
 
-    const previousEvent = await db.eventLog.findFirst({
-      where: { shop, shopifyId: collectionId, topic: { contains: "collections" } },
-      orderBy: { timestamp: "desc" },
+    // Try ChangeEvent first for title lookup
+    const previousChange = await db.changeEvent.findFirst({
+      where: { shop, entityType: "collection", entityId: collectionId },
+      orderBy: { detectedAt: "desc" },
     });
-    const match = previousEvent?.message?.match(/"([^"]+)"/);
-    if (match) title = match[1];
+    if (previousChange) {
+      title = previousChange.resourceName;
+    }
 
     const displayName = title || `Collection #${collectionId}`;
-    const message = `Collection deleted: "${displayName}"`;
 
-    await db.eventLog.create({
-      data: {
-        shop,
-        shopifyId: collectionId,
-        topic,
-        author: "System/App",
-        message,
-        diff: null,
-        webhookId,
-      },
-    });
+    // === StoreGuard ChangeEvent ===
+    if (webhookId) {
+      await recordCollectionDeleted(shop, collectionId, displayName, webhookId);
+    }
 
-    console.log(`[StoreGuard] Logged: ${message}`);
+    console.log(`[StoreGuard] Collection deleted: "${displayName}"`);
     return;
   }
 
   const collection = payload as CollectionPayload;
   const author = (await fetchAuthor(shop, accessToken, "Collection", collection.id, verb)) || "System/App";
-  const message = `${author} ${verb}d collection "${collection.title}"`;
 
-  await db.eventLog.create({
-    data: {
-      shop,
-      shopifyId: String(collection.id),
-      topic,
-      author,
-      message,
-      diff: JSON.stringify({ title: collection.title, handle: collection.handle }),
-      webhookId,
-    },
-  });
+  // === StoreGuard ChangeEvent ===
+  if (webhookId) {
+    if (verb === "create") {
+      await recordCollectionCreated(shop, String(collection.id), collection.title, webhookId);
+    } else {
+      await recordCollectionUpdated(shop, String(collection.id), collection.title, webhookId);
+    }
+  }
 
-  console.log(`[StoreGuard] Logged: ${message}`);
+  console.log(`[StoreGuard] Collection ${verb}d: "${collection.title}"`);
+}
+
+/**
+ * Process a discount job
+ */
+async function processDiscount(
+  shop: string,
+  topic: string,
+  payload: DiscountPayload | { id: number },
+  webhookId: string | null
+): Promise<void> {
+  const verb = topic.includes("create") ? "create" : topic.includes("update") ? "update" : "delete";
+
+  if (verb === "delete") {
+    const discountId = String((payload as { id: number }).id);
+
+    // Try to find a title from previous ChangeEvents
+    let title: string | null = null;
+    const previousChange = await db.changeEvent.findFirst({
+      where: { shop, entityType: "discount", entityId: discountId },
+      orderBy: { detectedAt: "desc" },
+    });
+    if (previousChange) {
+      title = previousChange.resourceName;
+    }
+
+    const displayName = title || `Discount #${discountId}`;
+
+    if (webhookId) {
+      await recordDiscountDeleted(shop, discountId, displayName, webhookId);
+    }
+
+    console.log(`[StoreGuard] Discount deleted: "${displayName}"`);
+    return;
+  }
+
+  const discount = payload as DiscountPayload;
+  const discountTitle = discount.title || discount.code || `Discount #${discount.id}`;
+  const discountValue = discount.value_type === "percentage" ? discount.value : null;
+
+  if (webhookId) {
+    if (verb === "create") {
+      await recordDiscountCreated(shop, String(discount.id), discountTitle, discountValue, webhookId);
+    } else {
+      await recordDiscountUpdated(shop, String(discount.id), discountTitle, discountValue, webhookId);
+    }
+  }
+
+  console.log(`[StoreGuard] Discount ${verb}d: "${discountTitle}"`);
+}
+
+/**
+ * Process a domain job
+ */
+async function processDomain(
+  shop: string,
+  topic: string,
+  payload: DomainPayload | { id: number },
+  webhookId: string | null
+): Promise<void> {
+  const isDestroy = topic.includes("destroy");
+
+  if (isDestroy) {
+    const domainId = String((payload as { id: number }).id);
+
+    // Try to find a host from previous ChangeEvents
+    let host: string | null = null;
+    const previousChange = await db.changeEvent.findFirst({
+      where: { shop, entityType: "domain", entityId: domainId },
+      orderBy: { detectedAt: "desc" },
+    });
+    if (previousChange) {
+      host = previousChange.resourceName;
+    }
+
+    const displayName = host || `Domain #${domainId}`;
+
+    if (webhookId) {
+      await recordDomainRemoved(shop, domainId, displayName, webhookId);
+    }
+
+    console.log(`[StoreGuard] Domain removed: "${displayName}"`);
+    return;
+  }
+
+  const domain = payload as DomainPayload;
+  const domainHost = domain.host || `Domain #${domain.id}`;
+
+  if (webhookId) {
+    await recordDomainChanged(shop, String(domain.id), domainHost, webhookId);
+  }
+
+  console.log(`[StoreGuard] Domain changed: "${domainHost}"`);
+}
+
+/** Shape of the inventoryLevels connection from the GraphQL response */
+interface InventoryLevelsConnection {
+  nodes: InventoryLevelNode[];
+  pageInfo: { hasNextPage: boolean; endCursor: string | null };
+}
+
+/**
+ * Fetch total inventory across all locations for an inventory item.
+ * Uses cursor-based pagination to handle merchants with >50 locations.
+ * Returns { totalQuantity, locationName } where totalQuantity is the sum
+ * of available quantities across all locations, and locationName is the
+ * name of the location that triggered this webhook.
+ */
+async function fetchTotalInventory(
+  shop: string,
+  accessToken: string,
+  inventoryItemId: number,
+  triggerLocationId: number
+): Promise<{ totalQuantity: number; locationName: string | null }> {
+  const allNodes: InventoryLevelNode[] = [];
+  let cursor: string | null = null;
+  const MAX_PAGES = 20; // Safety limit to prevent infinite loops
+
+  try {
+    for (let page = 0; page < MAX_PAGES; page++) {
+      const gql = await fetch(`https://${shop}/admin/api/${apiVersion}/graphql.json`, {
+        method: "POST",
+        headers: {
+          "X-Shopify-Access-Token": accessToken,
+          "Content-Type": "application/json",
+        },
+        body: JSON.stringify({
+          query: `#graphql
+            query InventoryLevels($inventoryItemId: ID!, $cursor: String) {
+              inventoryItem(id: $inventoryItemId) {
+                inventoryLevels(first: 50, after: $cursor) {
+                  nodes {
+                    quantities(names: ["available"]) {
+                      quantity
+                    }
+                    location {
+                      id
+                      name
+                    }
+                  }
+                  pageInfo {
+                    hasNextPage
+                    endCursor
+                  }
+                }
+              }
+            }`,
+          variables: {
+            inventoryItemId: `gid://shopify/InventoryItem/${inventoryItemId}`,
+            cursor,
+          },
+        }),
+      });
+
+      const data = (await gql.json()) as {
+        data?: { inventoryItem?: { inventoryLevels?: InventoryLevelsConnection } };
+      };
+      const connection = data?.data?.inventoryItem?.inventoryLevels;
+      if (!connection?.nodes || connection.nodes.length === 0) {
+        break;
+      }
+
+      allNodes.push(...connection.nodes);
+
+      if (!connection.pageInfo.hasNextPage || !connection.pageInfo.endCursor) {
+        break;
+      }
+      cursor = connection.pageInfo.endCursor;
+    }
+
+    if (allNodes.length === 0) {
+      return { totalQuantity: 0, locationName: null };
+    }
+
+    return aggregateInventoryLevels(allNodes, triggerLocationId);
+  } catch (error) {
+    console.error(`[StoreGuard] Failed to fetch total inventory:`, error);
+    return { totalQuantity: 0, locationName: null };
+  }
 }
 
 /**
  * Process an inventory update job
  *
- * NOTE: Once the orders/paid webhook is enabled (requires Protected Customer Data approval),
- * the noise filter below will automatically hide inventory updates caused by orders.
- * Until then, we keep logging inventory updates so the app isn't blind to sales activity.
+ * Multi-location aware: aggregates inventory across all locations before alerting.
+ * The webhook fires per-location, so we query Shopify for the total across all locations.
  */
 async function processInventoryUpdate(
   shop: string,
@@ -647,15 +857,15 @@ async function processInventoryUpdate(
   // When orders webhook is enabled, this will hide the "symptom" when we already have the "cause"
   if (productId) {
     try {
-      const recentOrder = await db.eventLog.findFirst({
+      const recentOrder = await db.changeEvent.findFirst({
         where: {
           shop,
-          topic: "ORDERS_CREATE",
-          timestamp: {
+          topic: "orders/paid",
+          detectedAt: {
             gte: new Date(Date.now() - 30 * 1000), // Within last 30 seconds
           },
         },
-        orderBy: { timestamp: "desc" },
+        orderBy: { detectedAt: "desc" },
       });
 
       if (recentOrder?.diff) {
@@ -671,114 +881,124 @@ async function processInventoryUpdate(
     }
   }
 
-  // Get previous inventory level for diff display AND for >0→0 detection
-  // Strategy: Check EventLog first (most recent), then fall back to ProductSnapshot
+  // === Multi-location: Fetch total inventory across all locations ===
+  const { totalQuantity, locationName } = await fetchTotalInventory(
+    shop,
+    accessToken,
+    payload.inventory_item_id,
+    payload.location_id
+  );
+
+  // Get previous TOTAL inventory for diff display AND for >0→0 detection
+  // Strategy: Check ChangeEvent first (most recent), then fall back to ProductSnapshot
   let oldAvailable: number | null = null;
   try {
-    // First, try EventLog (recent inventory updates)
-    const previousEvent = await db.eventLog.findFirst({
+    // First, try ChangeEvent (recent inventory updates) — stores totalQuantity
+    const previousEvent = await db.changeEvent.findFirst({
       where: {
         shop,
-        shopifyId: String(payload.inventory_item_id),
-        topic: "INVENTORY_LEVELS_UPDATE",
+        entityId: String(payload.inventory_item_id),
+        topic: "inventory/levels/update",
       },
-      orderBy: { timestamp: "desc" },
+      orderBy: { detectedAt: "desc" },
     });
 
     if (previousEvent?.diff) {
       const prevDiff = JSON.parse(previousEvent.diff);
-      oldAvailable = prevDiff.available;
+      // Prefer totalQuantity (multi-location) over legacy available (single-location)
+      oldAvailable = prevDiff.totalQuantity ?? prevDiff.available ?? null;
     }
 
-    // If no EventLog, fall back to ProductSnapshot
+    // If no ChangeEvent, fall back to ProductSnapshot
     if (oldAvailable === null && productId && variantId) {
-      const snapshot = await db.productSnapshot.findUnique({
-        where: { shop_id: { shop, id: productId } },
+      const matchingVariant = await db.variantSnapshot.findUnique({
+        where: {
+          productSnapshotId_shopifyVariantId: {
+            productSnapshotId: productId,
+            shopifyVariantId: variantId,
+          },
+        },
       });
-      if (snapshot?.variants) {
-        try {
-          const variants = JSON.parse(snapshot.variants) as Array<{ id: string; inventoryQuantity: number }>;
-          const matchingVariant = variants.find(v => v.id === variantId);
-          if (matchingVariant && matchingVariant.inventoryQuantity !== undefined) {
-            oldAvailable = matchingVariant.inventoryQuantity;
-            console.log(`[StoreGuard] Got previous inventory ${oldAvailable} from ProductSnapshot for ${productTitle}`);
-          }
-        } catch {
-          // Invalid JSON in snapshot
-        }
+      if (matchingVariant && matchingVariant.inventoryQuantity !== undefined) {
+        oldAvailable = matchingVariant.inventoryQuantity;
+        console.log(`[StoreGuard] Got previous inventory ${oldAvailable} from VariantSnapshot for ${productTitle}`);
       }
     }
   } catch (prevError) {
     console.error(`[StoreGuard] Failed to fetch previous inventory:`, prevError);
   }
 
-  // === StoreGuard: Detect inventory changes ===
+  // Build location context for alerts
+  const locationContext = locationName ? `Last change at ${locationName}` : null;
+
+  // === StoreGuard: Detect inventory changes using TOTAL quantity ===
   if (productId && webhookId) {
-    // Detect low stock (crossing below threshold)
+    // Detect low stock (crossing below threshold) — uses total across all locations
     const lowStockDetected = await detectLowStock(
       shop,
       String(payload.inventory_item_id),
       productId,
       productTitle,
       variantTitle,
-      payload.available,
+      totalQuantity,
       oldAvailable,
-      webhookId
+      webhookId,
+      locationContext
     );
 
     // Detect inventory hitting zero (only if not already low stock alert)
-    // Rule: Only triggers on >0 → 0 transition
-    if (payload.available === 0 && !lowStockDetected) {
+    // Rule: Only triggers on >0 → 0 transition — uses total across all locations
+    if (totalQuantity === 0 && !lowStockDetected) {
       await detectInventoryZero(
         shop,
         String(payload.inventory_item_id),
         productId,
         productTitle,
         variantTitle,
-        payload.available,
+        totalQuantity,
         oldAvailable,
-        webhookId
+        webhookId,
+        locationContext
       );
     }
   }
 
-  // Update or create ProductSnapshot with inventory (keeps snapshot current for future comparisons)
+  // Update or create ProductSnapshot with TOTAL inventory (keeps snapshot current for future comparisons)
   if (productId && variantId) {
     try {
-      const snapshot = await db.productSnapshot.findUnique({
+      // Ensure ProductSnapshot exists
+      await db.productSnapshot.upsert({
         where: { shop_id: { shop, id: productId } },
+        create: {
+          id: productId,
+          shop,
+          title: productTitle,
+          status: "active",
+        },
+        update: {},
       });
-      if (snapshot?.variants) {
-        // Update existing snapshot
-        const variants = JSON.parse(snapshot.variants) as Array<{ id: string; title: string; price: string; inventoryQuantity: number }>;
-        const variantIndex = variants.findIndex(v => v.id === variantId);
-        if (variantIndex >= 0) {
-          variants[variantIndex].inventoryQuantity = payload.available;
-          await db.productSnapshot.update({
-            where: { shop_id: { shop, id: productId } },
-            data: { variants: JSON.stringify(variants) },
-          });
-          console.log(`[StoreGuard] Updated ProductSnapshot inventory for ${productTitle}: ${payload.available}`);
-        }
-      } else if (!snapshot) {
-        // No snapshot exists - create a minimal one for future tracking
-        // This ensures the NEXT inventory change can be detected
-        await db.productSnapshot.create({
-          data: {
-            id: productId,
-            shop,
-            title: productTitle,
-            status: "active", // Default assumption
-            variants: JSON.stringify([{
-              id: variantId,
-              title: variantTitle || "Default Title",
-              price: "0.00",
-              inventoryQuantity: payload.available,
-            }]),
+
+      // Upsert the specific variant — atomic, no read-modify-write
+      await db.variantSnapshot.upsert({
+        where: {
+          productSnapshotId_shopifyVariantId: {
+            productSnapshotId: productId,
+            shopifyVariantId: variantId,
           },
-        });
-        console.log(`[StoreGuard] Created ProductSnapshot from inventory webhook for ${productTitle}`);
-      }
+        },
+        create: {
+          productSnapshotId: productId,
+          shop,
+          shopifyVariantId: variantId,
+          title: variantTitle || "Default Title",
+          price: "0.00",
+          inventoryQuantity: totalQuantity,
+        },
+        update: {
+          inventoryQuantity: totalQuantity,
+        },
+      });
+      console.log(`[StoreGuard] Updated VariantSnapshot inventory for ${productTitle}: ${totalQuantity} (total across locations)`);
     } catch (snapshotError) {
       console.error(`[StoreGuard] Failed to update ProductSnapshot inventory:`, snapshotError);
     }
@@ -789,40 +1009,49 @@ async function processInventoryUpdate(
       ? `${productTitle} - ${variantTitle}`
       : productTitle;
 
-  // Create a clear message showing stock change
+  // Create a clear message showing stock change (total across all locations)
   let message: string;
-  if (oldAvailable !== null && oldAvailable !== payload.available) {
-    const change = payload.available - oldAvailable;
+  if (oldAvailable !== null && oldAvailable !== totalQuantity) {
+    const change = totalQuantity - oldAvailable;
     const arrow = change > 0 ? "↑" : "↓";
-    message = `Stock ${arrow} "${displayName}" (${oldAvailable} → ${payload.available})`;
+    message = `Stock ${arrow} "${displayName}" (${oldAvailable} → ${totalQuantity} total)`;
   } else {
-    message = `Stock updated: "${displayName}" (${payload.available} units)`;
+    message = `Stock updated: "${displayName}" (${totalQuantity} units total)`;
+  }
+  if (locationName) {
+    message += ` [${locationName}]`;
   }
 
   const diff = JSON.stringify({
     available: payload.available,
+    totalQuantity,
     inventoryChange:
-      oldAvailable !== null && oldAvailable !== payload.available
-        ? { old: oldAvailable, new: payload.available }
+      oldAvailable !== null && oldAvailable !== totalQuantity
+        ? { old: oldAvailable, new: totalQuantity }
         : null,
     locationId: payload.location_id,
+    locationName,
   });
 
-  await db.eventLog.create({
+  await db.changeEvent.create({
     data: {
       shop,
+      entityType: "variant",
       // Use inventory_item_id consistently for inventory events
       // This matches the lookup in getPreviousInventory above
-      shopifyId: String(payload.inventory_item_id),
-      topic: "INVENTORY_LEVELS_UPDATE",
+      entityId: String(payload.inventory_item_id),
+      eventType: "inventory_update",
+      resourceName: displayName,
+      source: "webhook",
+      importance: "low",
+      topic: "inventory/levels/update",
       author: "System/App",
-      message,
       diff,
-      webhookId,
+      webhookId: webhookId ?? `activity-inventory-update-${payload.inventory_item_id}-${Date.now()}`,
     },
   });
 
-  console.log(`[StoreGuard] ✅ Logged: ${message}`);
+  console.log(`[StoreGuard] Logged: ${message}`);
 }
 
 /**
@@ -898,15 +1127,19 @@ async function processOrderPaid(
     discounts: payload.discount_codes,
   });
 
-  await db.eventLog.create({
+  await db.changeEvent.create({
     data: {
       shop,
-      shopifyId: String(payload.id),
-      topic: "ORDERS_CREATE",
+      entityType: "order",
+      entityId: String(payload.id),
+      eventType: "order_paid",
+      resourceName: message,
+      source: "webhook",
+      importance: "low",
+      topic: "orders/paid",
       author: "Customer",
-      message,
       diff,
-      webhookId,
+      webhookId: webhookId ?? `activity-orders-paid-${payload.id}-${Date.now()}`,
     },
   });
 
@@ -915,16 +1148,37 @@ async function processOrderPaid(
 
 /**
  * Process an app scopes update job
+ * Diffs previous vs current scopes and creates ChangeEvent for permission changes
  */
 async function processScopesUpdate(
   shop: string,
   sessionId: string,
-  payload: { current: string[] }
+  payload: { current: string[] },
+  webhookId: string | null
 ): Promise<void> {
+  // Get the previous scopes from the session before updating
+  const currentSession = await db.session.findUnique({
+    where: { id: sessionId },
+    select: { scope: true },
+  });
+
+  const previousScopes = currentSession?.scope
+    ? currentSession.scope.split(",").map(s => s.trim()).filter(Boolean)
+    : [];
+
+  const currentScopes = payload.current;
+
+  // Update the session with new scopes
   await db.session.update({
     where: { id: sessionId },
-    data: { scope: payload.current.toString() },
+    data: { scope: currentScopes.toString() },
   });
+
+  // === StoreGuard: Create ChangeEvent for permission diff ===
+  if (webhookId) {
+    await recordAppPermissionsChanged(shop, previousScopes, currentScopes, webhookId);
+  }
+
   console.log(`[StoreGuard] Updated scopes for ${shop}`);
 }
 
@@ -974,11 +1228,21 @@ async function processJob(job: {
     case "themes/publish":
       await processThemePublish(job.shop, payload, job.webhookId);
       break;
+    case "discounts/create":
+    case "discounts/update":
+    case "discounts/delete":
+      await processDiscount(job.shop, normalizedTopic, payload, job.webhookId);
+      break;
+    case "domains/create":
+    case "domains/update":
+    case "domains/destroy":
+      await processDomain(job.shop, normalizedTopic, payload, job.webhookId);
+      break;
     case "orders/paid":
       await processOrderPaid(job.shop, payload, job.webhookId);
       break;
     case "app/scopes/update":
-      await processScopesUpdate(job.shop, session.id, payload);
+      await processScopesUpdate(job.shop, session.id, payload, job.webhookId);
       break;
     default:
       console.log(`[StoreGuard] Unknown topic: ${job.topic} (normalized: ${normalizedTopic})`);
diff --git a/insightops/app/services/jobProcessor.test.ts b/insightops/app/services/jobProcessor.test.ts
new file mode 100644
index 0000000..3ed08ff
--- /dev/null
+++ b/insightops/app/services/jobProcessor.test.ts
@@ -0,0 +1,93 @@
+import { describe, it, expect } from "vitest";
+import {
+  aggregateInventoryLevels,
+  type InventoryLevelNode,
+} from "./changeDetection.utils";
+
+describe("aggregateInventoryLevels", () => {
+  it("should sum quantities across all locations", () => {
+    const nodes: InventoryLevelNode[] = [
+      { quantities: [{ quantity: 10 }], location: { id: "gid://shopify/Location/1", name: "Warehouse A" } },
+      { quantities: [{ quantity: 20 }], location: { id: "gid://shopify/Location/2", name: "Warehouse B" } },
+      { quantities: [{ quantity: 5 }], location: { id: "gid://shopify/Location/3", name: "Retail Store" } },
+    ];
+
+    const result = aggregateInventoryLevels(nodes, 2);
+    expect(result.totalQuantity).toBe(35);
+    expect(result.locationName).toBe("Warehouse B");
+  });
+
+  it("should return zero for empty nodes array", () => {
+    const result = aggregateInventoryLevels([], 1);
+    expect(result.totalQuantity).toBe(0);
+    expect(result.locationName).toBeNull();
+  });
+
+  it("should handle null location gracefully", () => {
+    const nodes: InventoryLevelNode[] = [
+      { quantities: [{ quantity: 7 }], location: null },
+      { quantities: [{ quantity: 3 }], location: { id: "gid://shopify/Location/5", name: "Main" } },
+    ];
+
+    const result = aggregateInventoryLevels(nodes, 5);
+    expect(result.totalQuantity).toBe(10);
+    expect(result.locationName).toBe("Main");
+  });
+
+  it("should return null locationName when trigger location not found", () => {
+    const nodes: InventoryLevelNode[] = [
+      { quantities: [{ quantity: 10 }], location: { id: "gid://shopify/Location/1", name: "Warehouse A" } },
+    ];
+
+    const result = aggregateInventoryLevels(nodes, 999);
+    expect(result.totalQuantity).toBe(10);
+    expect(result.locationName).toBeNull();
+  });
+
+  it("should handle missing quantities array", () => {
+    const nodes: InventoryLevelNode[] = [
+      { quantities: [], location: { id: "gid://shopify/Location/1", name: "W1" } },
+      { quantities: [{ quantity: 15 }], location: { id: "gid://shopify/Location/2", name: "W2" } },
+    ];
+
+    const result = aggregateInventoryLevels(nodes, 1);
+    expect(result.totalQuantity).toBe(15);
+    expect(result.locationName).toBe("W1");
+  });
+
+  it("should handle many locations (>50 simulating paginated results)", () => {
+    const nodes: InventoryLevelNode[] = [];
+    for (let i = 1; i <= 120; i++) {
+      nodes.push({
+        quantities: [{ quantity: 1 }],
+        location: { id: `gid://shopify/Location/${i}`, name: `Location ${i}` },
+      });
+    }
+
+    const result = aggregateInventoryLevels(nodes, 75);
+    expect(result.totalQuantity).toBe(120);
+    expect(result.locationName).toBe("Location 75");
+  });
+
+  it("should handle negative quantities", () => {
+    const nodes: InventoryLevelNode[] = [
+      { quantities: [{ quantity: -2 }], location: { id: "gid://shopify/Location/1", name: "Returns" } },
+      { quantities: [{ quantity: 10 }], location: { id: "gid://shopify/Location/2", name: "Warehouse" } },
+    ];
+
+    const result = aggregateInventoryLevels(nodes, 1);
+    expect(result.totalQuantity).toBe(8);
+    expect(result.locationName).toBe("Returns");
+  });
+
+  it("should handle zero quantities at all locations", () => {
+    const nodes: InventoryLevelNode[] = [
+      { quantities: [{ quantity: 0 }], location: { id: "gid://shopify/Location/1", name: "W1" } },
+      { quantities: [{ quantity: 0 }], location: { id: "gid://shopify/Location/2", name: "W2" } },
+    ];
+
+    const result = aggregateInventoryLevels(nodes, 1);
+    expect(result.totalQuantity).toBe(0);
+    expect(result.locationName).toBe("W1");
+  });
+});
diff --git a/insightops/app/services/onboarding.test.ts b/insightops/app/services/onboarding.test.ts
new file mode 100644
index 0000000..d744338
--- /dev/null
+++ b/insightops/app/services/onboarding.test.ts
@@ -0,0 +1,132 @@
+import { describe, it, expect } from "vitest";
+import {
+  ONBOARDING_STEPS,
+  getStepIndex,
+  isValidStep,
+  getNextStep,
+  getPreviousStep,
+  isValidEmail,
+  validateEmailStep,
+  validateMonitorStep,
+  DEFAULT_MONITORS,
+  type MonitorSelections,
+} from "./onboarding.utils";
+
+describe("ONBOARDING_STEPS", () => {
+  it("has exactly 5 steps in correct order", () => {
+    expect(ONBOARDING_STEPS).toEqual(["welcome", "email", "monitors", "sync", "done"]);
+    expect(ONBOARDING_STEPS).toHaveLength(5);
+  });
+});
+
+describe("getStepIndex", () => {
+  it("returns correct index for each step", () => {
+    expect(getStepIndex("welcome")).toBe(0);
+    expect(getStepIndex("email")).toBe(1);
+    expect(getStepIndex("monitors")).toBe(2);
+    expect(getStepIndex("sync")).toBe(3);
+    expect(getStepIndex("done")).toBe(4);
+  });
+});
+
+describe("isValidStep", () => {
+  it("returns true for valid steps", () => {
+    expect(isValidStep("welcome")).toBe(true);
+    expect(isValidStep("email")).toBe(true);
+    expect(isValidStep("monitors")).toBe(true);
+    expect(isValidStep("sync")).toBe(true);
+    expect(isValidStep("done")).toBe(true);
+  });
+
+  it("returns false for invalid steps", () => {
+    expect(isValidStep("invalid")).toBe(false);
+    expect(isValidStep("")).toBe(false);
+    expect(isValidStep("setup")).toBe(false);
+  });
+});
+
+describe("getNextStep", () => {
+  it("returns the next step", () => {
+    expect(getNextStep("welcome")).toBe("email");
+    expect(getNextStep("email")).toBe("monitors");
+    expect(getNextStep("monitors")).toBe("sync");
+    expect(getNextStep("sync")).toBe("done");
+  });
+
+  it("returns null for the last step", () => {
+    expect(getNextStep("done")).toBeNull();
+  });
+});
+
+describe("getPreviousStep", () => {
+  it("returns the previous step", () => {
+    expect(getPreviousStep("email")).toBe("welcome");
+    expect(getPreviousStep("monitors")).toBe("email");
+    expect(getPreviousStep("sync")).toBe("monitors");
+    expect(getPreviousStep("done")).toBe("sync");
+  });
+
+  it("returns null for the first step", () => {
+    expect(getPreviousStep("welcome")).toBeNull();
+  });
+});
+
+describe("isValidEmail", () => {
+  it("accepts valid emails", () => {
+    expect(isValidEmail("user@example.com")).toBe(true);
+    expect(isValidEmail("user+tag@domain.co.uk")).toBe(true);
+    expect(isValidEmail("a@b.c")).toBe(true);
+  });
+
+  it("rejects invalid emails", () => {
+    expect(isValidEmail("")).toBe(false);
+    expect(isValidEmail("noatsign")).toBe(false);
+    expect(isValidEmail("no@domain")).toBe(false);
+    expect(isValidEmail("@no-user.com")).toBe(false);
+    expect(isValidEmail("spaces in@email.com")).toBe(false);
+  });
+});
+
+describe("validateEmailStep", () => {
+  it("returns error for empty email", () => {
+    expect(validateEmailStep("")).toBe("Please enter an email address to receive alerts.");
+    expect(validateEmailStep("   ")).toBe("Please enter an email address to receive alerts.");
+  });
+
+  it("returns error for invalid email", () => {
+    expect(validateEmailStep("notanemail")).toBe("Please enter a valid email address.");
+  });
+
+  it("returns null for valid email", () => {
+    expect(validateEmailStep("user@example.com")).toBeNull();
+    expect(validateEmailStep("  user@example.com  ")).toBeNull();
+  });
+});
+
+describe("validateMonitorStep", () => {
+  it("returns error when no monitors selected", () => {
+    const noMonitors: MonitorSelections = {
+      trackPrices: false,
+      trackVisibility: false,
+      trackInventory: false,
+      trackCollections: false,
+    };
+    expect(validateMonitorStep(noMonitors)).toBe("Please select at least one monitor.");
+  });
+
+  it("returns null when at least one monitor is selected", () => {
+    expect(validateMonitorStep({ ...DEFAULT_MONITORS, trackPrices: true, trackVisibility: false, trackInventory: false, trackCollections: false })).toBeNull();
+    expect(validateMonitorStep(DEFAULT_MONITORS)).toBeNull();
+  });
+});
+
+describe("DEFAULT_MONITORS", () => {
+  it("has all monitors enabled by default", () => {
+    expect(DEFAULT_MONITORS).toEqual({
+      trackPrices: true,
+      trackVisibility: true,
+      trackInventory: true,
+      trackCollections: true,
+    });
+  });
+});
diff --git a/insightops/app/services/onboarding.utils.ts b/insightops/app/services/onboarding.utils.ts
new file mode 100644
index 0000000..c77cda6
--- /dev/null
+++ b/insightops/app/services/onboarding.utils.ts
@@ -0,0 +1,59 @@
+/**
+ * Onboarding step definitions and validation logic.
+ * Pure functions — no database or server dependencies.
+ */
+
+export const ONBOARDING_STEPS = ["welcome", "email", "monitors", "sync", "done"] as const;
+export type OnboardingStep = (typeof ONBOARDING_STEPS)[number];
+
+export function getStepIndex(step: OnboardingStep): number {
+  return ONBOARDING_STEPS.indexOf(step);
+}
+
+export function isValidStep(step: string): step is OnboardingStep {
+  return ONBOARDING_STEPS.includes(step as OnboardingStep);
+}
+
+export function getNextStep(current: OnboardingStep): OnboardingStep | null {
+  const idx = getStepIndex(current);
+  if (idx < 0 || idx >= ONBOARDING_STEPS.length - 1) return null;
+  return ONBOARDING_STEPS[idx + 1];
+}
+
+export function getPreviousStep(current: OnboardingStep): OnboardingStep | null {
+  const idx = getStepIndex(current);
+  if (idx <= 0) return null;
+  return ONBOARDING_STEPS[idx - 1];
+}
+
+export function isValidEmail(email: string): boolean {
+  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
+}
+
+export interface MonitorSelections {
+  trackPrices: boolean;
+  trackVisibility: boolean;
+  trackInventory: boolean;
+  trackCollections: boolean;
+}
+
+export const DEFAULT_MONITORS: MonitorSelections = {
+  trackPrices: true,
+  trackVisibility: true,
+  trackInventory: true,
+  trackCollections: true,
+};
+
+export function validateEmailStep(email: string): string | null {
+  const trimmed = email.trim();
+  if (!trimmed) return "Please enter an email address to receive alerts.";
+  if (!isValidEmail(trimmed)) return "Please enter a valid email address.";
+  return null;
+}
+
+export function validateMonitorStep(monitors: MonitorSelections): string | null {
+  const hasAny = monitors.trackPrices || monitors.trackVisibility ||
+    monitors.trackInventory || monitors.trackCollections;
+  if (!hasAny) return "Please select at least one monitor.";
+  return null;
+}
diff --git a/insightops/app/services/productSync.server.ts b/insightops/app/services/productSync.server.ts
index 6e95349..8606c1d 100644
--- a/insightops/app/services/productSync.server.ts
+++ b/insightops/app/services/productSync.server.ts
@@ -98,6 +98,12 @@ export const VARIANTS_PER_PAGE = 100;
  */
 const THROTTLE_THRESHOLD = 200;
 
+/**
+ * Maximum number of consecutive throttle retries before aborting.
+ * Prevents infinite loops under persistent rate limiting.
+ */
+export const MAX_THROTTLE_RETRIES = 10;
+
 /**
  * Wait for Shopify's rate limit bucket to refill enough for the next query.
  * Returns immediately if sufficient budget is available.
@@ -208,8 +214,8 @@ export async function getSyncStatus(shop: string): Promise<{
   if (!syncRecord) {
     // Legacy installs may have ProductCache entries from webhooks without ever creating baseline snapshots.
     // Baselines are what make the *first* product update show a diff.
-    const baselineCount = await db.eventLog.count({
-      where: { shop, topic: "products/snapshot" },
+    const baselineCount = await db.changeEvent.count({
+      where: { shop, eventType: "product_snapshot" },
     });
 
     if (baselineCount > 0) {
@@ -252,6 +258,7 @@ async function fetchAllVariants(
   // Paginate remaining variants
   let variantCursor = product.variants.pageInfo.endCursor;
   let hasMore = true;
+  let variantThrottleRetries = 0;
 
   while (hasMore) {
     const response = await admin.graphql(
@@ -285,11 +292,21 @@ async function fetchAllVariants(
     // Handle throttling on variant fetches
     const retryMs = getThrottleRetryMs(data);
     if (retryMs > 0) {
-      console.log(`[StoreGuard] Throttled on variant fetch, waiting ${retryMs}ms`);
+      variantThrottleRetries++;
+      if (variantThrottleRetries >= MAX_THROTTLE_RETRIES) {
+        console.warn(
+          `[StoreGuard] Variant fetch for product ${product.id} hit max throttle retries (${MAX_THROTTLE_RETRIES}), returning partial variants`
+        );
+        break;
+      }
+      console.log(`[StoreGuard] Throttled on variant fetch (attempt ${variantThrottleRetries}/${MAX_THROTTLE_RETRIES}), waiting ${retryMs}ms`);
       await new Promise((resolve) => setTimeout(resolve, retryMs));
       continue; // Retry the same cursor
     }
 
+    // Reset counter on successful request
+    variantThrottleRetries = 0;
+
     const variantPage = data.data?.product?.variants;
     if (!variantPage) break;
 
@@ -342,6 +359,8 @@ export async function syncProducts(
     update: { status: "syncing", startedAt: new Date(), error: null },
   });
 
+  let throttleRetries = 0;
+
   try {
     while (hasNextPage) {
       const response = await admin.graphql(
@@ -403,11 +422,21 @@ export async function syncProducts(
       // Handle THROTTLED errors — wait and retry the same cursor
       const retryMs = getThrottleRetryMs(data);
       if (retryMs > 0) {
-        console.log(`[StoreGuard] Throttled by Shopify, waiting ${retryMs}ms before retry...`);
+        throttleRetries++;
+        if (throttleRetries >= MAX_THROTTLE_RETRIES) {
+          console.warn(
+            `[StoreGuard] Product sync hit max throttle retries (${MAX_THROTTLE_RETRIES}) for ${shop}, returning partial result (${synced} products synced)`
+          );
+          break;
+        }
+        console.log(`[StoreGuard] Throttled by Shopify (attempt ${throttleRetries}/${MAX_THROTTLE_RETRIES}), waiting ${retryMs}ms before retry...`);
         await new Promise((resolve) => setTimeout(resolve, retryMs));
         continue; // Retry with the same cursor
       }
 
+      // Reset counter on successful request
+      throttleRetries = 0;
+
       const products = data.data?.products;
 
       if (!products) {
@@ -421,7 +450,7 @@ export async function syncProducts(
         data.extensions?.cost?.actualQueryCost ?? 50
       );
 
-      // Upsert products into cache and create baseline EventLog entries
+      // Upsert products into cache and create baseline ChangeEvent entries
       for (const edge of products.edges) {
         const product = edge.node;
         // Extract numeric ID from GID (gid://shopify/Product/123)
@@ -457,20 +486,44 @@ export async function syncProducts(
           inventoryQuantity: v.inventoryQuantity ?? 0,
         }));
 
-        await db.productSnapshot.upsert({
-          where: { shop_id: { shop, id: numericId } },
-          create: {
-            id: numericId,
-            shop,
-            title: product.title,
-            status: product.status.toLowerCase(),
-            variants: JSON.stringify(productSnapshotVariants),
-          },
-          update: {
-            title: product.title,
-            status: product.status.toLowerCase(),
-            variants: JSON.stringify(productSnapshotVariants),
-          },
+        await db.$transaction(async (tx) => {
+          await tx.productSnapshot.upsert({
+            where: { shop_id: { shop, id: numericId } },
+            create: {
+              id: numericId,
+              shop,
+              title: product.title,
+              status: product.status.toLowerCase(),
+            },
+            update: {
+              title: product.title,
+              status: product.status.toLowerCase(),
+            },
+          });
+
+          for (const v of productSnapshotVariants) {
+            await tx.variantSnapshot.upsert({
+              where: {
+                productSnapshotId_shopifyVariantId: {
+                  productSnapshotId: numericId,
+                  shopifyVariantId: String(v.id),
+                },
+              },
+              create: {
+                productSnapshotId: numericId,
+                shop,
+                shopifyVariantId: String(v.id),
+                title: v.title,
+                price: String(v.price),
+                inventoryQuantity: v.inventoryQuantity,
+              },
+              update: {
+                title: v.title,
+                price: String(v.price),
+                inventoryQuantity: v.inventoryQuantity,
+              },
+            });
+          }
         });
 
         // Build a synthetic ProductNode with all variants for snapshot creation
@@ -482,11 +535,11 @@ export async function syncProducts(
           },
         };
 
-        // Ensure we have a baseline snapshot for this product (legacy EventLog).
+        // Ensure we have a baseline snapshot for this product.
         // IMPORTANT: ProductCache can exist from webhooks, but that doesn't mean a baseline snapshot exists.
-        // Only `products/snapshot` events count as baselines.
-        const existingBaseline = await db.eventLog.findFirst({
-          where: { shop, shopifyId: numericId, topic: "products/snapshot" },
+        // Only `product_snapshot` events count as baselines.
+        const existingBaseline = await db.changeEvent.findFirst({
+          where: { shop, entityId: numericId, eventType: "product_snapshot" },
         });
 
         if (!existingBaseline || force) {
@@ -497,31 +550,37 @@ export async function syncProducts(
             changes: [], // No changes for baseline
           });
 
-          // Don't spam multiple baselines unless explicitly forced; even on force, keep it idempotent by upserting a single baseline.
-          // Prisma doesn't support "upsert" without a unique key, so we just create a new baseline when forcing.
-          // (For normal runs, we only create if missing.)
+          // Don't spam multiple baselines unless explicitly forced; even on force, keep it idempotent.
           if (!existingBaseline) {
-            await db.eventLog.create({
+            await db.changeEvent.create({
               data: {
                 shop,
-                shopifyId: numericId,
+                entityType: "product",
+                entityId: numericId,
+                eventType: "product_snapshot",
+                resourceName: product.title,
+                source: "sync_job",
+                importance: "low",
                 topic: "products/snapshot",
                 author: "StoreGuard",
-                message: `Baseline snapshot for "${product.title}"`,
                 diff,
-                webhookId: null,
+                webhookId: `baseline-${numericId}-${Date.now()}`,
               },
             });
           } else if (force) {
-            await db.eventLog.create({
+            await db.changeEvent.create({
               data: {
                 shop,
-                shopifyId: numericId,
+                entityType: "product",
+                entityId: numericId,
+                eventType: "product_snapshot",
+                resourceName: product.title,
+                source: "sync_job",
+                importance: "low",
                 topic: "products/snapshot",
                 author: "StoreGuard",
-                message: `Refreshed baseline snapshot for "${product.title}"`,
                 diff,
-                webhookId: null,
+                webhookId: `baseline-${numericId}-${Date.now()}`,
               },
             });
           }
@@ -588,7 +647,7 @@ export async function needsProductSync(shop: string): Promise<boolean> {
   const syncRecord = await db.shopSync.findUnique({ where: { shop } });
   const snapshotCount = await db.productSnapshot.count({ where: { shop } });
   const cacheCount = await db.productCache.count({ where: { shop } });
-  const baselineCount = await db.eventLog.count({ where: { shop, topic: "products/snapshot" } });
+  const baselineCount = await db.changeEvent.count({ where: { shop, eventType: "product_snapshot" } });
   const expectedCount = Math.max(syncRecord?.syncedProducts ?? 0, cacheCount, baselineCount);
 
   if (syncRecord) {
diff --git a/insightops/app/services/productSync.test.ts b/insightops/app/services/productSync.test.ts
index 00f9c75..bf40eb8 100644
--- a/insightops/app/services/productSync.test.ts
+++ b/insightops/app/services/productSync.test.ts
@@ -1,11 +1,42 @@
-import { describe, it, expect, vi } from "vitest";
+import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
 import {
   waitForRateLimit,
   getThrottleRetryMs,
   PRODUCTS_PER_PAGE,
   VARIANTS_PER_PAGE,
+  MAX_THROTTLE_RETRIES,
+  syncProducts,
 } from "./productSync.server";
 
+vi.mock("../db.server", () => {
+  const mockDb = {
+    shopSync: {
+      upsert: vi.fn().mockResolvedValue({}),
+      update: vi.fn().mockResolvedValue({}),
+    },
+    productCache: {
+      upsert: vi.fn().mockResolvedValue({}),
+    },
+    productSnapshot: {
+      upsert: vi.fn().mockResolvedValue({}),
+    },
+    variantSnapshot: {
+      upsert: vi.fn().mockResolvedValue({}),
+    },
+    changeEvent: {
+      findFirst: vi.fn().mockResolvedValue(null),
+      create: vi.fn().mockResolvedValue({}),
+    },
+    $transaction: vi.fn(async (fn: (tx: unknown) => Promise<void>) => {
+      await fn({
+        productSnapshot: { upsert: vi.fn().mockResolvedValue({}) },
+        variantSnapshot: { upsert: vi.fn().mockResolvedValue({}) },
+      });
+    }),
+  };
+  return { default: mockDb };
+});
+
 describe("PRODUCTS_PER_PAGE", () => {
   it("should be 250 (Shopify max)", () => {
     expect(PRODUCTS_PER_PAGE).toBe(250);
@@ -163,3 +194,163 @@ describe("waitForRateLimit", () => {
     vi.useRealTimers();
   });
 });
+
+describe("MAX_THROTTLE_RETRIES", () => {
+  it("should be 10", () => {
+    expect(MAX_THROTTLE_RETRIES).toBe(10);
+  });
+});
+
+describe("syncProducts throttle retry cap", () => {
+  beforeEach(() => {
+    vi.useFakeTimers();
+    vi.spyOn(console, "log").mockImplementation(() => {});
+    vi.spyOn(console, "warn").mockImplementation(() => {});
+    vi.spyOn(console, "error").mockImplementation(() => {});
+  });
+
+  afterEach(() => {
+    vi.useRealTimers();
+    vi.restoreAllMocks();
+  });
+
+  function makeThrottledResponse() {
+    return {
+      json: () =>
+        Promise.resolve({
+          data: undefined,
+          errors: [{ message: "Throttled", extensions: { code: "THROTTLED" } }],
+          extensions: {
+            cost: {
+              requestedQueryCost: 500,
+              actualQueryCost: 0,
+              throttleStatus: {
+                maximumAvailable: 1000,
+                currentlyAvailable: 0,
+                restoreRate: 50,
+              },
+            },
+          },
+        }),
+    };
+  }
+
+  it("should abort product sync after MAX_THROTTLE_RETRIES consecutive throttles", async () => {
+    const graphqlMock = vi.fn().mockResolvedValue(makeThrottledResponse());
+    const admin = { graphql: graphqlMock };
+
+    const syncPromise = syncProducts("test-shop.myshopify.com", admin);
+
+    // Each throttle retry waits (500/50)*1000 + 1000 = 11000ms
+    // We need to advance through MAX_THROTTLE_RETRIES iterations
+    for (let i = 0; i < MAX_THROTTLE_RETRIES; i++) {
+      await vi.advanceTimersByTimeAsync(11000);
+    }
+
+    const result = await syncPromise;
+
+    expect(result.synced).toBe(0);
+    expect(graphqlMock).toHaveBeenCalledTimes(MAX_THROTTLE_RETRIES);
+    expect(console.warn).toHaveBeenCalledWith(
+      expect.stringContaining("hit max throttle retries")
+    );
+  });
+
+  it("should reset retry counter after a successful request", async () => {
+    let callCount = 0;
+
+    const graphqlMock = vi.fn().mockImplementation(() => {
+      callCount++;
+      // First call: throttled
+      // Second call: success with no more pages
+      if (callCount === 1) {
+        return Promise.resolve(makeThrottledResponse());
+      }
+      return Promise.resolve({
+        json: () =>
+          Promise.resolve({
+            data: {
+              products: {
+                edges: [],
+                pageInfo: { hasNextPage: false, endCursor: null },
+              },
+            },
+            extensions: {
+              cost: {
+                requestedQueryCost: 50,
+                actualQueryCost: 50,
+                throttleStatus: {
+                  maximumAvailable: 1000,
+                  currentlyAvailable: 800,
+                  restoreRate: 50,
+                },
+              },
+            },
+          }),
+      });
+    });
+
+    const admin = { graphql: graphqlMock };
+    const syncPromise = syncProducts("test-shop.myshopify.com", admin);
+
+    // Advance past the throttle wait
+    await vi.advanceTimersByTimeAsync(11000);
+
+    const result = await syncPromise;
+
+    // Should have succeeded after one throttle + one successful request
+    expect(result.synced).toBe(0);
+    expect(result.error).toBeUndefined();
+    expect(graphqlMock).toHaveBeenCalledTimes(2);
+    expect(console.warn).not.toHaveBeenCalled();
+  });
+
+  it("should not abort if throttles are non-consecutive (interspersed with successes)", async () => {
+    let callCount = 0;
+
+    const graphqlMock = vi.fn().mockImplementation(() => {
+      callCount++;
+      // Alternate: throttle, success with products + next page, throttle, success with no next page
+      if (callCount % 2 === 1 && callCount < 8) {
+        return Promise.resolve(makeThrottledResponse());
+      }
+      const hasNextPage = callCount < 7;
+      return Promise.resolve({
+        json: () =>
+          Promise.resolve({
+            data: {
+              products: {
+                edges: [],
+                pageInfo: { hasNextPage, endCursor: hasNextPage ? "cursor" : null },
+              },
+            },
+            extensions: {
+              cost: {
+                requestedQueryCost: 50,
+                actualQueryCost: 50,
+                throttleStatus: {
+                  maximumAvailable: 1000,
+                  currentlyAvailable: 800,
+                  restoreRate: 50,
+                },
+              },
+            },
+          }),
+      });
+    });
+
+    const admin = { graphql: graphqlMock };
+    const syncPromise = syncProducts("test-shop.myshopify.com", admin);
+
+    // Advance through multiple throttle waits
+    for (let i = 0; i < 10; i++) {
+      await vi.advanceTimersByTimeAsync(11000);
+    }
+
+    const result = await syncPromise;
+
+    // Should complete without hitting max retries
+    expect(result.error).toBeUndefined();
+    expect(console.warn).not.toHaveBeenCalled();
+  });
+});
diff --git a/insightops/app/services/shopService.server.ts b/insightops/app/services/shopService.server.ts
index a11cccd..431c9f6 100644
--- a/insightops/app/services/shopService.server.ts
+++ b/insightops/app/services/shopService.server.ts
@@ -7,6 +7,10 @@ export interface ShopSettings {
   trackVisibility: boolean;
   trackInventory: boolean;
   trackThemes: boolean;
+  trackCollections: boolean;
+  trackDiscounts: boolean;
+  trackAppPermissions: boolean;
+  trackDomains: boolean;
   lowStockThreshold: number;
   instantAlerts: boolean;
 }
@@ -27,6 +31,8 @@ export async function getOrCreateShop(shopDomain: string): Promise<ShopSettings>
       trackVisibility: true,
       trackInventory: true,
       trackThemes: false, // Pro only by default
+      trackCollections: true,
+      trackDiscounts: false, // Pro only
       installedAt: new Date(),
     },
     update: {
@@ -44,6 +50,10 @@ export async function getOrCreateShop(shopDomain: string): Promise<ShopSettings>
     trackVisibility: shop.trackVisibility,
     trackInventory: shop.trackInventory,
     trackThemes: shop.trackThemes,
+    trackCollections: shop.trackCollections,
+    trackDiscounts: shop.trackDiscounts,
+    trackAppPermissions: shop.trackAppPermissions,
+    trackDomains: shop.trackDomains,
     lowStockThreshold: shop.lowStockThreshold,
     instantAlerts: shop.instantAlerts,
   };
@@ -67,6 +77,10 @@ export async function getShopSettings(shopDomain: string): Promise<ShopSettings
     trackVisibility: shop.trackVisibility,
     trackInventory: shop.trackInventory,
     trackThemes: shop.trackThemes,
+    trackCollections: shop.trackCollections,
+    trackDiscounts: shop.trackDiscounts,
+    trackAppPermissions: shop.trackAppPermissions,
+    trackDomains: shop.trackDomains,
     lowStockThreshold: shop.lowStockThreshold,
     instantAlerts: shop.instantAlerts,
   };
@@ -95,6 +109,27 @@ export async function updateShopSettings(
     trackThemes = false;
   }
 
+  // Discounts are Pro-only
+  let trackDiscounts = settings.trackDiscounts ?? shop.trackDiscounts;
+  if (shop.plan !== "pro" && trackDiscounts) {
+    console.log(`[StoreGuard] Blocking trackDiscounts for free plan: ${shopDomain}`);
+    trackDiscounts = false;
+  }
+
+  // App permissions are Pro-only
+  let trackAppPermissions = settings.trackAppPermissions ?? shop.trackAppPermissions;
+  if (shop.plan !== "pro" && trackAppPermissions) {
+    console.log(`[StoreGuard] Blocking trackAppPermissions for free plan: ${shopDomain}`);
+    trackAppPermissions = false;
+  }
+
+  // Domains are Pro-only
+  let trackDomains = settings.trackDomains ?? shop.trackDomains;
+  if (shop.plan !== "pro" && trackDomains) {
+    console.log(`[StoreGuard] Blocking trackDomains for free plan: ${shopDomain}`);
+    trackDomains = false;
+  }
+
   // Instant alerts are Pro-only
   let instantAlerts = settings.instantAlerts ?? shop.instantAlerts;
   if (shop.plan !== "pro" && instantAlerts) {
@@ -115,6 +150,10 @@ export async function updateShopSettings(
       trackVisibility: settings.trackVisibility ?? shop.trackVisibility,
       trackInventory: settings.trackInventory ?? shop.trackInventory,
       trackThemes,
+      trackCollections: settings.trackCollections ?? shop.trackCollections,
+      trackDiscounts,
+      trackAppPermissions,
+      trackDomains,
       lowStockThreshold,
       instantAlerts,
     },
@@ -129,6 +168,10 @@ export async function updateShopSettings(
     trackVisibility: updated.trackVisibility,
     trackInventory: updated.trackInventory,
     trackThemes: updated.trackThemes,
+    trackCollections: updated.trackCollections,
+    trackDiscounts: updated.trackDiscounts,
+    trackAppPermissions: updated.trackAppPermissions,
+    trackDomains: updated.trackDomains,
     lowStockThreshold: updated.lowStockThreshold,
     instantAlerts: updated.instantAlerts,
   };
@@ -173,6 +216,9 @@ export async function downgradeShopToFree(shopDomain: string): Promise<void> {
     data: {
       plan: "free",
       trackThemes: false, // Disable Pro-only features
+      trackDiscounts: false, // Disable Pro-only features
+      trackAppPermissions: false, // Disable Pro-only features
+      trackDomains: false, // Disable Pro-only features
       instantAlerts: false, // Disable Pro-only features
     },
   });
@@ -195,7 +241,7 @@ export async function isProPlan(shopDomain: string): Promise<boolean> {
  */
 export async function canTrackFeature(
   shopDomain: string,
-  feature: "prices" | "visibility" | "inventory" | "themes"
+  feature: "prices" | "visibility" | "inventory" | "themes" | "collections" | "discounts" | "app_permissions" | "domains"
 ): Promise<boolean> {
   const shop = await db.shop.findUnique({
     where: { shopifyDomain: shopDomain },
@@ -212,6 +258,14 @@ export async function canTrackFeature(
       return shop.trackInventory;
     case "themes":
       return shop.plan === "pro" && shop.trackThemes;
+    case "collections":
+      return shop.trackCollections;
+    case "discounts":
+      return shop.plan === "pro" && shop.trackDiscounts;
+    case "app_permissions":
+      return shop.plan === "pro" && shop.trackAppPermissions;
+    case "domains":
+      return shop.plan === "pro" && shop.trackDomains;
     default:
       return false;
   }
@@ -255,3 +309,41 @@ export async function getShopAlertEmail(shopDomain: string): Promise<string | nu
 
   return shop?.alertEmail ?? null;
 }
+
+/**
+ * Check if a shop has completed onboarding.
+ */
+export async function isOnboarded(shopDomain: string): Promise<boolean> {
+  const shop = await db.shop.findUnique({
+    where: { shopifyDomain: shopDomain },
+    select: { onboardedAt: true },
+  });
+  return shop?.onboardedAt !== null && shop?.onboardedAt !== undefined;
+}
+
+/**
+ * Mark a shop as onboarded and save initial settings from the onboarding flow.
+ */
+export async function completeOnboarding(
+  shopDomain: string,
+  settings: {
+    alertEmail: string | null;
+    trackPrices: boolean;
+    trackVisibility: boolean;
+    trackInventory: boolean;
+    trackCollections: boolean;
+  }
+): Promise<void> {
+  await db.shop.update({
+    where: { shopifyDomain: shopDomain },
+    data: {
+      alertEmail: settings.alertEmail,
+      trackPrices: settings.trackPrices,
+      trackVisibility: settings.trackVisibility,
+      trackInventory: settings.trackInventory,
+      trackCollections: settings.trackCollections,
+      onboardedAt: new Date(),
+    },
+  });
+  console.log(`[StoreGuard] Onboarding completed for ${shopDomain}`);
+}
diff --git a/insightops/prisma/migrations/20260218120000_unify_event_pipeline_drop_eventlog/migration.sql b/insightops/prisma/migrations/20260218120000_unify_event_pipeline_drop_eventlog/migration.sql
new file mode 100644
index 0000000..d2a8e22
--- /dev/null
+++ b/insightops/prisma/migrations/20260218120000_unify_event_pipeline_drop_eventlog/migration.sql
@@ -0,0 +1,9 @@
+-- Unify EventLog + ChangeEvent into single event pipeline
+-- EventLog is no longer referenced anywhere in the codebase.
+-- All audit/activity logging already uses ChangeEvent with topic, diff, author fields.
+
+-- Step 1: Make webhookId nullable on ChangeEvent (activity-only events don't need dedup)
+ALTER TABLE "ChangeEvent" ALTER COLUMN "webhookId" DROP NOT NULL;
+
+-- Step 2: Drop EventLog table and its indexes
+DROP TABLE IF EXISTS "EventLog";
diff --git a/insightops/prisma/migrations/20260218130000_normalize_variant_snapshots/migration.sql b/insightops/prisma/migrations/20260218130000_normalize_variant_snapshots/migration.sql
new file mode 100644
index 0000000..a72c59f
--- /dev/null
+++ b/insightops/prisma/migrations/20260218130000_normalize_variant_snapshots/migration.sql
@@ -0,0 +1,37 @@
+-- CreateTable
+CREATE TABLE "VariantSnapshot" (
+    "id" TEXT NOT NULL,
+    "shopifyVariantId" TEXT NOT NULL,
+    "productSnapshotId" TEXT NOT NULL,
+    "shop" TEXT NOT NULL,
+    "title" TEXT NOT NULL,
+    "price" TEXT NOT NULL,
+    "inventoryQuantity" INTEGER NOT NULL DEFAULT 0,
+
+    CONSTRAINT "VariantSnapshot_pkey" PRIMARY KEY ("id")
+);
+
+-- Migrate existing JSON data to rows
+INSERT INTO "VariantSnapshot" ("id", "shopifyVariantId", "productSnapshotId", "shop", "title", "price", "inventoryQuantity")
+SELECT
+    gen_random_uuid()::text,
+    elem->>'id',
+    "ProductSnapshot"."id",
+    "ProductSnapshot"."shop",
+    COALESCE(elem->>'title', 'Default Title'),
+    COALESCE(elem->>'price', '0.00'),
+    COALESCE((elem->>'inventoryQuantity')::integer, 0)
+FROM "ProductSnapshot",
+     json_array_elements("ProductSnapshot"."variants"::json) AS elem
+WHERE "ProductSnapshot"."variants" IS NOT NULL
+  AND "ProductSnapshot"."variants" != '';
+
+-- Drop old column
+ALTER TABLE "ProductSnapshot" DROP COLUMN IF EXISTS "variants";
+
+-- CreateIndex
+CREATE UNIQUE INDEX "VariantSnapshot_productSnapshotId_shopifyVariantId_key" ON "VariantSnapshot"("productSnapshotId", "shopifyVariantId");
+CREATE INDEX "VariantSnapshot_shop_shopifyVariantId_idx" ON "VariantSnapshot"("shop", "shopifyVariantId");
+
+-- AddForeignKey
+ALTER TABLE "VariantSnapshot" ADD CONSTRAINT "VariantSnapshot_productSnapshotId_fkey" FOREIGN KEY ("productSnapshotId") REFERENCES "ProductSnapshot"("id") ON DELETE CASCADE ON UPDATE CASCADE;
diff --git a/insightops/prisma/migrations/20260218140000_add_shop_onboarded_at/migration.sql b/insightops/prisma/migrations/20260218140000_add_shop_onboarded_at/migration.sql
new file mode 100644
index 0000000..91e58de
--- /dev/null
+++ b/insightops/prisma/migrations/20260218140000_add_shop_onboarded_at/migration.sql
@@ -0,0 +1,2 @@
+-- AlterTable
+ALTER TABLE "Shop" ADD COLUMN "onboardedAt" TIMESTAMP(3);
diff --git a/insightops/prisma/schema.prisma b/insightops/prisma/schema.prisma
index ba5f87d..d8ff111 100644
--- a/insightops/prisma/schema.prisma
+++ b/insightops/prisma/schema.prisma
@@ -41,9 +41,14 @@ model Shop {
   trackVisibility Boolean   @default(true)
   trackInventory  Boolean   @default(true)
   trackThemes     Boolean   @default(false) // Pro only
+  trackCollections Boolean  @default(true) // Collection monitoring (free plan)
+  trackDiscounts  Boolean   @default(false) // Pro only
+  trackAppPermissions Boolean @default(false) // Pro only
+  trackDomains    Boolean   @default(false) // Pro only
   lowStockThreshold Int     @default(5) // Alert when inventory drops below this
   instantAlerts   Boolean   @default(false) // Send alerts immediately (Pro only)
   installedAt     DateTime  @default(now())
+  onboardedAt     DateTime? // When onboarding was completed (null = not onboarded)
   uninstalledAt   DateTime?
   // Stripe billing
   stripeCustomerId     String?  @unique // Stripe customer ID (cus_xxx)
@@ -65,14 +70,19 @@ model ChangeEvent {
   source       String    @default("webhook") // "webhook" | "sync_job" | "manual"
   importance   String    @default("medium") // "high" | "medium" | "low"
   groupId      String?   // For grouping related changes (e.g. bulk edit session)
-  webhookId    String    @unique // Deduplication
+  webhookId    String?   @unique // Deduplication (nullable for activity-only events)
   contextData  String?   // JSON: sales velocity, revenue impact, business context
+  topic        String?   // Webhook topic e.g. "products/update" (unified from EventLog)
+  diff         String?   // JSON snapshot/change data (unified from EventLog)
+  author       String?   // Who made the change (from Shopify Events API)
+  instantAlertSentAt DateTime? // When instant alert email was sent (null = not sent)
 
   @@index([shop])
   @@index([shop, detectedAt])
   @@index([shop, eventType])
   @@index([digestedAt])
   @@index([shop, entityType, entityId])
+  @@index([shop, instantAlertSentAt])
 }
 
 // Product state snapshot for change detection
@@ -81,27 +91,26 @@ model ProductSnapshot {
   shop      String
   title     String
   status    String   // "active" | "draft" | "archived"
-  variants  String   // JSON: [{id, title, price, inventoryQuantity}]
   updatedAt DateTime @updatedAt
+  variants  VariantSnapshot[]
 
   @@unique([shop, id])
   @@index([shop])
 }
 
-model EventLog {
-  id          String   @id @default(uuid())
-  shop        String   // The store URL
-  shopifyId   String   // The Resource ID (e.g., Product ID)
-  topic       String   // e.g., "products/update"
-  author      String?  // The "Blame" retrieved via Events API
-  message     String   // Description of change
-  diff        String?  // JSON string: { old: value, new: value }
-  timestamp   DateTime @default(now())
-  webhookId   String?  @unique // Shopify webhook delivery ID for deduplication
-
-  @@index([shop])
-  @@index([shop, timestamp])
-  @@index([shop, shopifyId, topic])
+// Individual variant snapshot for change detection (normalized from JSON blob)
+model VariantSnapshot {
+  id                 String          @id @default(uuid())
+  shopifyVariantId   String          // Shopify variant ID (numeric string)
+  productSnapshotId  String          // FK to ProductSnapshot
+  shop               String          // Denormalized for efficient queries
+  title              String
+  price              String
+  inventoryQuantity  Int             @default(0)
+  productSnapshot    ProductSnapshot @relation(fields: [productSnapshotId], references: [id], onDelete: Cascade)
+
+  @@unique([productSnapshotId, shopifyVariantId])
+  @@index([shop, shopifyVariantId])
 }
 
 // Lightweight product cache for resolving names on delete
