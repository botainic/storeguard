diff --git a/insightops/app/routes/app._index.tsx b/insightops/app/routes/app._index.tsx
index 29b647c..b179925 100644
--- a/insightops/app/routes/app._index.tsx
+++ b/insightops/app/routes/app._index.tsx
@@ -1,17 +1,585 @@
-import type { LoaderFunctionArgs, HeadersFunction } from "react-router";
-import { redirect, useRouteError } from "react-router";
+import type { LoaderFunctionArgs, ActionFunctionArgs, HeadersFunction } from "react-router";
+import { redirect, useLoaderData, useActionData, useNavigation, useRouteError } from "react-router";
 import { boundary } from "@shopify/shopify-app-react-router/server";
+import { useState } from "react";
 import { authenticate } from "../shopify.server";
+import { isOnboarded, completeOnboarding, getOrCreateShop } from "../services/shopService.server";
+import { getSyncStatus } from "../services/productSync.server";
+import {
+  ONBOARDING_STEPS,
+  type OnboardingStep,
+  type MonitorSelections,
+  DEFAULT_MONITORS,
+  validateEmailStep,
+  validateMonitorStep,
+} from "../services/onboarding.utils";
 
-// StoreGuard: Redirect to Changes page (the main view)
-// Uses server-side redirect to preserve all Shopify URL params
 export const loader = async ({ request }: LoaderFunctionArgs) => {
-  await authenticate.admin(request);
+  const { session } = await authenticate.admin(request);
 
-  // Preserve all query params when redirecting to /app/changes
-  const url = new URL(request.url);
-  const params = url.searchParams.toString();
-  throw redirect(`/app/changes${params ? `?${params}` : ""}`);
+  await getOrCreateShop(session.shop);
+
+  const onboarded = await isOnboarded(session.shop);
+
+  if (onboarded) {
+    const url = new URL(request.url);
+    const params = url.searchParams.toString();
+    throw redirect(`/app/changes${params ? `?${params}` : ""}`);
+  }
+
+  const syncStatus = await getSyncStatus(session.shop);
+
+  return { shop: session.shop, syncStatus };
+};
+
+interface ActionResponse {
+  success: boolean;
+  error?: string;
+}
+
+export const action = async ({ request }: ActionFunctionArgs): Promise<ActionResponse> => {
+  const { session } = await authenticate.admin(request);
+  const formData = await request.formData();
+  const intent = formData.get("intent") as string;
+
+  if (intent === "complete") {
+    const alertEmail = (formData.get("alertEmail") as string)?.trim() || null;
+    const trackPrices = formData.get("trackPrices") === "true";
+    const trackVisibility = formData.get("trackVisibility") === "true";
+    const trackInventory = formData.get("trackInventory") === "true";
+    const trackCollections = formData.get("trackCollections") === "true";
+
+    try {
+      await completeOnboarding(session.shop, {
+        alertEmail,
+        trackPrices,
+        trackVisibility,
+        trackInventory,
+        trackCollections,
+      });
+      return { success: true };
+    } catch (error) {
+      console.error("[StoreGuard] Onboarding completion failed:", error);
+      return { success: false, error: "Failed to save. Please try again." };
+    }
+  }
+
+  return { success: false, error: "Unknown action" };
+};
+
+export default function Onboarding() {
+  const { syncStatus } = useLoaderData<typeof loader>();
+  const actionData = useActionData<ActionResponse>();
+  const navigation = useNavigation();
+  const isSubmitting = navigation.state === "submitting";
+
+  const [step, setStep] = useState<OnboardingStep>("welcome");
+  const [email, setEmail] = useState("");
+  const [emailError, setEmailError] = useState<string | null>(null);
+  const [monitors, setMonitors] = useState<MonitorSelections>(DEFAULT_MONITORS);
+  const [monitorError, setMonitorError] = useState<string | null>(null);
+
+  const stepIndex = ONBOARDING_STEPS.indexOf(step);
+
+  const goNext = () => {
+    if (step === "email") {
+      const err = validateEmailStep(email);
+      if (err) {
+        setEmailError(err);
+        return;
+      }
+    }
+    if (step === "monitors") {
+      const err = validateMonitorStep(monitors);
+      if (err) {
+        setMonitorError(err);
+        return;
+      }
+    }
+    const nextIdx = stepIndex + 1;
+    if (nextIdx < ONBOARDING_STEPS.length) {
+      setStep(ONBOARDING_STEPS[nextIdx]);
+    }
+  };
+
+  const goBack = () => {
+    const prevIdx = stepIndex - 1;
+    if (prevIdx >= 0) {
+      setStep(ONBOARDING_STEPS[prevIdx]);
+    }
+  };
+
+  // After action succeeds, redirect
+  if (actionData?.success) {
+    window.location.href = "/app/changes";
+    return (
+      <div style={{ ...containerStyle, textAlign: "center", paddingTop: 120 }}>
+        <p style={{ fontSize: 14, color: "#6b7280" }}>Redirecting to your dashboard...</p>
+      </div>
+    );
+  }
+
+  return (
+    <div style={containerStyle}>
+      {/* Progress dots */}
+      <div style={{ display: "flex", justifyContent: "center", gap: 8, marginBottom: 32 }}>
+        {ONBOARDING_STEPS.map((s, i) => (
+          <div
+            key={s}
+            style={{
+              width: 8,
+              height: 8,
+              borderRadius: "50%",
+              background: i <= stepIndex ? "#000" : "#d1d5db",
+              transition: "background 0.2s",
+            }}
+          />
+        ))}
+      </div>
+
+      {step === "welcome" && <WelcomeStep onNext={goNext} />}
+      {step === "email" && (
+        <EmailStep
+          email={email}
+          setEmail={(v) => { setEmail(v); setEmailError(null); }}
+          error={emailError}
+          onNext={goNext}
+          onBack={goBack}
+        />
+      )}
+      {step === "monitors" && (
+        <MonitorStep
+          monitors={monitors}
+          setMonitors={(v) => { setMonitors(v); setMonitorError(null); }}
+          error={monitorError}
+          onNext={goNext}
+          onBack={goBack}
+        />
+      )}
+      {step === "sync" && (
+        <SyncStep
+          syncStatus={syncStatus}
+          onNext={goNext}
+          onBack={goBack}
+        />
+      )}
+      {step === "done" && (
+        <DoneStep
+          email={email}
+          monitors={monitors}
+          isSubmitting={isSubmitting}
+          error={actionData?.error ?? null}
+          onBack={goBack}
+        />
+      )}
+    </div>
+  );
+}
+
+// --- Step Components ---
+
+function WelcomeStep({ onNext }: { onNext: () => void }) {
+  return (
+    <div style={cardStyle}>
+      <div style={{ textAlign: "center" }}>
+        <div style={{ marginBottom: 16 }}>
+          <svg width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#000" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round">
+            <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z" />
+          </svg>
+        </div>
+        <h1 style={{ fontSize: 22, fontWeight: 600, color: "#111827", marginBottom: 8 }}>
+          Welcome to StoreGuard
+        </h1>
+        <p style={{ fontSize: 14, color: "#6b7280", lineHeight: 1.6, maxWidth: 360, margin: "0 auto 24px" }}>
+          StoreGuard monitors your store for changes that cost you money — price errors, hidden
+          products, stockouts, and more. {"Let's"} get you set up in under a minute.
+        </p>
+        <button type="button" onClick={onNext} style={primaryButtonStyle}>
+          Get started
+        </button>
+      </div>
+    </div>
+  );
+}
+
+function EmailStep({
+  email,
+  setEmail,
+  error,
+  onNext,
+  onBack,
+}: {
+  email: string;
+  setEmail: (v: string) => void;
+  error: string | null;
+  onNext: () => void;
+  onBack: () => void;
+}) {
+  return (
+    <div style={cardStyle}>
+      <h2 style={headingStyle}>Where should we send alerts?</h2>
+      <p style={subStyle}>
+        {"You'll"} receive a daily digest of all detected changes, plus instant alerts if you upgrade later.
+      </p>
+
+      <input
+        type="email"
+        value={email}
+        onChange={(e) => setEmail(e.target.value)}
+        onKeyDown={(e) => { if (e.key === "Enter") { e.preventDefault(); onNext(); } }}
+        placeholder="you@example.com"
+        style={{
+          width: "100%",
+          padding: "10px 12px",
+          fontSize: 14,
+          border: error ? "1px solid #dc2626" : "1px solid #d1d5db",
+          borderRadius: 8,
+          outline: "none",
+          boxSizing: "border-box",
+          marginBottom: error ? 4 : 0,
+        }}
+      />
+      {error && <p style={{ color: "#dc2626", fontSize: 12, marginTop: 4 }}>{error}</p>}
+
+      <div style={buttonRowStyle}>
+        <button type="button" onClick={onBack} style={secondaryButtonStyle}>Back</button>
+        <button type="button" onClick={onNext} style={primaryButtonStyle}>Continue</button>
+      </div>
+    </div>
+  );
+}
+
+function MonitorStep({
+  monitors,
+  setMonitors,
+  error,
+  onNext,
+  onBack,
+}: {
+  monitors: MonitorSelections;
+  setMonitors: (v: MonitorSelections) => void;
+  error: string | null;
+  onNext: () => void;
+  onBack: () => void;
+}) {
+  const toggle = (key: keyof MonitorSelections) => {
+    setMonitors({ ...monitors, [key]: !monitors[key] });
+  };
+
+  return (
+    <div style={cardStyle}>
+      <h2 style={headingStyle}>What should we watch?</h2>
+      <p style={subStyle}>
+        Choose which changes to monitor. You can adjust these later in Settings.
+      </p>
+
+      <div style={{ display: "flex", flexDirection: "column", gap: 2, marginBottom: 16 }}>
+        <MonitorOption
+          checked={monitors.trackPrices}
+          onChange={() => toggle("trackPrices")}
+          label="Price changes"
+          description="Alert when variant prices are modified"
+        />
+        <MonitorOption
+          checked={monitors.trackVisibility}
+          onChange={() => toggle("trackVisibility")}
+          label="Visibility changes"
+          description="Alert when products are published, hidden, or archived"
+        />
+        <MonitorOption
+          checked={monitors.trackInventory}
+          onChange={() => toggle("trackInventory")}
+          label="Inventory alerts"
+          description="Alert on low stock and out of stock"
+        />
+        <MonitorOption
+          checked={monitors.trackCollections}
+          onChange={() => toggle("trackCollections")}
+          label="Collection changes"
+          description="Alert when collections are created, updated, or deleted"
+        />
+      </div>
+
+      {error && <p style={{ color: "#dc2626", fontSize: 12, marginBottom: 8 }}>{error}</p>}
+
+      <div style={buttonRowStyle}>
+        <button type="button" onClick={onBack} style={secondaryButtonStyle}>Back</button>
+        <button type="button" onClick={onNext} style={primaryButtonStyle}>Continue</button>
+      </div>
+    </div>
+  );
+}
+
+function MonitorOption({
+  checked,
+  onChange,
+  label,
+  description,
+}: {
+  checked: boolean;
+  onChange: () => void;
+  label: string;
+  description: string;
+}) {
+  return (
+    <label
+      aria-label={label}
+      style={{
+        display: "flex",
+        alignItems: "flex-start",
+        gap: 10,
+        padding: "10px 0",
+        borderBottom: "1px solid #f3f4f6",
+        cursor: "pointer",
+      }}
+    >
+      <input
+        type="checkbox"
+        checked={checked}
+        onChange={onChange}
+        style={{ width: 18, height: 18, marginTop: 1, accentColor: "#000", cursor: "pointer" }}
+      />
+      <div>
+        <div style={{ fontSize: 13, fontWeight: 500, color: "#111827" }}>{label}</div>
+        <div style={{ fontSize: 12, color: "#6b7280", marginTop: 1 }}>{description}</div>
+      </div>
+    </label>
+  );
+}
+
+function SyncStep({
+  syncStatus,
+  onNext,
+  onBack,
+}: {
+  syncStatus: { status: string; syncedProducts: number; totalProducts: number | null };
+  onNext: () => void;
+  onBack: () => void;
+}) {
+  const isSyncing = syncStatus.status === "syncing" || syncStatus.status === "pending";
+  const isCompleted = syncStatus.status === "completed";
+  const isFailed = syncStatus.status === "failed";
+
+  return (
+    <div style={cardStyle}>
+      <h2 style={headingStyle}>Syncing your products</h2>
+      <p style={subStyle}>
+        StoreGuard is creating baseline snapshots of your products so it can detect future changes.
+      </p>
+
+      <div style={{
+        padding: 16,
+        background: "#f9fafb",
+        borderRadius: 8,
+        textAlign: "center",
+        marginBottom: 16,
+      }}>
+        {isSyncing && (
+          <>
+            <div style={spinnerStyle} />
+            <p style={{ fontSize: 14, fontWeight: 500, color: "#111827", marginTop: 12 }}>
+              Syncing products...
+            </p>
+            <p style={{ fontSize: 13, color: "#6b7280", marginTop: 4 }}>
+              {syncStatus.syncedProducts} products synced
+              {syncStatus.totalProducts ? ` of ${syncStatus.totalProducts}` : ""}
+            </p>
+          </>
+        )}
+        {isCompleted && (
+          <>
+            <svg width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="#16a34a" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
+              <path d="M20 6L9 17l-5-5" />
+            </svg>
+            <p style={{ fontSize: 14, fontWeight: 500, color: "#111827", marginTop: 8 }}>
+              Sync complete
+            </p>
+            <p style={{ fontSize: 13, color: "#6b7280", marginTop: 4 }}>
+              {syncStatus.syncedProducts} products ready for monitoring
+            </p>
+          </>
+        )}
+        {isFailed && (
+          <>
+            <p style={{ fontSize: 14, fontWeight: 500, color: "#dc2626" }}>
+              Sync encountered an issue
+            </p>
+            <p style={{ fontSize: 13, color: "#6b7280", marginTop: 4 }}>
+              {"Don't"} worry — StoreGuard will retry automatically. You can continue setup.
+            </p>
+          </>
+        )}
+        {syncStatus.status === "not_started" && (
+          <>
+            <p style={{ fontSize: 14, fontWeight: 500, color: "#111827" }}>
+              Sync will start automatically
+            </p>
+            <p style={{ fontSize: 13, color: "#6b7280", marginTop: 4 }}>
+              Your products will be synced in the background. You can continue setup.
+            </p>
+          </>
+        )}
+      </div>
+
+      <div style={buttonRowStyle}>
+        <button type="button" onClick={onBack} style={secondaryButtonStyle}>Back</button>
+        <button type="button" onClick={onNext} style={primaryButtonStyle}>
+          Continue
+        </button>
+      </div>
+    </div>
+  );
+}
+
+function DoneStep({
+  email,
+  monitors,
+  isSubmitting,
+  error,
+  onBack,
+}: {
+  email: string;
+  monitors: MonitorSelections;
+  isSubmitting: boolean;
+  error: string | null;
+  onBack: () => void;
+}) {
+  const activeMonitors = [
+    monitors.trackPrices && "Price changes",
+    monitors.trackVisibility && "Visibility changes",
+    monitors.trackInventory && "Inventory alerts",
+    monitors.trackCollections && "Collection changes",
+  ].filter(Boolean);
+
+  return (
+    <div style={cardStyle}>
+      <h2 style={headingStyle}>{"You're"} all set</h2>
+      <p style={subStyle}>
+        {"Here's"} a summary of your setup. You can change these anytime in Settings.
+      </p>
+
+      <div style={{ marginBottom: 20 }}>
+        <div style={summaryRowStyle}>
+          <span style={summaryLabelStyle}>Alert email</span>
+          <span style={{ fontSize: 13, color: "#111827" }}>{email}</span>
+        </div>
+        <div style={summaryRowStyle}>
+          <span style={summaryLabelStyle}>Monitors</span>
+          <span style={{ fontSize: 13, color: "#111827" }}>{activeMonitors.join(", ")}</span>
+        </div>
+      </div>
+
+      {error && (
+        <p style={{ color: "#dc2626", fontSize: 12, marginBottom: 8 }}>{error}</p>
+      )}
+
+      <form method="post">
+        <input type="hidden" name="intent" value="complete" />
+        <input type="hidden" name="alertEmail" value={email} />
+        <input type="hidden" name="trackPrices" value={String(monitors.trackPrices)} />
+        <input type="hidden" name="trackVisibility" value={String(monitors.trackVisibility)} />
+        <input type="hidden" name="trackInventory" value={String(monitors.trackInventory)} />
+        <input type="hidden" name="trackCollections" value={String(monitors.trackCollections)} />
+
+        <div style={buttonRowStyle}>
+          <button type="button" onClick={onBack} disabled={isSubmitting} style={secondaryButtonStyle}>
+            Back
+          </button>
+          <button type="submit" disabled={isSubmitting} style={{
+            ...primaryButtonStyle,
+            opacity: isSubmitting ? 0.6 : 1,
+            cursor: isSubmitting ? "not-allowed" : "pointer",
+          }}>
+            {isSubmitting ? "Finishing..." : "Start protecting my store"}
+          </button>
+        </div>
+      </form>
+    </div>
+  );
+}
+
+// --- Styles ---
+
+const containerStyle: React.CSSProperties = {
+  maxWidth: 480,
+  margin: "0 auto",
+  padding: "40px 16px",
+  fontFamily: "system-ui, sans-serif",
+};
+
+const cardStyle: React.CSSProperties = {
+  background: "#fff",
+  border: "1px solid #e5e7eb",
+  borderRadius: 12,
+  padding: "24px 20px",
+};
+
+const headingStyle: React.CSSProperties = {
+  fontSize: 18,
+  fontWeight: 600,
+  color: "#111827",
+  marginBottom: 6,
+};
+
+const subStyle: React.CSSProperties = {
+  fontSize: 13,
+  color: "#6b7280",
+  lineHeight: 1.5,
+  marginBottom: 20,
+};
+
+const buttonRowStyle: React.CSSProperties = {
+  display: "flex",
+  justifyContent: "space-between",
+  gap: 12,
+  marginTop: 20,
+};
+
+const primaryButtonStyle: React.CSSProperties = {
+  background: "#000",
+  color: "#fff",
+  padding: "10px 20px",
+  fontSize: 14,
+  fontWeight: 500,
+  border: "none",
+  borderRadius: 8,
+  cursor: "pointer",
+  minHeight: 44,
+};
+
+const secondaryButtonStyle: React.CSSProperties = {
+  background: "#fff",
+  color: "#374151",
+  padding: "10px 16px",
+  fontSize: 14,
+  fontWeight: 500,
+  border: "1px solid #d1d5db",
+  borderRadius: 8,
+  cursor: "pointer",
+  minHeight: 44,
+};
+
+const summaryRowStyle: React.CSSProperties = {
+  display: "flex",
+  justifyContent: "space-between",
+  padding: "10px 0",
+  borderBottom: "1px solid #f3f4f6",
+};
+
+const summaryLabelStyle: React.CSSProperties = {
+  fontSize: 13,
+  color: "#6b7280",
+  fontWeight: 500,
+};
+
+const spinnerStyle: React.CSSProperties = {
+  width: 24,
+  height: 24,
+  border: "3px solid #e5e7eb",
+  borderTop: "3px solid #000",
+  borderRadius: "50%",
+  animation: "spin 1s linear infinite",
+  margin: "0 auto",
 };
 
 // Required for Shopify to handle exit-iframe redirect via App Bridge
diff --git a/insightops/app/routes/app.changes.test.ts b/insightops/app/routes/app.changes.test.ts
index 69dbc6d..3ad303a 100644
--- a/insightops/app/routes/app.changes.test.ts
+++ b/insightops/app/routes/app.changes.test.ts
@@ -12,6 +12,15 @@ const eventConfig: Record<string, { label: string; color: string }> = {
   inventory_low: { label: "Low Stock", color: "#f97316" },
   inventory_zero: { label: "Out of Stock", color: "#e74c3c" },
   theme_publish: { label: "Theme Published", color: "#3498db" },
+  collection_created: { label: "Collection Created", color: "#10b981" },
+  collection_updated: { label: "Collection Updated", color: "#10b981" },
+  collection_deleted: { label: "Collection Deleted", color: "#e74c3c" },
+  discount_created: { label: "Discount Created", color: "#8b5cf6" },
+  discount_changed: { label: "Discount Changed", color: "#8b5cf6" },
+  discount_deleted: { label: "Discount Deleted", color: "#e74c3c" },
+  app_permissions_changed: { label: "App Permissions", color: "#6366f1" },
+  domain_changed: { label: "Domain Changed", color: "#0891b2" },
+  domain_removed: { label: "Domain Removed", color: "#e74c3c" },
 };
 
 const importanceConfig: Record<string, { label: string; color: string }> = {
@@ -27,6 +36,15 @@ const ALL_EVENT_TYPES = [
   "inventory_low",
   "inventory_zero",
   "theme_publish",
+  "collection_created",
+  "collection_updated",
+  "collection_deleted",
+  "discount_created",
+  "discount_changed",
+  "discount_deleted",
+  "app_permissions_changed",
+  "domain_changed",
+  "domain_removed",
 ];
 
 const ALL_IMPORTANCE_LEVELS = ["high", "medium", "low"];
diff --git a/insightops/app/routes/app.changes.tsx b/insightops/app/routes/app.changes.tsx
index d824c80..a0ef45f 100644
--- a/insightops/app/routes/app.changes.tsx
+++ b/insightops/app/routes/app.changes.tsx
@@ -42,6 +42,15 @@ const eventConfig: Record<string, { label: string; color: string }> = {
   inventory_low: { label: "Low Stock", color: "#f97316" },
   inventory_zero: { label: "Out of Stock", color: "#e74c3c" },
   theme_publish: { label: "Theme Published", color: "#3498db" },
+  collection_created: { label: "Collection Created", color: "#10b981" },
+  collection_updated: { label: "Collection Updated", color: "#10b981" },
+  collection_deleted: { label: "Collection Deleted", color: "#e74c3c" },
+  discount_created: { label: "Discount Created", color: "#8b5cf6" },
+  discount_changed: { label: "Discount Changed", color: "#8b5cf6" },
+  discount_deleted: { label: "Discount Deleted", color: "#e74c3c" },
+  app_permissions_changed: { label: "App Permissions", color: "#6366f1" },
+  domain_changed: { label: "Domain Changed", color: "#0891b2" },
+  domain_removed: { label: "Domain Removed", color: "#e74c3c" },
 };
 
 const importanceConfig: Record<string, { label: string; color: string }> = {
@@ -197,10 +206,14 @@ export default function RecentChanges() {
                     const ctx = JSON.parse(event.contextData) as {
                       velocityContext?: string | null;
                       revenueImpact?: number | null;
+                      locationContext?: string | null;
                     };
-                    if (!ctx.velocityContext && ctx.revenueImpact === null) return null;
+                    if (!ctx.velocityContext && ctx.revenueImpact === null && !ctx.locationContext) return null;
                     return (
                       <div style={{ marginTop: 6, fontSize: 12, color: "#6b7280" }}>
+                        {ctx.locationContext && (
+                          <span style={{ marginRight: 8 }}>{ctx.locationContext}</span>
+                        )}
                         {ctx.velocityContext && (
                           <span style={{ marginRight: 8 }}>{ctx.velocityContext}</span>
                         )}
diff --git a/insightops/app/routes/app.settings.tsx b/insightops/app/routes/app.settings.tsx
index 1ec2a02..0c82ff7 100644
--- a/insightops/app/routes/app.settings.tsx
+++ b/insightops/app/routes/app.settings.tsx
@@ -28,6 +28,10 @@ export const action = async ({ request }: ActionFunctionArgs): Promise<ActionRes
   const trackVisibility = formData.get("trackVisibility") === "on";
   const trackInventory = formData.get("trackInventory") === "on";
   const trackThemes = formData.get("trackThemes") === "on";
+  const trackCollections = formData.get("trackCollections") === "on";
+  const trackDiscounts = formData.get("trackDiscounts") === "on";
+  const trackAppPermissions = formData.get("trackAppPermissions") === "on";
+  const trackDomains = formData.get("trackDomains") === "on";
   const lowStockThreshold = parseInt(formData.get("lowStockThreshold") as string) || 5;
   const instantAlerts = formData.get("instantAlerts") === "on";
 
@@ -50,6 +54,10 @@ export const action = async ({ request }: ActionFunctionArgs): Promise<ActionRes
       trackVisibility,
       trackInventory,
       trackThemes,
+      trackCollections,
+      trackDiscounts,
+      trackAppPermissions,
+      trackDomains,
       lowStockThreshold,
       instantAlerts,
     });
@@ -200,6 +208,20 @@ export default function Settings() {
               </label>
             </div>
           )}
+          <Toggle
+            name="trackCollections"
+            label="Collection changes"
+            description="Track when collections are created, updated, or deleted"
+            defaultChecked={settings.trackCollections}
+          />
+          <Toggle
+            name="trackDiscounts"
+            label="Discount changes"
+            description="Track when discounts are created, modified, or deleted"
+            defaultChecked={settings.trackDiscounts}
+            disabled={settings.plan !== "pro"}
+            proOnly
+          />
           <Toggle
             name="trackThemes"
             label="Theme publishes"
@@ -208,6 +230,22 @@ export default function Settings() {
             disabled={settings.plan !== "pro"}
             proOnly
           />
+          <Toggle
+            name="trackAppPermissions"
+            label="App permission changes"
+            description="Track when installed apps expand or change their permissions"
+            defaultChecked={settings.trackAppPermissions}
+            disabled={settings.plan !== "pro"}
+            proOnly
+          />
+          <Toggle
+            name="trackDomains"
+            label="Domain changes"
+            description="Track when domains are added, changed, or removed"
+            defaultChecked={settings.trackDomains}
+            disabled={settings.plan !== "pro"}
+            proOnly
+          />
         </Section>
 
         {/* 2. Your Plan */}
diff --git a/insightops/app/routes/webhooks.compliance.tsx b/insightops/app/routes/webhooks.compliance.tsx
index e6ef0e4..eddb0d6 100644
--- a/insightops/app/routes/webhooks.compliance.tsx
+++ b/insightops/app/routes/webhooks.compliance.tsx
@@ -42,11 +42,6 @@ export const action = async ({ request }: ActionFunctionArgs) => {
           where: { shop },
         });
 
-        // Delete event logs
-        await db.eventLog.deleteMany({
-          where: { shop },
-        });
-
         // Delete product snapshots
         await db.productSnapshot.deleteMany({
           where: { shop },
diff --git a/insightops/app/routes/webhooks.discounts.create.tsx b/insightops/app/routes/webhooks.discounts.create.tsx
new file mode 100644
index 0000000..ae71798
--- /dev/null
+++ b/insightops/app/routes/webhooks.discounts.create.tsx
@@ -0,0 +1,29 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob } from "../services/jobQueue.server";
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    return new Response();
+  }
+
+  const discount = payload as { id: number };
+
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(discount.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
+
+  return new Response();
+};
diff --git a/insightops/app/routes/webhooks.discounts.delete.tsx b/insightops/app/routes/webhooks.discounts.delete.tsx
new file mode 100644
index 0000000..ae71798
--- /dev/null
+++ b/insightops/app/routes/webhooks.discounts.delete.tsx
@@ -0,0 +1,29 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob } from "../services/jobQueue.server";
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    return new Response();
+  }
+
+  const discount = payload as { id: number };
+
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(discount.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
+
+  return new Response();
+};
diff --git a/insightops/app/routes/webhooks.discounts.update.tsx b/insightops/app/routes/webhooks.discounts.update.tsx
new file mode 100644
index 0000000..ae71798
--- /dev/null
+++ b/insightops/app/routes/webhooks.discounts.update.tsx
@@ -0,0 +1,29 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob } from "../services/jobQueue.server";
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    return new Response();
+  }
+
+  const discount = payload as { id: number };
+
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(discount.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
+
+  return new Response();
+};
diff --git a/insightops/app/routes/webhooks.orders.paid.tsx b/insightops/app/routes/webhooks.domains.create.tsx
similarity index 87%
rename from insightops/app/routes/webhooks.orders.paid.tsx
rename to insightops/app/routes/webhooks.domains.create.tsx
index 023d3b4..1033f84 100644
--- a/insightops/app/routes/webhooks.orders.paid.tsx
+++ b/insightops/app/routes/webhooks.domains.create.tsx
@@ -14,14 +14,15 @@ export const action = async ({ request }: ActionFunctionArgs) => {
     return new Response();
   }
 
-  const order = payload as { id: number };
+  const domain = payload as { id: number };
 
   await queueWebhookJob({
     shop,
     topic,
-    resourceId: String(order.id),
+    resourceId: String(domain.id),
     payload,
     webhookId: webhookId || undefined,
+    delayMs: 2000,
   });
 
   return new Response();
diff --git a/insightops/app/routes/webhooks.domains.destroy.tsx b/insightops/app/routes/webhooks.domains.destroy.tsx
new file mode 100644
index 0000000..1033f84
--- /dev/null
+++ b/insightops/app/routes/webhooks.domains.destroy.tsx
@@ -0,0 +1,29 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob } from "../services/jobQueue.server";
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    return new Response();
+  }
+
+  const domain = payload as { id: number };
+
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(domain.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
+
+  return new Response();
+};
diff --git a/insightops/app/routes/webhooks.domains.update.tsx b/insightops/app/routes/webhooks.domains.update.tsx
new file mode 100644
index 0000000..1033f84
--- /dev/null
+++ b/insightops/app/routes/webhooks.domains.update.tsx
@@ -0,0 +1,29 @@
+import type { ActionFunctionArgs } from "react-router";
+import { authenticate } from "../shopify.server";
+import { queueWebhookJob } from "../services/jobQueue.server";
+
+export const action = async ({ request }: ActionFunctionArgs) => {
+  const webhookId = request.headers.get("X-Shopify-Webhook-Id");
+
+  const { shop, session, topic, payload } =
+    await authenticate.webhook(request);
+
+  console.log(`[StoreGuard] Received ${topic} webhook for ${shop} (ID: ${webhookId})`);
+
+  if (!session) {
+    return new Response();
+  }
+
+  const domain = payload as { id: number };
+
+  await queueWebhookJob({
+    shop,
+    topic,
+    resourceId: String(domain.id),
+    payload,
+    webhookId: webhookId || undefined,
+    delayMs: 2000,
+  });
+
+  return new Response();
+};
diff --git a/insightops/app/services/changeDetection.server.ts b/insightops/app/services/changeDetection.server.ts
index b1f1c7c..6d3cf77 100644
--- a/insightops/app/services/changeDetection.server.ts
+++ b/insightops/app/services/changeDetection.server.ts
@@ -8,9 +8,19 @@ import {
   shouldAlertInventoryZero as checkInventoryZero,
   shouldAlertLowStock as checkLowStock,
   formatVariantLabel,
+  isCriticalInstantAlert,
 } from "./changeDetection.utils";
 import { getProductSalesVelocity } from "./salesVelocity.server";
-import { formatVelocityContext, estimateRevenueImpact } from "./salesVelocity.utils";
+import {
+  enrichPriceChange,
+  enrichInventoryZero,
+  enrichLowStock,
+  enrichVisibilityChange,
+  enrichThemePublish,
+  serializeContext,
+} from "./contextEnricher.server";
+import { estimateMoneySaved } from "./moneySaved.utils";
+import { diffScopes } from "./jobProcessor.utils";
 
 /**
  * Change Detection Service for StoreGuard
@@ -60,20 +70,21 @@ async function getProductSnapshot(shop: string, productId: string): Promise<{
 } | null> {
   const snapshot = await db.productSnapshot.findUnique({
     where: { shop_id: { shop, id: productId } },
+    include: { variants: true },
   });
 
   if (!snapshot) return null;
 
-  try {
-    const variants = JSON.parse(snapshot.variants) as VariantSnapshot[];
-    return {
-      title: snapshot.title,
-      status: snapshot.status,
-      variants,
-    };
-  } catch {
-    return null;
-  }
+  return {
+    title: snapshot.title,
+    status: snapshot.status,
+    variants: snapshot.variants.map(v => ({
+      id: v.shopifyVariantId,
+      title: v.title,
+      price: v.price,
+      inventoryQuantity: v.inventoryQuantity,
+    })),
+  };
 }
 
 /**
@@ -84,21 +95,83 @@ async function updateProductSnapshot(
   productId: string,
   data: { title: string; status: string; variants: VariantSnapshot[] }
 ): Promise<void> {
-  await db.productSnapshot.upsert({
-    where: { shop_id: { shop, id: productId } },
-    create: {
-      id: productId,
+  await db.$transaction(async (tx) => {
+    await tx.productSnapshot.upsert({
+      where: { shop_id: { shop, id: productId } },
+      create: {
+        id: productId,
+        shop,
+        title: data.title,
+        status: data.status,
+      },
+      update: {
+        title: data.title,
+        status: data.status,
+      },
+    });
+
+    for (const v of data.variants) {
+      await tx.variantSnapshot.upsert({
+        where: {
+          productSnapshotId_shopifyVariantId: {
+            productSnapshotId: productId,
+            shopifyVariantId: String(v.id),
+          },
+        },
+        create: {
+          productSnapshotId: productId,
+          shop,
+          shopifyVariantId: String(v.id),
+          title: v.title,
+          price: String(v.price),
+          inventoryQuantity: v.inventoryQuantity,
+        },
+        update: {
+          title: v.title,
+          price: String(v.price),
+          inventoryQuantity: v.inventoryQuantity,
+        },
+      });
+    }
+  });
+}
+
+/** Max instant alert emails per shop per hour */
+const INSTANT_ALERT_RATE_LIMIT = 10;
+
+/**
+ * Decide whether to send an instant alert for a change event.
+ * Returns true only when:
+ * 1. The shop has instant alerts enabled (Pro + toggle on + email set)
+ * 2. The event is critical (price drop >50%, out of stock, visibility hidden, domain removed, permissions expanded)
+ * 3. The shop has not exceeded the rate limit (max 10 per hour)
+ */
+export async function shouldSendInstantAlert(
+  shop: string,
+  event: { eventType: string; importance: string; afterValue?: string | null }
+): Promise<boolean> {
+  // 1. Feature gate: Pro plan + instant alerts enabled + email configured
+  const enabled = await hasInstantAlerts(shop);
+  if (!enabled) return false;
+
+  // 2. Severity check: only critical events
+  if (!isCriticalInstantAlert(event)) return false;
+
+  // 3. Rate limit: max 10 instant alert emails per shop per hour
+  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000);
+  const recentAlertCount = await db.changeEvent.count({
+    where: {
       shop,
-      title: data.title,
-      status: data.status,
-      variants: JSON.stringify(data.variants),
-    },
-    update: {
-      title: data.title,
-      status: data.status,
-      variants: JSON.stringify(data.variants),
+      instantAlertSentAt: { not: null, gte: oneHourAgo },
     },
   });
+
+  if (recentAlertCount >= INSTANT_ALERT_RATE_LIMIT) {
+    console.log(`[StoreGuard] Rate limit reached for ${shop}: ${recentAlertCount} instant alerts in last hour`);
+    return false;
+  }
+
+  return true;
 }
 
 /**
@@ -106,9 +179,9 @@ async function updateProductSnapshot(
  */
 async function createChangeEvent(data: {
   shop: string;
-  entityType: "product" | "variant" | "theme";
+  entityType: string;
   entityId: string;
-  eventType: "price_change" | "visibility_change" | "inventory_low" | "inventory_zero" | "theme_publish";
+  eventType: string;
   resourceName: string;
   beforeValue: string | null;
   afterValue: string | null;
@@ -117,8 +190,18 @@ async function createChangeEvent(data: {
   importance?: "high" | "medium" | "low";
   groupId?: string;
   contextData?: string | null;
+  moneySaved?: number | null;
 }): Promise<void> {
   try {
+    const importance = data.importance ?? "medium";
+
+    // Check instant alert eligibility BEFORE creating the event (for rate limit accuracy)
+    const sendInstant = await shouldSendInstantAlert(data.shop, {
+      eventType: data.eventType,
+      importance,
+      afterValue: data.afterValue,
+    });
+
     const event = await db.changeEvent.create({
       data: {
         shop: data.shop,
@@ -130,16 +213,17 @@ async function createChangeEvent(data: {
         afterValue: data.afterValue,
         webhookId: data.webhookId,
         source: data.source ?? "webhook",
-        importance: data.importance ?? "medium",
+        importance,
         groupId: data.groupId,
         contextData: data.contextData ?? null,
+        instantAlertSentAt: sendInstant ? new Date() : null,
+        moneySaved: data.moneySaved ?? null,
       },
     });
     console.log(`[StoreGuard] Created ${data.eventType} event for "${data.resourceName}"`);
 
-    // Send instant alert if enabled (Pro feature)
-    const shouldSendInstant = await hasInstantAlerts(data.shop);
-    if (shouldSendInstant) {
+    // Send instant alert for critical events only
+    if (sendInstant) {
       const alertEmail = await getShopAlertEmail(data.shop);
       if (alertEmail) {
         // Fire and forget - don't block on email sending
@@ -149,7 +233,7 @@ async function createChangeEvent(data: {
             resourceName: data.resourceName,
             beforeValue: data.beforeValue,
             afterValue: data.afterValue,
-            importance: data.importance ?? "medium",
+            importance,
             detectedAt: event.detectedAt,
             contextData: data.contextData ?? null,
           },
@@ -221,15 +305,20 @@ export async function detectPriceChanges(
       const variantLabel = formatVariantLabel(product.title, newVariant.title);
       const importance = calculatePriceImportance(oldVariant.price, newVariant.price);
 
-      // Build context data with sales velocity
-      const priceDiff = Math.abs(parseFloat(newVariant.price) - parseFloat(oldVariant.price));
-      const velocityContext = formatVelocityContext(velocity);
-      const revenueImpact = estimateRevenueImpact(velocity, "price_error", {
-        priceDifference: priceDiff,
+      const enriched = enrichPriceChange(
+        variantLabel,
+        `$${oldVariant.price}`,
+        `$${newVariant.price}`,
+        velocity
+      );
+      const contextData = serializeContext(enriched);
+
+      const moneySaved = estimateMoneySaved({
+        eventType: "price_change",
+        velocity,
+        beforeValue: `$${oldVariant.price}`,
+        afterValue: `$${newVariant.price}`,
       });
-      const contextData = (velocityContext || revenueImpact !== null)
-        ? JSON.stringify({ velocityContext, revenueImpact })
-        : null;
 
       await createChangeEvent({
         shop,
@@ -242,6 +331,7 @@ export async function detectPriceChanges(
         webhookId: `${webhookId}-price-${newVariant.id}`,
         importance: importance as "high" | "medium" | "low",
         contextData,
+        moneySaved,
       });
       changesDetected++;
     }
@@ -304,11 +394,20 @@ export async function detectVisibilityChanges(
       // Non-critical
     }
 
-    const velocityContext = formatVelocityContext(velocity);
-    const revenueImpact = estimateRevenueImpact(velocity, "visibility", {});
-    const contextData = (velocityContext || revenueImpact !== null)
-      ? JSON.stringify({ velocityContext, revenueImpact })
-      : null;
+    const enriched = enrichVisibilityChange(
+      product.title,
+      oldSnapshot.status,
+      product.status,
+      velocity
+    );
+    const contextData = serializeContext(enriched);
+
+    const moneySaved = estimateMoneySaved({
+      eventType: "visibility_change",
+      velocity,
+      beforeValue: oldSnapshot.status,
+      afterValue: product.status,
+    });
 
     await createChangeEvent({
       shop,
@@ -321,6 +420,7 @@ export async function detectVisibilityChanges(
       webhookId: `${webhookId}-status`,
       importance,
       contextData,
+      moneySaved,
     });
 
     // Update snapshot
@@ -368,7 +468,8 @@ export async function detectInventoryZero(
   variantTitle: string,
   newQuantity: number,
   previousQuantity: number | null, // Must be provided from webhook processing
-  webhookId: string
+  webhookId: string,
+  locationContext?: string | null
 ): Promise<boolean> {
   // Check if shop wants to track inventory
   if (!await canTrackFeature(shop, "inventory")) {
@@ -404,23 +505,34 @@ export async function detectInventoryZero(
     // Non-critical
   }
 
-  const velocityContext = formatVelocityContext(velocity);
-  const revenueImpact = estimateRevenueImpact(velocity, "stockout", {});
-  const contextData = (velocityContext || revenueImpact !== null)
-    ? JSON.stringify({ velocityContext, revenueImpact })
-    : null;
+  const displayName = formatVariantLabel(productTitle, variantTitle);
+  const enriched = enrichInventoryZero(
+    displayName,
+    String(previousQuantity),
+    velocity,
+    locationContext ?? null
+  );
+  const contextData = serializeContext(enriched);
+
+  const moneySaved = estimateMoneySaved({
+    eventType: "inventory_zero",
+    velocity,
+    beforeValue: String(previousQuantity),
+    afterValue: "0",
+  });
 
   await createChangeEvent({
     shop,
     entityType: "variant",
     entityId: inventoryItemId,
     eventType: "inventory_zero",
-    resourceName: formatVariantLabel(productTitle, variantTitle),
+    resourceName: displayName,
     beforeValue: String(previousQuantity),
     afterValue: "0",
     webhookId: `${webhookId}-inventory-zero-${inventoryItemId}`,
-    importance: "high", // Out of stock is always high importance
+    importance: "high",
     contextData,
+    moneySaved,
   });
 
   return true;
@@ -439,7 +551,8 @@ export async function detectLowStock(
   variantTitle: string,
   newQuantity: number,
   previousQuantity: number | null,
-  webhookId: string
+  webhookId: string,
+  locationContext?: string | null
 ): Promise<boolean> {
   // Get the shop's low stock threshold
   const threshold = await getLowStockThreshold(shop);
@@ -478,11 +591,21 @@ export async function detectLowStock(
     // Non-critical
   }
 
-  const velocityContext = formatVelocityContext(velocity);
-  const revenueImpact = estimateRevenueImpact(velocity, "stockout", {});
-  const contextData = (velocityContext || revenueImpact !== null)
-    ? JSON.stringify({ velocityContext, revenueImpact })
-    : null;
+  const enriched = enrichLowStock(
+    displayName,
+    String(previousQuantity),
+    String(newQuantity),
+    velocity,
+    locationContext ?? null
+  );
+  const contextData = serializeContext(enriched);
+
+  const moneySaved = estimateMoneySaved({
+    eventType: "inventory_low",
+    velocity,
+    beforeValue: String(previousQuantity),
+    afterValue: String(newQuantity),
+  });
 
   await createChangeEvent({
     shop,
@@ -493,8 +616,9 @@ export async function detectLowStock(
     beforeValue: String(previousQuantity),
     afterValue: String(newQuantity),
     webhookId: `${webhookId}-inventory-low-${inventoryItemId}`,
-    importance: "medium", // Low stock is medium importance (zero is high)
+    importance: "medium",
     contextData,
+    moneySaved,
   });
 
   console.log(`[StoreGuard] Low stock alert: ${displayName} dropped to ${newQuantity} (threshold: ${threshold})`);
@@ -525,16 +649,328 @@ export async function recordThemePublish(
     return false;
   }
 
+  const enriched = enrichThemePublish(theme.name);
+  const contextData = serializeContext(enriched);
+
   await createChangeEvent({
     shop,
     entityType: "theme",
     entityId: String(theme.id),
     eventType: "theme_publish",
     resourceName: theme.name,
-    beforeValue: null, // We don't know what theme was live before
+    beforeValue: null,
     afterValue: "main",
     webhookId: `${webhookId}-theme`,
-    importance: "high", // Theme publish is always important
+    importance: "high",
+    contextData,
+  });
+
+  return true;
+}
+
+// ============================================
+// COLLECTION CHANGE DETECTION
+// ============================================
+
+/**
+ * Record a collection created event
+ */
+export async function recordCollectionCreated(
+  shop: string,
+  collectionId: string,
+  collectionTitle: string,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "collections")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "collection",
+    entityId: collectionId,
+    eventType: "collection_created",
+    resourceName: collectionTitle,
+    beforeValue: null,
+    afterValue: collectionTitle,
+    webhookId: `${webhookId}-collection-created`,
+    importance: "low",
+  });
+
+  return true;
+}
+
+/**
+ * Record a collection updated event
+ */
+export async function recordCollectionUpdated(
+  shop: string,
+  collectionId: string,
+  collectionTitle: string,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "collections")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "collection",
+    entityId: collectionId,
+    eventType: "collection_updated",
+    resourceName: collectionTitle,
+    beforeValue: null,
+    afterValue: collectionTitle,
+    webhookId: `${webhookId}-collection-updated`,
+    importance: "medium",
+  });
+
+  return true;
+}
+
+/**
+ * Record a collection deleted event
+ * HIGH importance — deleting a collection breaks links and navigation
+ */
+export async function recordCollectionDeleted(
+  shop: string,
+  collectionId: string,
+  collectionTitle: string,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "collections")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "collection",
+    entityId: collectionId,
+    eventType: "collection_deleted",
+    resourceName: collectionTitle,
+    beforeValue: collectionTitle,
+    afterValue: null,
+    webhookId: `${webhookId}-collection-deleted`,
+    importance: "high",
+  });
+
+  return true;
+}
+
+// ============================================
+// DISCOUNT CHANGE DETECTION (Pro only)
+// ============================================
+
+/**
+ * Record a discount created event
+ */
+export async function recordDiscountCreated(
+  shop: string,
+  discountId: string,
+  discountTitle: string,
+  discountValue: string | null,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "discounts")) {
+    return false;
+  }
+
+  // Large discounts (>=50%) are high importance
+  let importance: "high" | "medium" | "low" = "medium";
+  if (discountValue) {
+    const numericValue = parseFloat(discountValue);
+    if (!isNaN(numericValue) && numericValue >= 50) {
+      importance = "high";
+    }
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "discount",
+    entityId: discountId,
+    eventType: "discount_created",
+    resourceName: discountTitle,
+    beforeValue: null,
+    afterValue: discountValue ? `${discountValue}% off` : discountTitle,
+    webhookId: `${webhookId}-discount-created`,
+    importance,
+  });
+
+  return true;
+}
+
+/**
+ * Record a discount updated event
+ */
+export async function recordDiscountUpdated(
+  shop: string,
+  discountId: string,
+  discountTitle: string,
+  discountValue: string | null,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "discounts")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "discount",
+    entityId: discountId,
+    eventType: "discount_changed",
+    resourceName: discountTitle,
+    beforeValue: null,
+    afterValue: discountValue ? `${discountValue}% off` : discountTitle,
+    webhookId: `${webhookId}-discount-changed`,
+    importance: "medium",
+  });
+
+  return true;
+}
+
+/**
+ * Record a discount deleted event
+ * HIGH importance — deleting a discount can break promotions
+ */
+export async function recordDiscountDeleted(
+  shop: string,
+  discountId: string,
+  discountTitle: string,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "discounts")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "discount",
+    entityId: discountId,
+    eventType: "discount_deleted",
+    resourceName: discountTitle,
+    beforeValue: discountTitle,
+    afterValue: null,
+    webhookId: `${webhookId}-discount-deleted`,
+    importance: "high",
+  });
+
+  return true;
+}
+
+// ============================================
+// APP PERMISSION CHANGE DETECTION (Pro only)
+// ============================================
+
+/**
+ * Record an app permissions changed event.
+ * Diffs previous vs current scopes.
+ * HIGH importance for scope expansions (new permissions added).
+ */
+export async function recordAppPermissionsChanged(
+  shop: string,
+  previousScopes: string[],
+  currentScopes: string[],
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "app_permissions")) {
+    return false;
+  }
+
+  // Diff scopes
+  const { added, removed } = diffScopes(previousScopes, currentScopes);
+
+  // No actual change
+  if (added.length === 0 && removed.length === 0) {
+    return false;
+  }
+
+  // Scope expansions are HIGH importance (security risk)
+  const importance: "high" | "medium" | "low" = added.length > 0 ? "high" : "medium";
+
+  let resourceName = "App permissions";
+  if (added.length > 0 && removed.length === 0) {
+    resourceName = `${added.length} scope${added.length > 1 ? "s" : ""} added`;
+  } else if (removed.length > 0 && added.length === 0) {
+    resourceName = `${removed.length} scope${removed.length > 1 ? "s" : ""} removed`;
+  } else {
+    resourceName = `${added.length} added, ${removed.length} removed`;
+  }
+
+  const contextData = JSON.stringify({ added, removed });
+
+  await createChangeEvent({
+    shop,
+    entityType: "app",
+    entityId: shop,
+    eventType: "app_permissions_changed",
+    resourceName,
+    beforeValue: previousScopes.join(", "),
+    afterValue: currentScopes.join(", "),
+    webhookId: `${webhookId}-app-permissions`,
+    importance,
+    contextData,
+  });
+
+  return true;
+}
+
+// ============================================
+// DOMAIN CHANGE DETECTION (Pro only)
+// ============================================
+
+/**
+ * Record a domain changed event (created or updated)
+ * HIGH importance — domain changes affect SEO and store access
+ */
+export async function recordDomainChanged(
+  shop: string,
+  domainId: string,
+  domainHost: string,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "domains")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "domain",
+    entityId: domainId,
+    eventType: "domain_changed",
+    resourceName: domainHost,
+    beforeValue: null,
+    afterValue: domainHost,
+    webhookId: `${webhookId}-domain-changed`,
+    importance: "high",
+  });
+
+  return true;
+}
+
+/**
+ * Record a domain removed event
+ * HIGH importance — removing a domain breaks store access
+ */
+export async function recordDomainRemoved(
+  shop: string,
+  domainId: string,
+  domainHost: string,
+  webhookId: string
+): Promise<boolean> {
+  if (!await canTrackFeature(shop, "domains")) {
+    return false;
+  }
+
+  await createChangeEvent({
+    shop,
+    entityType: "domain",
+    entityId: domainId,
+    eventType: "domain_removed",
+    resourceName: domainHost,
+    beforeValue: domainHost,
+    afterValue: null,
+    webhookId: `${webhookId}-domain-removed`,
+    importance: "high",
   });
 
   return true;
diff --git a/insightops/app/services/changeDetection.test.ts b/insightops/app/services/changeDetection.test.ts
index 22e5097..050e6ee 100644
--- a/insightops/app/services/changeDetection.test.ts
+++ b/insightops/app/services/changeDetection.test.ts
@@ -6,6 +6,7 @@ import {
   shouldAlertInventoryZero,
   shouldAlertLowStock,
   formatVariantLabel,
+  isCriticalInstantAlert,
 } from "./changeDetection.utils";
 
 describe("calculatePriceImportance", () => {
@@ -155,3 +156,85 @@ describe("formatVariantLabel", () => {
     expect(formatVariantLabel("Widget", null)).toBe("Widget");
   });
 });
+
+describe("isCriticalInstantAlert", () => {
+  // Price changes: only high importance (>50% drop) triggers instant alert
+  it("should return true for high-importance price changes (>50% drop)", () => {
+    expect(isCriticalInstantAlert({ eventType: "price_change", importance: "high" })).toBe(true);
+  });
+
+  it("should return false for medium-importance price changes", () => {
+    expect(isCriticalInstantAlert({ eventType: "price_change", importance: "medium" })).toBe(false);
+  });
+
+  it("should return false for low-importance price changes", () => {
+    expect(isCriticalInstantAlert({ eventType: "price_change", importance: "low" })).toBe(false);
+  });
+
+  // Inventory zero: always critical
+  it("should return true for inventory_zero events", () => {
+    expect(isCriticalInstantAlert({ eventType: "inventory_zero", importance: "high" })).toBe(true);
+  });
+
+  // Visibility: only when product becomes hidden
+  it("should return true when product is hidden (active -> draft)", () => {
+    expect(isCriticalInstantAlert({
+      eventType: "visibility_change",
+      importance: "high",
+      afterValue: "draft",
+    })).toBe(true);
+  });
+
+  it("should return true when product is archived (active -> archived)", () => {
+    expect(isCriticalInstantAlert({
+      eventType: "visibility_change",
+      importance: "high",
+      afterValue: "archived",
+    })).toBe(true);
+  });
+
+  it("should return false when product becomes visible (draft -> active)", () => {
+    expect(isCriticalInstantAlert({
+      eventType: "visibility_change",
+      importance: "medium",
+      afterValue: "active",
+    })).toBe(false);
+  });
+
+  // Domain removed: always critical
+  it("should return true for domain_removed events", () => {
+    expect(isCriticalInstantAlert({ eventType: "domain_removed", importance: "high" })).toBe(true);
+  });
+
+  // App permissions expanded: only high importance (scopes added)
+  it("should return true for high-importance app_permissions_changed (scopes expanded)", () => {
+    expect(isCriticalInstantAlert({ eventType: "app_permissions_changed", importance: "high" })).toBe(true);
+  });
+
+  it("should return false for medium-importance app_permissions_changed (scopes removed only)", () => {
+    expect(isCriticalInstantAlert({ eventType: "app_permissions_changed", importance: "medium" })).toBe(false);
+  });
+
+  // Non-critical event types should never trigger
+  it("should return false for inventory_low events", () => {
+    expect(isCriticalInstantAlert({ eventType: "inventory_low", importance: "medium" })).toBe(false);
+  });
+
+  it("should return false for theme_publish events", () => {
+    expect(isCriticalInstantAlert({ eventType: "theme_publish", importance: "high" })).toBe(false);
+  });
+
+  it("should return false for collection events", () => {
+    expect(isCriticalInstantAlert({ eventType: "collection_created", importance: "low" })).toBe(false);
+    expect(isCriticalInstantAlert({ eventType: "collection_deleted", importance: "high" })).toBe(false);
+  });
+
+  it("should return false for discount events", () => {
+    expect(isCriticalInstantAlert({ eventType: "discount_created", importance: "medium" })).toBe(false);
+    expect(isCriticalInstantAlert({ eventType: "discount_deleted", importance: "high" })).toBe(false);
+  });
+
+  it("should return false for domain_changed events", () => {
+    expect(isCriticalInstantAlert({ eventType: "domain_changed", importance: "high" })).toBe(false);
+  });
+});
diff --git a/insightops/app/services/changeDetection.utils.ts b/insightops/app/services/changeDetection.utils.ts
index cf64cce..bf8c4ae 100644
--- a/insightops/app/services/changeDetection.utils.ts
+++ b/insightops/app/services/changeDetection.utils.ts
@@ -102,3 +102,66 @@ export function formatVariantLabel(
   }
   return `${productTitle} - ${variantTitle}`;
 }
+
+/**
+ * Determine if a change event is critical enough for an immediate instant alert.
+ *
+ * Critical events:
+ * - Price drop >50% (importance "high" on price_change)
+ * - Out of stock across all locations (inventory_zero)
+ * - Product hidden from store (visibility_change to draft/archived)
+ * - Domain removed (domain_removed)
+ * - App permissions expanded (app_permissions_changed with importance "high")
+ */
+export function isCriticalInstantAlert(event: {
+  eventType: string;
+  importance: string;
+  afterValue?: string | null;
+}): boolean {
+  switch (event.eventType) {
+    case "price_change":
+      return event.importance === "high";
+    case "inventory_zero":
+      return true;
+    case "visibility_change":
+      return event.afterValue === "draft" || event.afterValue === "archived";
+    case "domain_removed":
+      return true;
+    case "app_permissions_changed":
+      return event.importance === "high";
+    default:
+      return false;
+  }
+}
+
+/** Shape of each inventory level node returned by Shopify GraphQL */
+export interface InventoryLevelNode {
+  quantities: Array<{ quantity: number }>;
+  location: { id: string; name: string } | null;
+}
+
+/**
+ * Aggregate inventory level nodes into a total quantity and trigger location name.
+ * Used by fetchTotalInventory after paginating through all inventory levels.
+ */
+export function aggregateInventoryLevels(
+  nodes: InventoryLevelNode[],
+  triggerLocationId: number
+): { totalQuantity: number; locationName: string | null } {
+  let totalQuantity = 0;
+  let locationName: string | null = null;
+
+  for (const level of nodes) {
+    const qty = level.quantities?.[0]?.quantity ?? 0;
+    totalQuantity += qty;
+
+    // Identify the triggering location
+    const locGid: string = level.location?.id ?? "";
+    const locMatch = locGid.match(/\/Location\/(\d+)$/);
+    if (locMatch?.[1] === String(triggerLocationId)) {
+      locationName = level.location?.name ?? null;
+    }
+  }
+
+  return { totalQuantity, locationName };
+}
diff --git a/insightops/app/services/contextEnricher.server.ts b/insightops/app/services/contextEnricher.server.ts
new file mode 100644
index 0000000..9b729bf
--- /dev/null
+++ b/insightops/app/services/contextEnricher.server.ts
@@ -0,0 +1,240 @@
+/**
+ * Context Enricher for StoreGuard
+ *
+ * Centralizes business context enrichment for ChangeEvents.
+ * Each event type gets a human-readable summary stored in contextData JSON.
+ *
+ * Context structure (stored as JSON string in ChangeEvent.contextData):
+ * {
+ *   summary: string;           // Human-readable one-liner for emails/UI
+ *   velocityContext?: string;   // e.g., "selling 8/day"
+ *   revenueImpact?: number;    // Estimated $/hr impact
+ *   locationContext?: string;   // e.g., "Warehouse A"
+ *   percentChange?: number;    // For price changes
+ *   direction?: "up" | "down"; // For price changes
+ * }
+ */
+
+import type { ProductVelocity } from "./salesVelocity.utils";
+import { formatVelocityContext, estimateRevenueImpact } from "./salesVelocity.utils";
+
+export interface EnrichedContext {
+  summary: string;
+  velocityContext: string | null;
+  revenueImpact: number | null;
+  locationContext: string | null;
+  percentChange: number | null;
+  direction: "up" | "down" | null;
+}
+
+/**
+ * Enrich a price change event with business context.
+ * Calculates % change, direction, and flags likely typos (>=90% drop).
+ */
+export function enrichPriceChange(
+  resourceName: string,
+  beforePrice: string,
+  afterPrice: string,
+  velocity: ProductVelocity | null
+): EnrichedContext {
+  const oldVal = parseFloat(beforePrice.replace(/^\$/, ""));
+  const newVal = parseFloat(afterPrice.replace(/^\$/, ""));
+
+  let percentChange: number | null = null;
+  let direction: "up" | "down" | null = null;
+
+  if (!isNaN(oldVal) && !isNaN(newVal) && oldVal > 0) {
+    percentChange = Math.round(((newVal - oldVal) / oldVal) * 100);
+    direction = newVal > oldVal ? "up" : "down";
+  }
+
+  const velocityContext = formatVelocityContext(velocity);
+  const priceDiff = !isNaN(oldVal) && !isNaN(newVal) ? Math.abs(newVal - oldVal) : 0;
+  const revenueImpact = estimateRevenueImpact(velocity, "price_error", {
+    priceDifference: priceDiff,
+  });
+
+  let summary = `${resourceName} changed from ${beforePrice} to ${afterPrice}`;
+  if (percentChange !== null) {
+    const absPercent = Math.abs(percentChange);
+    const dirWord = direction === "up" ? "increase" : "decrease";
+    summary += ` (${absPercent}% ${dirWord})`;
+    if (direction === "down" && absPercent >= 90) {
+      summary += " — probably a typo";
+    }
+  }
+  if (velocityContext) {
+    summary += ` — ${velocityContext}`;
+  }
+
+  return {
+    summary,
+    velocityContext,
+    revenueImpact,
+    locationContext: null,
+    percentChange,
+    direction,
+  };
+}
+
+/**
+ * Enrich an inventory zero event with business context.
+ * Includes revenue at risk based on sales velocity.
+ */
+export function enrichInventoryZero(
+  resourceName: string,
+  previousQuantity: string,
+  velocity: ProductVelocity | null,
+  locationContext: string | null
+): EnrichedContext {
+  const velocityCtx = formatVelocityContext(velocity);
+  const revenueImpact = estimateRevenueImpact(velocity, "stockout", {});
+
+  let summary = `${resourceName} hit zero stock (was ${previousQuantity} units)`;
+  if (velocityCtx) {
+    summary += ` — you've been ${velocityCtx}`;
+  }
+  if (locationContext) {
+    summary += ` at ${locationContext}`;
+  }
+
+  return {
+    summary,
+    velocityContext: velocityCtx,
+    revenueImpact,
+    locationContext,
+    percentChange: null,
+    direction: null,
+  };
+}
+
+/**
+ * Enrich a low stock event with business context.
+ */
+export function enrichLowStock(
+  resourceName: string,
+  previousQuantity: string,
+  currentQuantity: string,
+  velocity: ProductVelocity | null,
+  locationContext: string | null
+): EnrichedContext {
+  const velocityCtx = formatVelocityContext(velocity);
+  const revenueImpact = estimateRevenueImpact(velocity, "stockout", {});
+
+  let summary = `${resourceName} dropped to ${currentQuantity} units (was ${previousQuantity})`;
+  if (velocityCtx) {
+    summary += ` — ${velocityCtx}`;
+  }
+  if (locationContext) {
+    summary += ` at ${locationContext}`;
+  }
+
+  return {
+    summary,
+    velocityContext: velocityCtx,
+    revenueImpact,
+    locationContext,
+    percentChange: null,
+    direction: null,
+  };
+}
+
+/**
+ * Enrich a visibility change event with business context.
+ * Includes what the transition means and recent sales data.
+ */
+export function enrichVisibilityChange(
+  resourceName: string,
+  beforeStatus: string,
+  afterStatus: string,
+  velocity: ProductVelocity | null
+): EnrichedContext {
+  const velocityCtx = formatVelocityContext(velocity);
+  const revenueImpact = estimateRevenueImpact(velocity, "visibility", {});
+
+  const goingHidden = afterStatus === "draft" || afterStatus === "archived";
+  const visibilityLabel = goingHidden ? "no longer visible to customers" : "now visible to customers";
+
+  let summary = `${resourceName} went ${beforeStatus} → ${afterStatus} — ${visibilityLabel}`;
+  if (velocityCtx) {
+    summary += ` (${velocityCtx})`;
+  }
+
+  return {
+    summary,
+    velocityContext: velocityCtx,
+    revenueImpact,
+    locationContext: null,
+    percentChange: null,
+    direction: null,
+  };
+}
+
+/**
+ * Enrich a theme publish event.
+ */
+export function enrichThemePublish(themeName: string): EnrichedContext {
+  const time = new Date().toLocaleTimeString("en-US", {
+    hour: "numeric",
+    minute: "2-digit",
+    hour12: true,
+  });
+  const summary = `Theme "${themeName}" went live at ${time}`;
+
+  return {
+    summary,
+    velocityContext: null,
+    revenueImpact: null,
+    locationContext: null,
+    percentChange: null,
+    direction: null,
+  };
+}
+
+/**
+ * Serialize EnrichedContext to JSON string for storage in contextData field.
+ * Returns null if context has no meaningful data.
+ */
+export function serializeContext(context: EnrichedContext): string | null {
+  // Always store if we have a summary
+  if (!context.summary) return null;
+
+  const data: Record<string, unknown> = { summary: context.summary };
+  if (context.velocityContext) data.velocityContext = context.velocityContext;
+  if (context.revenueImpact !== null) data.revenueImpact = context.revenueImpact;
+  if (context.locationContext) data.locationContext = context.locationContext;
+  if (context.percentChange !== null) data.percentChange = context.percentChange;
+  if (context.direction) data.direction = context.direction;
+
+  return JSON.stringify(data);
+}
+
+/**
+ * Parse contextData JSON string back to structured data.
+ * Safe — returns defaults on invalid/missing data.
+ */
+export function parseContextData(contextData: string | null | undefined): {
+  summary: string | null;
+  velocityContext: string | null;
+  revenueImpact: number | null;
+  locationContext: string | null;
+  percentChange: number | null;
+  direction: "up" | "down" | null;
+} {
+  if (!contextData) {
+    return { summary: null, velocityContext: null, revenueImpact: null, locationContext: null, percentChange: null, direction: null };
+  }
+  try {
+    const ctx = JSON.parse(contextData) as Record<string, unknown>;
+    return {
+      summary: typeof ctx.summary === "string" ? ctx.summary : null,
+      velocityContext: typeof ctx.velocityContext === "string" ? ctx.velocityContext : null,
+      revenueImpact: typeof ctx.revenueImpact === "number" ? ctx.revenueImpact : null,
+      locationContext: typeof ctx.locationContext === "string" ? ctx.locationContext : null,
+      percentChange: typeof ctx.percentChange === "number" ? ctx.percentChange : null,
+      direction: ctx.direction === "up" || ctx.direction === "down" ? ctx.direction : null,
+    };
+  } catch {
+    return { summary: null, velocityContext: null, revenueImpact: null, locationContext: null, percentChange: null, direction: null };
+  }
+}
diff --git a/insightops/app/services/contextEnricher.test.ts b/insightops/app/services/contextEnricher.test.ts
new file mode 100644
index 0000000..86b640a
--- /dev/null
+++ b/insightops/app/services/contextEnricher.test.ts
@@ -0,0 +1,247 @@
+import { describe, it, expect } from "vitest";
+import {
+  enrichPriceChange,
+  enrichInventoryZero,
+  enrichLowStock,
+  enrichVisibilityChange,
+  enrichThemePublish,
+  serializeContext,
+  parseContextData,
+  type EnrichedContext,
+} from "./contextEnricher.server";
+import type { ProductVelocity } from "./salesVelocity.utils";
+
+const highVelocity: ProductVelocity = {
+  productId: "100",
+  totalUnitsSold: 240,
+  totalRevenue: 12000,
+  orderCount: 200,
+  dailySalesRate: 8,
+  dailyRevenue: 400,
+  periodDays: 30,
+};
+
+const lowVelocity: ProductVelocity = {
+  productId: "100",
+  totalUnitsSold: 3,
+  totalRevenue: 150,
+  orderCount: 3,
+  dailySalesRate: 0.1,
+  dailyRevenue: 5,
+  periodDays: 30,
+};
+
+describe("enrichPriceChange", () => {
+  it("should calculate percent decrease and direction", () => {
+    const result = enrichPriceChange("Blue Jacket", "$100.00", "$50.00", null);
+    expect(result.percentChange).toBe(-50);
+    expect(result.direction).toBe("down");
+    expect(result.summary).toContain("50% decrease");
+  });
+
+  it("should calculate percent increase and direction", () => {
+    const result = enrichPriceChange("Blue Jacket", "$50.00", "$100.00", null);
+    expect(result.percentChange).toBe(100);
+    expect(result.direction).toBe("up");
+    expect(result.summary).toContain("100% increase");
+  });
+
+  it("should flag likely typos for >=90% drops", () => {
+    const result = enrichPriceChange("Blue Jacket", "$89.00", "$8.90", null);
+    expect(result.summary).toContain("probably a typo");
+    expect(result.direction).toBe("down");
+  });
+
+  it("should not flag typo for moderate decreases", () => {
+    const result = enrichPriceChange("Blue Jacket", "$100.00", "$80.00", null);
+    expect(result.summary).not.toContain("probably a typo");
+  });
+
+  it("should include velocity context when available", () => {
+    const result = enrichPriceChange("Blue Jacket", "$100.00", "$50.00", highVelocity);
+    expect(result.velocityContext).toBe("selling 8/day");
+    expect(result.summary).toContain("selling 8/day");
+    expect(result.revenueImpact).not.toBeNull();
+  });
+
+  it("should handle no velocity data gracefully", () => {
+    const result = enrichPriceChange("Blue Jacket", "$100.00", "$50.00", null);
+    expect(result.velocityContext).toBeNull();
+    expect(result.revenueImpact).toBeNull();
+  });
+
+  it("should handle zero old price", () => {
+    const result = enrichPriceChange("Free Item", "$0.00", "$10.00", null);
+    // Can't calculate % change from $0
+    expect(result.percentChange).toBeNull();
+    expect(result.direction).toBeNull();
+  });
+});
+
+describe("enrichInventoryZero", () => {
+  it("should include previous quantity in summary", () => {
+    const result = enrichInventoryZero("Black Hoodie", "15", null, null);
+    expect(result.summary).toContain("Black Hoodie hit zero stock (was 15 units)");
+  });
+
+  it("should include velocity context", () => {
+    const result = enrichInventoryZero("Black Hoodie", "15", highVelocity, null);
+    expect(result.summary).toContain("you've been selling 8/day");
+    expect(result.revenueImpact).not.toBeNull();
+  });
+
+  it("should include location context", () => {
+    const result = enrichInventoryZero("Black Hoodie", "15", null, "Warehouse A");
+    expect(result.summary).toContain("at Warehouse A");
+    expect(result.locationContext).toBe("Warehouse A");
+  });
+
+  it("should include both velocity and location", () => {
+    const result = enrichInventoryZero("Black Hoodie", "15", highVelocity, "Main Store");
+    expect(result.summary).toContain("selling 8/day");
+    expect(result.summary).toContain("at Main Store");
+  });
+});
+
+describe("enrichLowStock", () => {
+  it("should show current and previous quantities", () => {
+    const result = enrichLowStock("Red Sneakers", "10", "3", null, null);
+    expect(result.summary).toContain("dropped to 3 units (was 10)");
+  });
+
+  it("should include velocity context", () => {
+    const result = enrichLowStock("Red Sneakers", "10", "3", lowVelocity, null);
+    expect(result.summary).toContain("sold 3 in the last 30 days");
+  });
+
+  it("should include location context", () => {
+    const result = enrichLowStock("Red Sneakers", "10", "3", null, "Store Front");
+    expect(result.summary).toContain("at Store Front");
+  });
+});
+
+describe("enrichVisibilityChange", () => {
+  it("should describe going hidden", () => {
+    const result = enrichVisibilityChange("Red Sneakers", "active", "draft", null);
+    expect(result.summary).toContain("no longer visible to customers");
+    expect(result.summary).toContain("active → draft");
+  });
+
+  it("should describe going visible", () => {
+    const result = enrichVisibilityChange("Red Sneakers", "draft", "active", null);
+    expect(result.summary).toContain("now visible to customers");
+  });
+
+  it("should include velocity for hidden products with sales", () => {
+    const result = enrichVisibilityChange("Red Sneakers", "active", "draft", highVelocity);
+    expect(result.summary).toContain("selling 8/day");
+    expect(result.revenueImpact).not.toBeNull();
+  });
+});
+
+describe("enrichThemePublish", () => {
+  it("should include theme name and time", () => {
+    const result = enrichThemePublish("Dawn Custom");
+    expect(result.summary).toContain('Theme "Dawn Custom" went live');
+    expect(result.velocityContext).toBeNull();
+    expect(result.revenueImpact).toBeNull();
+  });
+});
+
+describe("serializeContext", () => {
+  it("should serialize all fields", () => {
+    const context: EnrichedContext = {
+      summary: "Test summary",
+      velocityContext: "selling 8/day",
+      revenueImpact: 16.67,
+      locationContext: "Warehouse A",
+      percentChange: -50,
+      direction: "down",
+    };
+    const json = serializeContext(context);
+    expect(json).not.toBeNull();
+    const parsed = JSON.parse(json!);
+    expect(parsed.summary).toBe("Test summary");
+    expect(parsed.velocityContext).toBe("selling 8/day");
+    expect(parsed.revenueImpact).toBe(16.67);
+    expect(parsed.locationContext).toBe("Warehouse A");
+    expect(parsed.percentChange).toBe(-50);
+    expect(parsed.direction).toBe("down");
+  });
+
+  it("should omit null optional fields", () => {
+    const context: EnrichedContext = {
+      summary: "Simple summary",
+      velocityContext: null,
+      revenueImpact: null,
+      locationContext: null,
+      percentChange: null,
+      direction: null,
+    };
+    const json = serializeContext(context);
+    const parsed = JSON.parse(json!);
+    expect(parsed.summary).toBe("Simple summary");
+    expect(parsed.velocityContext).toBeUndefined();
+    expect(parsed.revenueImpact).toBeUndefined();
+  });
+
+  it("should return null for empty summary", () => {
+    const context: EnrichedContext = {
+      summary: "",
+      velocityContext: null,
+      revenueImpact: null,
+      locationContext: null,
+      percentChange: null,
+      direction: null,
+    };
+    expect(serializeContext(context)).toBeNull();
+  });
+});
+
+describe("parseContextData", () => {
+  it("should parse valid JSON with all fields", () => {
+    const json = JSON.stringify({
+      summary: "Test",
+      velocityContext: "selling 8/day",
+      revenueImpact: 16.67,
+      locationContext: "Warehouse",
+      percentChange: -50,
+      direction: "down",
+    });
+    const result = parseContextData(json);
+    expect(result.summary).toBe("Test");
+    expect(result.velocityContext).toBe("selling 8/day");
+    expect(result.revenueImpact).toBe(16.67);
+    expect(result.locationContext).toBe("Warehouse");
+    expect(result.percentChange).toBe(-50);
+    expect(result.direction).toBe("down");
+  });
+
+  it("should return defaults for null input", () => {
+    const result = parseContextData(null);
+    expect(result.summary).toBeNull();
+    expect(result.velocityContext).toBeNull();
+    expect(result.revenueImpact).toBeNull();
+    expect(result.percentChange).toBeNull();
+    expect(result.direction).toBeNull();
+  });
+
+  it("should return defaults for invalid JSON", () => {
+    const result = parseContextData("not json");
+    expect(result.summary).toBeNull();
+  });
+
+  it("should handle legacy contextData without summary field", () => {
+    const json = JSON.stringify({ velocityContext: "selling 8/day", revenueImpact: 10 });
+    const result = parseContextData(json);
+    expect(result.summary).toBeNull();
+    expect(result.velocityContext).toBe("selling 8/day");
+    expect(result.revenueImpact).toBe(10);
+  });
+
+  it("should reject invalid direction values", () => {
+    const json = JSON.stringify({ direction: "sideways" });
+    const result = parseContextData(json);
+    expect(result.direction).toBeNull();
+  });
+});
diff --git a/insightops/app/services/dailyDigest.server.ts b/insightops/app/services/dailyDigest.server.ts
index 02b6584..8950192 100644
--- a/insightops/app/services/dailyDigest.server.ts
+++ b/insightops/app/services/dailyDigest.server.ts
@@ -28,13 +28,7 @@ export interface DigestSummary {
   periodEnd: Date;
   totalChanges: number;
   highPriorityCount: number;
-  eventsByType: {
-    price_change: DigestEvent[];
-    visibility_change: DigestEvent[];
-    inventory_low: DigestEvent[];
-    inventory_zero: DigestEvent[];
-    theme_publish: DigestEvent[];
-  };
+  eventsByType: Record<string, DigestEvent[]>;
 }
 
 /**
@@ -110,14 +104,8 @@ export async function generateDigestForShop(shopDomain: string): Promise<DigestS
     return null;
   }
 
-  // Group events by type
-  const eventsByType = {
-    price_change: [] as DigestEvent[],
-    visibility_change: [] as DigestEvent[],
-    inventory_low: [] as DigestEvent[],
-    inventory_zero: [] as DigestEvent[],
-    theme_publish: [] as DigestEvent[],
-  };
+  // Group events by type dynamically
+  const eventsByType: Record<string, DigestEvent[]> = {};
 
   let highPriorityCount = 0;
 
@@ -139,11 +127,10 @@ export async function generateDigestForShop(shopDomain: string): Promise<DigestS
       highPriorityCount++;
     }
 
-    // Add to appropriate category
-    const eventType = event.eventType as keyof typeof eventsByType;
-    if (eventsByType[eventType]) {
-      eventsByType[eventType].push(digestEvent);
+    if (!eventsByType[event.eventType]) {
+      eventsByType[event.eventType] = [];
     }
+    eventsByType[event.eventType].push(digestEvent);
   }
 
   // Build summary
@@ -181,14 +168,10 @@ export async function markEventsAsDigested(eventIds: string[]): Promise<void> {
  * Get all event IDs from a digest summary
  */
 export function getEventIdsFromDigest(digest: DigestSummary): string[] {
-  const allEvents = [
-    ...digest.eventsByType.price_change,
-    ...digest.eventsByType.visibility_change,
-    ...digest.eventsByType.inventory_low,
-    ...digest.eventsByType.inventory_zero,
-    ...digest.eventsByType.theme_publish,
-  ];
-
+  const allEvents: DigestEvent[] = [];
+  for (const events of Object.values(digest.eventsByType)) {
+    allEvents.push(...events);
+  }
   return allEvents.map((e) => e.id);
 }
 
@@ -207,8 +190,26 @@ export function formatEventType(eventType: string): string {
       return "Out of Stock";
     case "theme_publish":
       return "Theme Published";
+    case "collection_created":
+      return "Collection Created";
+    case "collection_updated":
+      return "Collection Updated";
+    case "collection_deleted":
+      return "Collection Deleted";
+    case "discount_created":
+      return "Discount Created";
+    case "discount_changed":
+      return "Discount Changed";
+    case "discount_deleted":
+      return "Discount Deleted";
+    case "app_permissions_changed":
+      return "App Permissions Changed";
+    case "domain_changed":
+      return "Domain Changed";
+    case "domain_removed":
+      return "Domain Removed";
     default:
-      return eventType;
+      return eventType.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
   }
 }
 
@@ -233,7 +234,25 @@ export function formatEventForEmail(event: DigestEvent): string {
       return `${event.resourceName}: now out of stock (was ${event.beforeValue} units) (${time})`;
     case "theme_publish":
       return `"${event.resourceName}" is now your live theme (${time})`;
+    case "collection_created":
+      return `Collection "${event.resourceName}" was created (${time})`;
+    case "collection_updated":
+      return `Collection "${event.resourceName}" was updated (${time})`;
+    case "collection_deleted":
+      return `Collection "${event.resourceName}" was deleted (${time})`;
+    case "discount_created":
+      return `Discount "${event.resourceName}" was created (${time})`;
+    case "discount_changed":
+      return `Discount "${event.resourceName}" was modified: ${event.beforeValue ?? ""} → ${event.afterValue ?? ""} (${time})`;
+    case "discount_deleted":
+      return `Discount "${event.resourceName}" was deleted (${time})`;
+    case "app_permissions_changed":
+      return `App permissions changed: ${event.resourceName} (${time})`;
+    case "domain_changed":
+      return `Domain "${event.resourceName}" was added or changed (${time})`;
+    case "domain_removed":
+      return `Domain "${event.resourceName}" was removed (${time})`;
     default:
-      return `${event.resourceName}: ${event.beforeValue} → ${event.afterValue} (${time})`;
+      return `${event.resourceName}: ${event.beforeValue ?? ""} → ${event.afterValue ?? ""} (${time})`;
   }
 }
diff --git a/insightops/app/services/dailyDigest.test.ts b/insightops/app/services/dailyDigest.test.ts
index 0723be2..2530eaf 100644
--- a/insightops/app/services/dailyDigest.test.ts
+++ b/insightops/app/services/dailyDigest.test.ts
@@ -105,8 +105,29 @@ describe("formatEventType", () => {
     expect(formatEventType("theme_publish")).toBe("Theme Published");
   });
 
-  it("should return raw event type for unknown types", () => {
-    expect(formatEventType("unknown_event")).toBe("unknown_event");
+  it("should format collection event types", () => {
+    expect(formatEventType("collection_created")).toBe("Collection Created");
+    expect(formatEventType("collection_updated")).toBe("Collection Updated");
+    expect(formatEventType("collection_deleted")).toBe("Collection Deleted");
+  });
+
+  it("should format discount event types", () => {
+    expect(formatEventType("discount_created")).toBe("Discount Created");
+    expect(formatEventType("discount_changed")).toBe("Discount Changed");
+    expect(formatEventType("discount_deleted")).toBe("Discount Deleted");
+  });
+
+  it("should format app permissions event type", () => {
+    expect(formatEventType("app_permissions_changed")).toBe("App Permissions Changed");
+  });
+
+  it("should format domain event types", () => {
+    expect(formatEventType("domain_changed")).toBe("Domain Changed");
+    expect(formatEventType("domain_removed")).toBe("Domain Removed");
+  });
+
+  it("should title-case unknown event types", () => {
+    expect(formatEventType("unknown_event")).toBe("Unknown Event");
   });
 });
 
@@ -182,4 +203,67 @@ describe("formatEventForEmail", () => {
     expect(result).toContain("Dawn 2.0");
     expect(result).toContain("live theme");
   });
+
+  it("should format collection created event", () => {
+    const event = makeEvent({
+      eventType: "collection_created",
+      entityType: "collection",
+      resourceName: "Summer Sale",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("Summer Sale");
+    expect(result).toContain("created");
+  });
+
+  it("should format collection deleted event", () => {
+    const event = makeEvent({
+      eventType: "collection_deleted",
+      entityType: "collection",
+      resourceName: "Old Collection",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("Old Collection");
+    expect(result).toContain("deleted");
+  });
+
+  it("should format discount created event", () => {
+    const event = makeEvent({
+      eventType: "discount_created",
+      entityType: "discount",
+      resourceName: "SUMMER50",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("SUMMER50");
+    expect(result).toContain("created");
+  });
+
+  it("should format discount changed event", () => {
+    const event = makeEvent({
+      eventType: "discount_changed",
+      entityType: "discount",
+      resourceName: "BLACKFRIDAY",
+      beforeValue: "20%",
+      afterValue: "50%",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("BLACKFRIDAY");
+    expect(result).toContain("20%");
+    expect(result).toContain("50%");
+  });
+
+  it("should format discount deleted event", () => {
+    const event = makeEvent({
+      eventType: "discount_deleted",
+      entityType: "discount",
+      resourceName: "EXPIRED10",
+    });
+
+    const result = formatEventForEmail(event);
+    expect(result).toContain("EXPIRED10");
+    expect(result).toContain("deleted");
+  });
 });
diff --git a/insightops/app/services/emailService.server.ts b/insightops/app/services/emailService.server.ts
index 5366b10..b5af624 100644
--- a/insightops/app/services/emailService.server.ts
+++ b/insightops/app/services/emailService.server.ts
@@ -1,17 +1,22 @@
 /**
  * Email Service for StoreGuard
  *
- * Sends emails via Resend API.
+ * Sends emails via Resend API. Template generation is in emailTemplates.server.ts.
  * Environment variables required:
  * - RESEND_API_KEY: Your Resend API key
  * - DIGEST_FROM_EMAIL: Sender email (e.g., alerts@storeguard.app)
  */
 
+import type { DigestSummary } from "./dailyDigest.server";
 import {
-  type DigestSummary,
-  formatEventType,
-  formatEventForEmail,
-} from "./dailyDigest.server";
+  generateDigestEmailHtml,
+  generateInstantAlertHtml,
+  getInstantAlertSubject,
+  type InstantAlertEvent,
+} from "./emailTemplates.server";
+
+// Re-export template functions for consumers that import from here
+export { generateDigestEmailHtml, generateInstantAlertHtml, type InstantAlertEvent };
 
 const RESEND_API_KEY = process.env.RESEND_API_KEY;
 const FROM_EMAIL = process.env.DIGEST_FROM_EMAIL || "StoreGuard <alerts@storeguard.app>";
@@ -67,382 +72,18 @@ async function sendEmail(
   }
 }
 
-/**
- * Generate HTML email for daily digest
- */
-export function generateDigestEmailHtml(digest: DigestSummary): string {
-  const shopName = digest.shop.replace(".myshopify.com", "");
-  const dateStr = digest.generatedAt.toLocaleDateString("en-US", {
-    weekday: "long",
-    year: "numeric",
-    month: "long",
-    day: "numeric",
-  });
-
-  // Build sections for each event type
-  const sections: string[] = [];
-
-  // Price changes
-  if (digest.eventsByType.price_change.length > 0) {
-    sections.push(buildEventSection(
-      "💰 Price Changes",
-      digest.eventsByType.price_change,
-      "#f59e0b" // amber
-    ));
-  }
-
-  // Visibility changes
-  if (digest.eventsByType.visibility_change.length > 0) {
-    sections.push(buildEventSection(
-      "👁️ Visibility Changes",
-      digest.eventsByType.visibility_change,
-      "#8b5cf6" // purple
-    ));
-  }
-
-  // Low stock
-  if (digest.eventsByType.inventory_low && digest.eventsByType.inventory_low.length > 0) {
-    sections.push(buildEventSection(
-      "⚠️ Low Stock",
-      digest.eventsByType.inventory_low,
-      "#f97316" // orange
-    ));
-  }
-
-  // Out of stock
-  if (digest.eventsByType.inventory_zero.length > 0) {
-    sections.push(buildEventSection(
-      "📦 Out of Stock",
-      digest.eventsByType.inventory_zero,
-      "#ef4444" // red
-    ));
-  }
-
-  // Theme publishes
-  if (digest.eventsByType.theme_publish.length > 0) {
-    sections.push(buildEventSection(
-      "🎨 Theme Published",
-      digest.eventsByType.theme_publish,
-      "#06b6d4" // cyan
-    ));
-  }
-
-  const sectionsHtml = sections.join("");
-
-  // Summary stats
-  const highPriorityBadge = digest.highPriorityCount > 0
-    ? `<span style="background: #fef2f2; color: #dc2626; padding: 4px 12px; border-radius: 12px; font-size: 13px; font-weight: 600;">${digest.highPriorityCount} High Priority</span>`
-    : "";
-
-  return `
-<!DOCTYPE html>
-<html>
-<head>
-  <meta charset="utf-8">
-  <meta name="viewport" content="width=device-width, initial-scale=1.0">
-  <title>StoreGuard Daily Digest</title>
-</head>
-<body style="margin: 0; padding: 0; background: #f3f4f6; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
-  <div style="max-width: 600px; margin: 0 auto; padding: 24px;">
-    <!-- Header -->
-    <div style="background: #000; color: #fff; padding: 24px; border-radius: 12px 12px 0 0; text-align: center;">
-      <h1 style="margin: 0; font-size: 24px; font-weight: 600;">🛡️ StoreGuard</h1>
-      <p style="margin: 8px 0 0; opacity: 0.8; font-size: 14px;">Daily Digest for ${shopName}</p>
-    </div>
-
-    <!-- Summary -->
-    <div style="background: #fff; padding: 24px; border-bottom: 1px solid #e5e7eb;">
-      <p style="margin: 0 0 12px; color: #6b7280; font-size: 14px;">${dateStr}</p>
-      <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
-        <span style="background: #f3f4f6; color: #374151; padding: 8px 16px; border-radius: 8px; font-size: 16px; font-weight: 600;">
-          ${digest.totalChanges} Change${digest.totalChanges !== 1 ? "s" : ""} Detected
-        </span>
-        ${highPriorityBadge}
-      </div>
-    </div>
-
-    <!-- Event Sections -->
-    <div style="background: #fff;">
-      ${sectionsHtml}
-    </div>
-
-    <!-- Footer -->
-    <div style="background: #fff; padding: 24px; border-radius: 0 0 12px 12px; border-top: 1px solid #e5e7eb; text-align: center;">
-      <p style="margin: 0 0 8px; color: #6b7280; font-size: 13px;">
-        You're receiving this because you enabled daily digests in StoreGuard.
-      </p>
-      <p style="margin: 0; color: #9ca3af; font-size: 12px;">
-        <a href="https://${digest.shop}/admin/apps/storeguard/settings" style="color: #6b7280;">Manage notification settings</a>
-      </p>
-    </div>
-  </div>
-</body>
-</html>
-`.trim();
-}
-
-/**
- * Build HTML section for a group of events
- */
-function buildEventSection(
-  title: string,
-  events: DigestSummary["eventsByType"]["price_change"],
-  accentColor: string
-): string {
-  const eventItems = events
-    .map((event) => {
-      const importanceDot = event.importance === "high"
-        ? `<span style="display: inline-block; width: 8px; height: 8px; background: #ef4444; border-radius: 50%; margin-right: 8px;"></span>`
-        : "";
-
-      return `
-        <div style="padding: 12px 0; border-bottom: 1px solid #f3f4f6;">
-          ${importanceDot}<strong style="color: #111827;">${event.resourceName}</strong>
-          <div style="margin-top: 4px; color: #6b7280; font-size: 13px;">
-            ${formatChangeDescription(event)}
-          </div>
-        </div>
-      `;
-    })
-    .join("");
-
-  return `
-    <div style="padding: 0 24px;">
-      <div style="padding: 16px 0; border-bottom: 2px solid ${accentColor};">
-        <h2 style="margin: 0; font-size: 16px; font-weight: 600; color: #111827;">${title}</h2>
-        <p style="margin: 4px 0 0; font-size: 13px; color: #6b7280;">${events.length} change${events.length !== 1 ? "s" : ""}</p>
-      </div>
-      ${eventItems}
-    </div>
-  `;
-}
-
-/**
- * Format change description for email
- */
-function formatChangeDescription(event: DigestSummary["eventsByType"]["price_change"][0]): string {
-  const time = event.detectedAt.toLocaleTimeString("en-US", {
-    hour: "numeric",
-    minute: "2-digit",
-    hour12: true,
-  });
-
-  // Parse context data for sales velocity
-  let velocitySuffix = "";
-  if (event.contextData) {
-    try {
-      const ctx = JSON.parse(event.contextData) as {
-        velocityContext?: string | null;
-      };
-      if (ctx.velocityContext) {
-        velocitySuffix = ` — ${ctx.velocityContext}`;
-      }
-    } catch {
-      // Ignore invalid context
-    }
-  }
-
-  switch (event.eventType) {
-    case "price_change":
-      return `${event.beforeValue} → ${event.afterValue}${velocitySuffix} • ${time}`;
-    case "visibility_change":
-      return `${event.beforeValue} → ${event.afterValue}${velocitySuffix} • ${time}`;
-    case "inventory_low":
-      return `Stock dropped to ${event.afterValue} units (was ${event.beforeValue})${velocitySuffix} • ${time}`;
-    case "inventory_zero":
-      return `Now out of stock (was ${event.beforeValue} units)${velocitySuffix} • ${time}`;
-    case "theme_publish":
-      return `Now your live theme • ${time}`;
-    default:
-      return `${event.beforeValue} → ${event.afterValue}${velocitySuffix} • ${time}`;
-  }
-}
-
 /**
  * Send daily digest email for a shop
  */
 export async function sendDigestEmail(digest: DigestSummary): Promise<SendEmailResult> {
   const shopName = digest.shop.replace(".myshopify.com", "");
-  const subject = `🛡️ StoreGuard: ${digest.totalChanges} change${digest.totalChanges !== 1 ? "s" : ""} detected on ${shopName}`;
+  const subject = `StoreGuard: ${digest.totalChanges} change${digest.totalChanges !== 1 ? "s" : ""} detected on ${shopName}`;
 
   const html = generateDigestEmailHtml(digest);
 
   return sendEmail(digest.alertEmail, subject, html);
 }
 
-// ============================================
-// INSTANT ALERTS
-// ============================================
-
-interface InstantAlertEvent {
-  eventType: string;
-  resourceName: string;
-  beforeValue: string | null;
-  afterValue: string | null;
-  importance: string;
-  detectedAt: Date;
-  contextData?: string | null;
-}
-
-/**
- * Get subject line for instant alert based on event type
- */
-function getInstantAlertSubject(event: InstantAlertEvent, shopName: string): string {
-  switch (event.eventType) {
-    case "price_change":
-      return `⚡ Price changed: ${event.resourceName} - ${shopName}`;
-    case "visibility_change":
-      return `⚡ Product ${event.afterValue === "active" ? "published" : "hidden"}: ${event.resourceName} - ${shopName}`;
-    case "inventory_low":
-      return `⚠️ Low stock: ${event.resourceName} (${event.afterValue} left) - ${shopName}`;
-    case "inventory_zero":
-      return `🚨 Out of stock: ${event.resourceName} - ${shopName}`;
-    case "theme_publish":
-      return `🎨 Theme published: ${event.resourceName} - ${shopName}`;
-    default:
-      return `⚡ Change detected: ${event.resourceName} - ${shopName}`;
-  }
-}
-
-/**
- * Get alert icon based on event type
- */
-function getAlertIcon(eventType: string): string {
-  switch (eventType) {
-    case "price_change": return "💰";
-    case "visibility_change": return "👁️";
-    case "inventory_low": return "⚠️";
-    case "inventory_zero": return "🚨";
-    case "theme_publish": return "🎨";
-    default: return "⚡";
-  }
-}
-
-/**
- * Get alert color based on event type
- */
-function getAlertColor(eventType: string): string {
-  switch (eventType) {
-    case "price_change": return "#f59e0b";
-    case "visibility_change": return "#8b5cf6";
-    case "inventory_low": return "#f97316";
-    case "inventory_zero": return "#ef4444";
-    case "theme_publish": return "#06b6d4";
-    default: return "#6b7280";
-  }
-}
-
-/**
- * Generate HTML for instant alert email
- */
-function generateInstantAlertHtml(
-  event: InstantAlertEvent,
-  shop: string
-): string {
-  const shopName = shop.replace(".myshopify.com", "");
-  const icon = getAlertIcon(event.eventType);
-  const color = getAlertColor(event.eventType);
-  const time = event.detectedAt.toLocaleString("en-US", {
-    weekday: "short",
-    month: "short",
-    day: "numeric",
-    hour: "numeric",
-    minute: "2-digit",
-    hour12: true,
-  });
-
-  // Parse context data for sales velocity
-  let velocityContext: string | null = null;
-  let revenueImpact: number | null = null;
-  if (event.contextData) {
-    try {
-      const ctx = JSON.parse(event.contextData) as {
-        velocityContext?: string | null;
-        revenueImpact?: number | null;
-      };
-      velocityContext = ctx.velocityContext ?? null;
-      revenueImpact = ctx.revenueImpact ?? null;
-    } catch {
-      // Invalid context data
-    }
-  }
-
-  // Build change description
-  let changeDescription = "";
-  switch (event.eventType) {
-    case "price_change":
-      changeDescription = `Price changed from ${event.beforeValue} to ${event.afterValue}`;
-      break;
-    case "visibility_change":
-      changeDescription = `Status changed from ${event.beforeValue} to ${event.afterValue}`;
-      break;
-    case "inventory_low":
-      changeDescription = `Stock dropped to ${event.afterValue} units (was ${event.beforeValue})`;
-      break;
-    case "inventory_zero":
-      changeDescription = `Now out of stock (was ${event.beforeValue} units)`;
-      break;
-    case "theme_publish":
-      changeDescription = `"${event.resourceName}" is now your live theme`;
-      break;
-    default:
-      changeDescription = `${event.beforeValue || ""} → ${event.afterValue || ""}`;
-  }
-
-  // Append sales velocity context
-  if (velocityContext) {
-    changeDescription += ` — ${velocityContext}`;
-  }
-
-  return `
-<!DOCTYPE html>
-<html>
-<head>
-  <meta charset="utf-8">
-  <meta name="viewport" content="width=device-width, initial-scale=1.0">
-  <title>StoreGuard Alert</title>
-</head>
-<body style="margin: 0; padding: 0; background: #f3f4f6; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;">
-  <div style="max-width: 500px; margin: 0 auto; padding: 24px;">
-    <!-- Header -->
-    <div style="background: ${color}; color: #fff; padding: 20px; border-radius: 12px 12px 0 0; text-align: center;">
-      <div style="font-size: 32px; margin-bottom: 8px;">${icon}</div>
-      <h1 style="margin: 0; font-size: 18px; font-weight: 600;">Instant Alert</h1>
-      <p style="margin: 4px 0 0; opacity: 0.9; font-size: 13px;">${shopName}</p>
-    </div>
-
-    <!-- Content -->
-    <div style="background: #fff; padding: 24px; border-radius: 0 0 12px 12px;">
-      <h2 style="margin: 0 0 8px; font-size: 18px; font-weight: 600; color: #111827;">
-        ${event.resourceName}
-      </h2>
-      <p style="margin: 0 0 16px; color: #374151; font-size: 15px;">
-        ${changeDescription}
-      </p>
-      ${revenueImpact !== null ? `<p style="margin: 0 0 16px; color: #dc2626; font-size: 14px; font-weight: 500;">Estimated impact: ~$${revenueImpact.toFixed(2)}/hr until fixed</p>` : ""}
-      <p style="margin: 0; color: #9ca3af; font-size: 13px;">
-        Detected at ${time}
-      </p>
-
-      <!-- Action -->
-      <div style="margin-top: 24px; padding-top: 16px; border-top: 1px solid #e5e7eb;">
-        <a href="https://${shop}/admin"
-           style="display: inline-block; background: #000; color: #fff; padding: 10px 20px; border-radius: 6px; text-decoration: none; font-size: 14px; font-weight: 500;">
-          View in Shopify Admin
-        </a>
-      </div>
-    </div>
-
-    <!-- Footer -->
-    <p style="margin: 16px 0 0; text-align: center; color: #9ca3af; font-size: 12px;">
-      <a href="https://${shop}/admin/apps/storeguard/settings" style="color: #6b7280;">Manage instant alerts</a>
-    </p>
-  </div>
-</body>
-</html>
-`.trim();
-}
-
 /**
  * Send instant alert email for a single change event
  */
diff --git a/insightops/app/services/emailTemplates.server.ts b/insightops/app/services/emailTemplates.server.ts
new file mode 100644
index 0000000..9fa1d20
--- /dev/null
+++ b/insightops/app/services/emailTemplates.server.ts
@@ -0,0 +1,493 @@
+/**
+ * Email Templates for StoreGuard
+ *
+ * Responsive HTML email templates compatible with Gmail, Apple Mail, and Outlook.
+ * - Table-based layout (Outlook uses Word renderer, no CSS flex/grid)
+ * - All CSS inline (Gmail strips <style> blocks)
+ * - 320px minimum width, single column
+ * - 14px body font, proper line-heights
+ * - StoreGuard branding with shield icon
+ */
+
+import type { DigestSummary, DigestEvent } from "./dailyDigest.server";
+
+// ============================================
+// SHARED CONSTANTS
+// ============================================
+
+const BRAND_COLOR = "#111827";
+const BODY_BG = "#f3f4f6";
+const CARD_BG = "#ffffff";
+const TEXT_PRIMARY = "#111827";
+const TEXT_SECONDARY = "#6b7280";
+const TEXT_MUTED = "#9ca3af";
+const BORDER_COLOR = "#e5e7eb";
+const BORDER_LIGHT = "#f3f4f6";
+const HIGH_PRIORITY_BG = "#fef2f2";
+const HIGH_PRIORITY_TEXT = "#dc2626";
+const FONT_STACK = "-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif";
+
+/** Shield icon as a simple HTML entity + text (renders consistently across all email clients) */
+const SHIELD_ICON = "&#x1F6E1;&#xFE0F;";
+
+/** Event type display config: title, color, display order */
+export const EVENT_TYPE_CONFIG: Record<string, { title: string; color: string; order: number }> = {
+  price_change: { title: "Price Changes", color: "#f59e0b", order: 1 },
+  visibility_change: { title: "Visibility Changes", color: "#8b5cf6", order: 2 },
+  inventory_low: { title: "Low Stock", color: "#f97316", order: 3 },
+  inventory_zero: { title: "Out of Stock", color: "#ef4444", order: 4 },
+  theme_publish: { title: "Theme Published", color: "#06b6d4", order: 5 },
+  collection_created: { title: "Collection Created", color: "#10b981", order: 6 },
+  collection_updated: { title: "Collection Updated", color: "#10b981", order: 7 },
+  collection_deleted: { title: "Collection Deleted", color: "#ef4444", order: 8 },
+  discount_created: { title: "Discount Created", color: "#8b5cf6", order: 9 },
+  discount_changed: { title: "Discount Changed", color: "#8b5cf6", order: 10 },
+  discount_deleted: { title: "Discount Deleted", color: "#ef4444", order: 11 },
+  app_permissions_changed: { title: "App Permissions Changed", color: "#6366f1", order: 12 },
+  domain_changed: { title: "Domain Changed", color: "#0891b2", order: 13 },
+  domain_removed: { title: "Domain Removed", color: "#ef4444", order: 14 },
+};
+
+// ============================================
+// SHARED HELPERS
+// ============================================
+
+/** Wrap content in the standard email document shell */
+function emailShell(title: string, body: string): string {
+  return `<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
+<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
+<head>
+  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
+  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
+  <title>${title}</title>
+  <!--[if mso]>
+  <style type="text/css">
+    table { border-collapse: collapse; }
+    .button-link { padding: 12px 24px !important; }
+  </style>
+  <![endif]-->
+</head>
+<body style="margin: 0; padding: 0; background-color: ${BODY_BG}; font-family: ${FONT_STACK}; font-size: 14px; line-height: 1.5; color: ${TEXT_PRIMARY}; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%;">
+  <!-- Outer wrapper table for full-width background -->
+  <table role="presentation" cellpadding="0" cellspacing="0" border="0" width="100%" style="background-color: ${BODY_BG};">
+    <tr>
+      <td align="center" style="padding: 24px 16px;">
+        <!-- Inner content table with max-width -->
+        <!--[if mso]><table role="presentation" cellpadding="0" cellspacing="0" border="0" width="600"><tr><td><![endif]-->
+        <table role="presentation" cellpadding="0" cellspacing="0" border="0" width="100%" style="max-width: 600px; min-width: 320px;">
+          ${body}
+        </table>
+        <!--[if mso]></td></tr></table><![endif]-->
+      </td>
+    </tr>
+  </table>
+</body>
+</html>`;
+}
+
+/** Parse contextData JSON safely */
+function parseContextData(contextData: string | null | undefined): {
+  summary: string | null;
+  velocityContext: string | null;
+  locationContext: string | null;
+  revenueImpact: number | null;
+  percentChange: number | null;
+  direction: "up" | "down" | null;
+} {
+  if (!contextData) return { summary: null, velocityContext: null, locationContext: null, revenueImpact: null, percentChange: null, direction: null };
+  try {
+    const ctx = JSON.parse(contextData) as Record<string, unknown>;
+    return {
+      summary: typeof ctx.summary === "string" ? ctx.summary : null,
+      velocityContext: typeof ctx.velocityContext === "string" ? ctx.velocityContext : null,
+      locationContext: typeof ctx.locationContext === "string" ? ctx.locationContext : null,
+      revenueImpact: typeof ctx.revenueImpact === "number" ? ctx.revenueImpact : null,
+      percentChange: typeof ctx.percentChange === "number" ? ctx.percentChange : null,
+      direction: ctx.direction === "up" || ctx.direction === "down" ? ctx.direction : null,
+    };
+  } catch {
+    return { summary: null, velocityContext: null, locationContext: null, revenueImpact: null, percentChange: null, direction: null };
+  }
+}
+
+/** Get the accent color for an event type */
+export function getAlertColor(eventType: string): string {
+  return EVENT_TYPE_CONFIG[eventType]?.color ?? "#6b7280";
+}
+
+// ============================================
+// DAILY DIGEST EMAIL
+// ============================================
+
+/** Format a change description for digest email rows */
+export function formatDigestChangeDescription(event: DigestEvent): string {
+  const time = event.detectedAt.toLocaleTimeString("en-US", {
+    hour: "numeric",
+    minute: "2-digit",
+    hour12: true,
+  });
+
+  const ctx = parseContextData(event.contextData);
+
+  // Use enriched summary when available for price, inventory, visibility, theme events
+  if (ctx.summary) {
+    const revenueNote = ctx.revenueImpact !== null
+      ? ` &mdash; ~$${ctx.revenueImpact.toFixed(2)}/hr at risk`
+      : "";
+    return `${ctx.summary}${revenueNote} &bull; ${time}`;
+  }
+
+  // Fallback for events without enriched context (collections, discounts, etc.)
+  let suffix = "";
+  if (ctx.locationContext) suffix += ` &mdash; ${ctx.locationContext}`;
+  if (ctx.velocityContext) suffix += ` &mdash; ${ctx.velocityContext}`;
+
+  switch (event.eventType) {
+    case "price_change":
+      return `${event.beforeValue} &rarr; ${event.afterValue}${suffix} &bull; ${time}`;
+    case "visibility_change":
+      return `${event.beforeValue} &rarr; ${event.afterValue}${suffix} &bull; ${time}`;
+    case "inventory_low":
+      return `Stock dropped to ${event.afterValue} units (was ${event.beforeValue})${suffix} &bull; ${time}`;
+    case "inventory_zero":
+      return `Now out of stock (was ${event.beforeValue} units)${suffix} &bull; ${time}`;
+    case "theme_publish":
+      return `Now your live theme &bull; ${time}`;
+    case "collection_created":
+      return `New collection created &bull; ${time}`;
+    case "collection_updated":
+      return `Collection updated &bull; ${time}`;
+    case "collection_deleted":
+      return `Collection deleted &bull; ${time}`;
+    case "discount_created":
+      return `Discount created &bull; ${time}`;
+    case "discount_changed":
+      return `${event.beforeValue ?? ""} &rarr; ${event.afterValue ?? ""} &bull; ${time}`;
+    case "discount_deleted":
+      return `Discount deleted &bull; ${time}`;
+    case "app_permissions_changed":
+      return `Permissions changed &bull; ${time}`;
+    case "domain_changed":
+      return `Domain added or changed &bull; ${time}`;
+    case "domain_removed":
+      return `Domain removed &bull; ${time}`;
+    default:
+      return `${event.beforeValue ?? ""} &rarr; ${event.afterValue ?? ""}${suffix} &bull; ${time}`;
+  }
+}
+
+/** Build a single event row for the digest */
+function buildEventRow(event: DigestEvent): string {
+  const importanceDot = event.importance === "high"
+    ? `<td width="12" valign="top" style="padding-top: 4px;"><table role="presentation" cellpadding="0" cellspacing="0" border="0"><tr><td width="8" height="8" style="width: 8px; height: 8px; background-color: ${HIGH_PRIORITY_TEXT}; border-radius: 50%; font-size: 1px; line-height: 1px;">&nbsp;</td></tr></table></td>`
+    : `<td width="12" style="font-size: 1px; line-height: 1px;">&nbsp;</td>`;
+
+  return `<tr>
+  <td style="padding: 12px 0; border-bottom: 1px solid ${BORDER_LIGHT};">
+    <table role="presentation" cellpadding="0" cellspacing="0" border="0" width="100%">
+      <tr>
+        ${importanceDot}
+        <td style="font-family: ${FONT_STACK};">
+          <strong style="color: ${TEXT_PRIMARY}; font-size: 14px;">${event.resourceName}</strong>
+          <div style="margin-top: 4px; color: ${TEXT_SECONDARY}; font-size: 13px; line-height: 1.4;">
+            ${formatDigestChangeDescription(event)}
+          </div>
+        </td>
+      </tr>
+    </table>
+  </td>
+</tr>`;
+}
+
+/** Build a section for a group of events (e.g., "Price Changes") */
+function buildEventSection(title: string, events: DigestEvent[], accentColor: string): string {
+  const rows = events.map(buildEventRow).join("");
+
+  return `<tr>
+  <td style="padding: 0 24px;">
+    <table role="presentation" cellpadding="0" cellspacing="0" border="0" width="100%">
+      <tr>
+        <td style="padding: 16px 0; border-bottom: 2px solid ${accentColor};">
+          <h2 style="margin: 0; font-size: 16px; font-weight: 600; color: ${TEXT_PRIMARY}; font-family: ${FONT_STACK};">${title}</h2>
+          <p style="margin: 4px 0 0; font-size: 13px; color: ${TEXT_SECONDARY}; font-family: ${FONT_STACK};">${events.length} change${events.length !== 1 ? "s" : ""}</p>
+        </td>
+      </tr>
+      ${rows}
+    </table>
+  </td>
+</tr>`;
+}
+
+/** Generate the full HTML email for a daily digest */
+export function generateDigestEmailHtml(digest: DigestSummary): string {
+  const shopName = digest.shop.replace(".myshopify.com", "");
+  const dateStr = digest.generatedAt.toLocaleDateString("en-US", {
+    weekday: "long",
+    year: "numeric",
+    month: "long",
+    day: "numeric",
+  });
+
+  // Build sections sorted by display order
+  const sortedTypes = Object.entries(digest.eventsByType)
+    .filter(([, events]) => events.length > 0)
+    .sort(([a], [b]) => {
+      const orderA = EVENT_TYPE_CONFIG[a]?.order ?? 99;
+      const orderB = EVENT_TYPE_CONFIG[b]?.order ?? 99;
+      return orderA - orderB;
+    });
+
+  const sectionRows = sortedTypes
+    .map(([eventType, events]) => {
+      const config = EVENT_TYPE_CONFIG[eventType] ?? {
+        title: eventType.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase()),
+        color: "#6b7280",
+      };
+      return buildEventSection(config.title, events, config.color);
+    })
+    .join("");
+
+  const highPriorityCell = digest.highPriorityCount > 0
+    ? `<td style="padding-left: 8px;">
+        <table role="presentation" cellpadding="0" cellspacing="0" border="0">
+          <tr>
+            <td style="background-color: ${HIGH_PRIORITY_BG}; color: ${HIGH_PRIORITY_TEXT}; padding: 4px 12px; border-radius: 12px; font-size: 13px; font-weight: 600; font-family: ${FONT_STACK};">${digest.highPriorityCount} High Priority</td>
+          </tr>
+        </table>
+      </td>`
+    : "";
+
+  const body = `
+<!-- Header -->
+<tr>
+  <td align="center" bgcolor="${BRAND_COLOR}" style="background-color: ${BRAND_COLOR}; padding: 28px 24px; border-radius: 8px 8px 0 0;">
+    <h1 style="margin: 0; font-size: 22px; font-weight: 700; color: #ffffff; font-family: ${FONT_STACK};">${SHIELD_ICON} StoreGuard</h1>
+    <p style="margin: 8px 0 0; font-size: 14px; color: #a1a1aa; font-family: ${FONT_STACK};">Daily Digest for ${shopName}</p>
+  </td>
+</tr>
+<!-- Summary -->
+<tr>
+  <td bgcolor="${CARD_BG}" style="background-color: ${CARD_BG}; padding: 24px; border-bottom: 1px solid ${BORDER_COLOR};">
+    <p style="margin: 0 0 12px; color: ${TEXT_SECONDARY}; font-size: 14px; font-family: ${FONT_STACK};">${dateStr}</p>
+    <table role="presentation" cellpadding="0" cellspacing="0" border="0">
+      <tr>
+        <td style="background-color: ${BORDER_LIGHT}; color: #374151; padding: 8px 16px; border-radius: 8px; font-size: 16px; font-weight: 600; font-family: ${FONT_STACK};">
+          ${digest.totalChanges} Change${digest.totalChanges !== 1 ? "s" : ""} Detected
+        </td>
+        ${highPriorityCell}
+      </tr>
+    </table>
+  </td>
+</tr>
+<!-- Event Sections -->
+<tr>
+  <td bgcolor="${CARD_BG}" style="background-color: ${CARD_BG};">
+    <table role="presentation" cellpadding="0" cellspacing="0" border="0" width="100%">
+      ${sectionRows}
+    </table>
+  </td>
+</tr>
+<!-- Footer -->
+<tr>
+  <td bgcolor="${CARD_BG}" style="background-color: ${CARD_BG}; padding: 24px; border-radius: 0 0 8px 8px; border-top: 1px solid ${BORDER_COLOR}; text-align: center;">
+    <p style="margin: 0 0 8px; color: ${TEXT_SECONDARY}; font-size: 13px; font-family: ${FONT_STACK};">
+      You're receiving this because you enabled daily digests in StoreGuard.
+    </p>
+    <p style="margin: 0; font-size: 12px; font-family: ${FONT_STACK};">
+      <a href="https://${digest.shop}/admin/apps/storeguard/settings" style="color: ${TEXT_SECONDARY}; text-decoration: underline;">Manage notification settings</a>
+    </p>
+  </td>
+</tr>`;
+
+  return emailShell("StoreGuard Daily Digest", body);
+}
+
+// ============================================
+// INSTANT ALERT EMAIL
+// ============================================
+
+export interface InstantAlertEvent {
+  eventType: string;
+  resourceName: string;
+  beforeValue: string | null;
+  afterValue: string | null;
+  importance: string;
+  detectedAt: Date;
+  contextData?: string | null;
+}
+
+/** Get subject line for instant alert */
+export function getInstantAlertSubject(event: InstantAlertEvent, shopName: string): string {
+  switch (event.eventType) {
+    case "price_change":
+      return `Price changed: ${event.resourceName} - ${shopName}`;
+    case "visibility_change":
+      return `Product ${event.afterValue === "active" ? "published" : "hidden"}: ${event.resourceName} - ${shopName}`;
+    case "inventory_low":
+      return `Low stock: ${event.resourceName} (${event.afterValue} left) - ${shopName}`;
+    case "inventory_zero":
+      return `Out of stock: ${event.resourceName} - ${shopName}`;
+    case "theme_publish":
+      return `Theme published: ${event.resourceName} - ${shopName}`;
+    case "collection_created":
+      return `Collection created: ${event.resourceName} - ${shopName}`;
+    case "collection_updated":
+      return `Collection updated: ${event.resourceName} - ${shopName}`;
+    case "collection_deleted":
+      return `Collection deleted: ${event.resourceName} - ${shopName}`;
+    case "discount_created":
+      return `Discount created: ${event.resourceName} - ${shopName}`;
+    case "discount_changed":
+      return `Discount changed: ${event.resourceName} - ${shopName}`;
+    case "discount_deleted":
+      return `Discount deleted: ${event.resourceName} - ${shopName}`;
+    case "app_permissions_changed":
+      return `App permissions changed: ${event.resourceName} - ${shopName}`;
+    case "domain_changed":
+      return `Domain changed: ${event.resourceName} - ${shopName}`;
+    case "domain_removed":
+      return `Domain removed: ${event.resourceName} - ${shopName}`;
+    default:
+      return `Change detected: ${event.resourceName} - ${shopName}`;
+  }
+}
+
+/** Build the change description for an instant alert */
+export function buildInstantAlertDescription(event: InstantAlertEvent): string {
+  const ctx = parseContextData(event.contextData);
+
+  // Use enriched summary when available
+  if (ctx.summary) {
+    return ctx.summary;
+  }
+
+  // Fallback for events without enriched context
+  let description = "";
+  switch (event.eventType) {
+    case "price_change":
+      description = `Price changed from ${event.beforeValue} to ${event.afterValue}`;
+      break;
+    case "visibility_change":
+      description = `Status changed from ${event.beforeValue} to ${event.afterValue}`;
+      break;
+    case "inventory_low":
+      description = `Stock dropped to ${event.afterValue} units total (was ${event.beforeValue})`;
+      break;
+    case "inventory_zero":
+      description = `Now out of stock across all locations (was ${event.beforeValue} units)`;
+      break;
+    case "theme_publish":
+      description = `&quot;${event.resourceName}&quot; is now your live theme`;
+      break;
+    case "collection_created":
+      description = `Collection &quot;${event.resourceName}&quot; was created`;
+      break;
+    case "collection_updated":
+      description = `Collection &quot;${event.resourceName}&quot; was updated`;
+      break;
+    case "collection_deleted":
+      description = `Collection &quot;${event.resourceName}&quot; was deleted`;
+      break;
+    case "discount_created":
+      description = `Discount &quot;${event.resourceName}&quot; was created`;
+      break;
+    case "discount_changed":
+      description = `Discount &quot;${event.resourceName}&quot; was modified: ${event.beforeValue || ""} &rarr; ${event.afterValue || ""}`;
+      break;
+    case "discount_deleted":
+      description = `Discount &quot;${event.resourceName}&quot; was deleted`;
+      break;
+    case "app_permissions_changed":
+      description = `App permissions were changed: ${event.resourceName}`;
+      break;
+    case "domain_changed":
+      description = `Domain &quot;${event.resourceName}&quot; was added or changed`;
+      break;
+    case "domain_removed":
+      description = `Domain &quot;${event.resourceName}&quot; was removed`;
+      break;
+    default:
+      description = `${event.beforeValue || ""} &rarr; ${event.afterValue || ""}`;
+  }
+
+  if (ctx.locationContext) description += ` &mdash; ${ctx.locationContext}`;
+  if (ctx.velocityContext) description += ` &mdash; ${ctx.velocityContext}`;
+
+  return description;
+}
+
+/** Generate the full HTML for an instant alert email */
+export function generateInstantAlertHtml(event: InstantAlertEvent, shop: string): string {
+  const shopName = shop.replace(".myshopify.com", "");
+  const color = getAlertColor(event.eventType);
+  const time = event.detectedAt.toLocaleString("en-US", {
+    weekday: "short",
+    month: "short",
+    day: "numeric",
+    hour: "numeric",
+    minute: "2-digit",
+    hour12: true,
+  });
+
+  const { revenueImpact } = parseContextData(event.contextData);
+  const changeDescription = buildInstantAlertDescription(event);
+
+  const impactRow = revenueImpact !== null
+    ? `<tr><td style="padding: 0 0 16px; color: ${HIGH_PRIORITY_TEXT}; font-size: 14px; font-weight: 500; font-family: ${FONT_STACK};">Estimated impact: ~$${revenueImpact.toFixed(2)}/hr until fixed</td></tr>`
+    : "";
+
+  const body = `
+<!-- Header -->
+<tr>
+  <td align="center" bgcolor="${color}" style="background-color: ${color}; padding: 24px; border-radius: 8px 8px 0 0;">
+    <h1 style="margin: 0; font-size: 18px; font-weight: 700; color: #ffffff; font-family: ${FONT_STACK};">${SHIELD_ICON} Instant Alert</h1>
+    <p style="margin: 6px 0 0; font-size: 13px; color: #ffffff; font-family: ${FONT_STACK};">${shopName}</p>
+  </td>
+</tr>
+<!-- Content -->
+<tr>
+  <td bgcolor="${CARD_BG}" style="background-color: ${CARD_BG}; padding: 24px;">
+    <table role="presentation" cellpadding="0" cellspacing="0" border="0" width="100%">
+      <tr>
+        <td style="padding: 0 0 8px;">
+          <h2 style="margin: 0; font-size: 18px; font-weight: 600; color: ${TEXT_PRIMARY}; font-family: ${FONT_STACK};">${event.resourceName}</h2>
+        </td>
+      </tr>
+      <tr>
+        <td style="padding: 0 0 16px; color: #374151; font-size: 14px; line-height: 1.5; font-family: ${FONT_STACK};">
+          ${changeDescription}
+        </td>
+      </tr>
+      ${impactRow}
+      <tr>
+        <td style="padding: 0; color: ${TEXT_MUTED}; font-size: 13px; font-family: ${FONT_STACK};">
+          Detected at ${time}
+        </td>
+      </tr>
+      <tr>
+        <td style="padding: 24px 0 0; border-top: 1px solid ${BORDER_COLOR}; padding-top: 16px; margin-top: 24px;">
+          <!--[if mso]>
+          <v:roundrect xmlns:v="urn:schemas-microsoft-com:vml" xmlns:w="urn:schemas-microsoft-com:office:word" href="https://${shop}/admin" style="height:44px;v-text-anchor:middle;width:200px;" arcsize="14%" stroke="f" fillcolor="${BRAND_COLOR}">
+            <w:anchorlock/>
+            <center style="color:#ffffff;font-family:${FONT_STACK};font-size:14px;font-weight:bold;">View in Shopify Admin</center>
+          </v:roundrect>
+          <![endif]-->
+          <!--[if !mso]><!-->
+          <a href="https://${shop}/admin" style="display: inline-block; background-color: ${BRAND_COLOR}; color: #ffffff; padding: 12px 24px; border-radius: 6px; text-decoration: none; font-size: 14px; font-weight: 600; font-family: ${FONT_STACK}; line-height: 1; mso-hide: all;">View in Shopify Admin</a>
+          <!--<![endif]-->
+        </td>
+      </tr>
+    </table>
+  </td>
+</tr>
+<!-- Footer -->
+<tr>
+  <td bgcolor="${CARD_BG}" style="background-color: ${CARD_BG}; padding: 16px 24px 24px; border-radius: 0 0 8px 8px; border-top: 1px solid ${BORDER_COLOR}; text-align: center;">
+    <p style="margin: 0; font-size: 12px; font-family: ${FONT_STACK};">
+      <a href="https://${shop}/admin/apps/storeguard/settings" style="color: ${TEXT_SECONDARY}; text-decoration: underline;">Manage instant alerts</a>
+    </p>
+  </td>
+</tr>`;
+
+  return emailShell("StoreGuard Alert", body);
+}
diff --git a/insightops/app/services/emailTemplates.test.ts b/insightops/app/services/emailTemplates.test.ts
new file mode 100644
index 0000000..e6a757c
--- /dev/null
+++ b/insightops/app/services/emailTemplates.test.ts
@@ -0,0 +1,560 @@
+import { describe, it, expect } from "vitest";
+import {
+  generateDigestEmailHtml,
+  generateInstantAlertHtml,
+  getInstantAlertSubject,
+  buildInstantAlertDescription,
+  formatDigestChangeDescription,
+  getAlertColor,
+  EVENT_TYPE_CONFIG,
+  type InstantAlertEvent,
+} from "./emailTemplates.server";
+import type { DigestSummary, DigestEvent } from "./dailyDigest.server";
+
+// ============================================
+// HELPERS
+// ============================================
+
+function makeDigestEvent(overrides: Partial<DigestEvent> = {}): DigestEvent {
+  return {
+    id: "evt-1",
+    entityType: "variant",
+    entityId: "gid://shopify/ProductVariant/1",
+    eventType: "price_change",
+    resourceName: "Blue Jacket / M",
+    beforeValue: "$89.00",
+    afterValue: "$8.90",
+    detectedAt: new Date("2026-02-18T14:30:00Z"),
+    importance: "high",
+    contextData: null,
+    ...overrides,
+  };
+}
+
+function makeDigest(overrides: Partial<DigestSummary> = {}): DigestSummary {
+  return {
+    shop: "test-store.myshopify.com",
+    alertEmail: "owner@test-store.com",
+    generatedAt: new Date("2026-02-18T15:00:00Z"),
+    periodStart: new Date("2026-02-17T15:00:00Z"),
+    periodEnd: new Date("2026-02-18T15:00:00Z"),
+    totalChanges: 1,
+    highPriorityCount: 0,
+    eventsByType: {
+      price_change: [makeDigestEvent()],
+    },
+    ...overrides,
+  };
+}
+
+function makeInstantEvent(overrides: Partial<InstantAlertEvent> = {}): InstantAlertEvent {
+  return {
+    eventType: "price_change",
+    resourceName: "Blue Jacket / M",
+    beforeValue: "$89.00",
+    afterValue: "$8.90",
+    importance: "high",
+    detectedAt: new Date("2026-02-18T14:30:00Z"),
+    contextData: null,
+    ...overrides,
+  };
+}
+
+// ============================================
+// DIGEST EMAIL HTML
+// ============================================
+
+describe("generateDigestEmailHtml", () => {
+  it("produces valid XHTML transitional doctype", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"');
+    expect(html).toContain('xmlns="http://www.w3.org/1999/xhtml"');
+  });
+
+  it("includes charset and viewport meta tags", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain('http-equiv="Content-Type"');
+    expect(html).toContain('content="text/html; charset=utf-8"');
+    expect(html).toContain('name="viewport"');
+    expect(html).toContain("width=device-width");
+  });
+
+  it("uses table-based layout (no flex/grid)", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).not.toContain("display: flex");
+    expect(html).not.toContain("display: grid");
+    expect(html).toContain('role="presentation"');
+  });
+
+  it("uses inline styles only (no <style> blocks outside mso conditionals)", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    // Remove MSO conditional comments before checking
+    const withoutMso = html.replace(/<!--\[if mso\]>[\s\S]*?<!\[endif\]-->/g, "");
+    expect(withoutMso).not.toMatch(/<style[\s>]/);
+  });
+
+  it("sets min-width 320px on content table", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("min-width: 320px");
+  });
+
+  it("sets max-width 600px on content table", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("max-width: 600px");
+  });
+
+  it("uses 14px base font size", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("font-size: 14px");
+  });
+
+  it("includes StoreGuard branding with shield", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("StoreGuard");
+    // Shield HTML entity
+    expect(html).toContain("&#x1F6E1;");
+  });
+
+  it("includes shop name without myshopify.com", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("test-store");
+    expect(html).not.toContain("test-store.myshopify.com</");
+  });
+
+  it("includes total changes count", () => {
+    const html = generateDigestEmailHtml(makeDigest({ totalChanges: 5 }));
+    expect(html).toContain("5 Changes Detected");
+  });
+
+  it("shows singular 'Change' for 1 event", () => {
+    const html = generateDigestEmailHtml(makeDigest({ totalChanges: 1 }));
+    expect(html).toContain("1 Change Detected");
+  });
+
+  it("shows high priority badge when highPriorityCount > 0", () => {
+    const html = generateDigestEmailHtml(makeDigest({ highPriorityCount: 3 }));
+    expect(html).toContain("3 High Priority");
+  });
+
+  it("hides high priority badge when highPriorityCount is 0", () => {
+    const html = generateDigestEmailHtml(makeDigest({ highPriorityCount: 0 }));
+    expect(html).not.toContain("High Priority");
+  });
+
+  it("renders event sections with proper titles", () => {
+    const html = generateDigestEmailHtml(makeDigest({
+      eventsByType: {
+        price_change: [makeDigestEvent()],
+        inventory_zero: [makeDigestEvent({ eventType: "inventory_zero", importance: "high" })],
+      },
+    }));
+    expect(html).toContain("Price Changes");
+    expect(html).toContain("Out of Stock");
+  });
+
+  it("renders event sections in display order", () => {
+    const html = generateDigestEmailHtml(makeDigest({
+      eventsByType: {
+        inventory_zero: [makeDigestEvent({ eventType: "inventory_zero" })],
+        price_change: [makeDigestEvent()],
+      },
+    }));
+    const priceIdx = html.indexOf("Price Changes");
+    const stockIdx = html.indexOf("Out of Stock");
+    expect(priceIdx).toBeLessThan(stockIdx);
+  });
+
+  it("renders resource names in event rows", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("Blue Jacket / M");
+  });
+
+  it("shows high-priority dot for high importance events", () => {
+    const html = generateDigestEmailHtml(makeDigest({
+      eventsByType: {
+        price_change: [makeDigestEvent({ importance: "high" })],
+      },
+    }));
+    // Red dot background
+    expect(html).toContain("background-color: #dc2626");
+  });
+
+  it("includes settings link in footer", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("test-store.myshopify.com/admin/apps/storeguard/settings");
+    expect(html).toContain("Manage notification settings");
+  });
+
+  it("includes Outlook conditional comments for fixed-width wrapper", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain("<!--[if mso]>");
+    expect(html).toContain("<![endif]-->");
+  });
+
+  it("includes bgcolor attributes for Outlook background colors", () => {
+    const html = generateDigestEmailHtml(makeDigest());
+    expect(html).toContain('bgcolor="');
+  });
+
+  it("handles unknown event types gracefully with fallback title", () => {
+    const html = generateDigestEmailHtml(makeDigest({
+      eventsByType: {
+        mystery_event: [makeDigestEvent({ eventType: "mystery_event" })],
+      },
+    }));
+    expect(html).toContain("Mystery Event");
+  });
+});
+
+// ============================================
+// DIGEST CHANGE DESCRIPTIONS
+// ============================================
+
+describe("formatDigestChangeDescription", () => {
+  it("formats price changes with arrow entity", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent());
+    expect(result).toContain("$89.00");
+    expect(result).toContain("&rarr;");
+    expect(result).toContain("$8.90");
+  });
+
+  it("formats visibility changes", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      eventType: "visibility_change",
+      beforeValue: "active",
+      afterValue: "draft",
+    }));
+    expect(result).toContain("active");
+    expect(result).toContain("draft");
+  });
+
+  it("formats inventory zero", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      eventType: "inventory_zero",
+      beforeValue: "15",
+      afterValue: "0",
+    }));
+    expect(result).toContain("out of stock");
+    expect(result).toContain("15 units");
+  });
+
+  it("formats inventory low", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      eventType: "inventory_low",
+      beforeValue: "20",
+      afterValue: "3",
+    }));
+    expect(result).toContain("3 units");
+    expect(result).toContain("was 20");
+  });
+
+  it("formats theme publish", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      eventType: "theme_publish",
+      resourceName: "Dawn Custom",
+    }));
+    expect(result).toContain("live theme");
+  });
+
+  it("includes velocity context from contextData", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      contextData: JSON.stringify({ velocityContext: "selling 8/day" }),
+    }));
+    expect(result).toContain("selling 8/day");
+  });
+
+  it("includes location context from contextData", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      contextData: JSON.stringify({ locationContext: "Main Warehouse" }),
+    }));
+    expect(result).toContain("Main Warehouse");
+  });
+
+  it("handles invalid contextData gracefully", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({
+      contextData: "not-json",
+    }));
+    // Should still produce a result without crashing
+    expect(result).toContain("$89.00");
+  });
+
+  it("formats collection events", () => {
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "collection_created" }))).toContain("collection created");
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "collection_updated" }))).toContain("Collection updated");
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "collection_deleted" }))).toContain("Collection deleted");
+  });
+
+  it("formats discount events", () => {
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "discount_created" }))).toContain("Discount created");
+    expect(formatDigestChangeDescription(makeDigestEvent({
+      eventType: "discount_changed",
+      beforeValue: "20% off",
+      afterValue: "50% off",
+    }))).toContain("&rarr;");
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "discount_deleted" }))).toContain("Discount deleted");
+  });
+
+  it("formats app permissions changed", () => {
+    const result = formatDigestChangeDescription(makeDigestEvent({ eventType: "app_permissions_changed" }));
+    expect(result).toContain("Permissions changed");
+  });
+
+  it("formats domain events", () => {
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "domain_changed" }))).toContain("Domain added or changed");
+    expect(formatDigestChangeDescription(makeDigestEvent({ eventType: "domain_removed" }))).toContain("Domain removed");
+  });
+});
+
+// ============================================
+// INSTANT ALERT HTML
+// ============================================
+
+describe("generateInstantAlertHtml", () => {
+  it("produces valid XHTML transitional doctype", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"');
+  });
+
+  it("uses table-based layout", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).not.toContain("display: flex");
+    expect(html).toContain('role="presentation"');
+  });
+
+  it("sets min-width 320px", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("min-width: 320px");
+  });
+
+  it("uses 14px base font size", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("font-size: 14px");
+  });
+
+  it("includes shield branding", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("&#x1F6E1;");
+  });
+
+  it("uses event-specific accent color in header", () => {
+    const html = generateInstantAlertHtml(
+      makeInstantEvent({ eventType: "inventory_zero" }),
+      "test-store.myshopify.com",
+    );
+    expect(html).toContain(EVENT_TYPE_CONFIG.inventory_zero.color);
+  });
+
+  it("includes resource name", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("Blue Jacket / M");
+  });
+
+  it("includes change description", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("Price changed from $89.00 to $8.90");
+  });
+
+  it("includes Shopify Admin CTA button", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("View in Shopify Admin");
+    expect(html).toContain("test-store.myshopify.com/admin");
+  });
+
+  it("includes Outlook VML button fallback", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("v:roundrect");
+  });
+
+  it("shows revenue impact when present in contextData", () => {
+    const html = generateInstantAlertHtml(
+      makeInstantEvent({ contextData: JSON.stringify({ revenueImpact: 42.50 }) }),
+      "test-store.myshopify.com",
+    );
+    expect(html).toContain("$42.50/hr");
+  });
+
+  it("hides revenue impact when not present", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).not.toContain("Estimated impact");
+  });
+
+  it("includes settings link in footer", () => {
+    const html = generateInstantAlertHtml(makeInstantEvent(), "test-store.myshopify.com");
+    expect(html).toContain("Manage instant alerts");
+  });
+});
+
+// ============================================
+// INSTANT ALERT SUBJECTS
+// ============================================
+
+describe("getInstantAlertSubject", () => {
+  it("includes resource name and shop name", () => {
+    const subject = getInstantAlertSubject(makeInstantEvent(), "test-store");
+    expect(subject).toContain("Blue Jacket / M");
+    expect(subject).toContain("test-store");
+  });
+
+  it("returns correct subject for each event type", () => {
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "price_change" }), "shop"))
+      .toContain("Price changed");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "inventory_zero" }), "shop"))
+      .toContain("Out of stock");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "inventory_low", afterValue: "3" }), "shop"))
+      .toContain("Low stock");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "theme_publish" }), "shop"))
+      .toContain("Theme published");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "visibility_change", afterValue: "active" }), "shop"))
+      .toContain("published");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "visibility_change", afterValue: "draft" }), "shop"))
+      .toContain("hidden");
+  });
+
+  it("returns correct subject for V2 event types", () => {
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "collection_created" }), "shop"))
+      .toContain("Collection created");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "discount_deleted" }), "shop"))
+      .toContain("Discount deleted");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "app_permissions_changed" }), "shop"))
+      .toContain("App permissions changed");
+    expect(getInstantAlertSubject(makeInstantEvent({ eventType: "domain_removed" }), "shop"))
+      .toContain("Domain removed");
+  });
+
+  it("does not include emojis in subject lines", () => {
+    const types = [
+      "price_change", "visibility_change", "inventory_low", "inventory_zero",
+      "theme_publish", "collection_created", "discount_deleted", "domain_changed",
+    ];
+    for (const eventType of types) {
+      const subject = getInstantAlertSubject(makeInstantEvent({ eventType }), "shop");
+      // Check no emoji characters (common emoji ranges)
+      expect(subject).not.toMatch(/[\u{1F600}-\u{1F64F}]/u);
+      expect(subject).not.toMatch(/[\u{1F300}-\u{1F5FF}]/u);
+      expect(subject).not.toMatch(/[\u{1F680}-\u{1F6FF}]/u);
+      expect(subject).not.toMatch(/[\u{2600}-\u{26FF}]/u);
+      expect(subject).not.toMatch(/[\u{2700}-\u{27BF}]/u);
+    }
+  });
+
+  it("handles unknown event types", () => {
+    const subject = getInstantAlertSubject(makeInstantEvent({ eventType: "unknown_type" }), "shop");
+    expect(subject).toContain("Change detected");
+  });
+});
+
+// ============================================
+// INSTANT ALERT DESCRIPTIONS
+// ============================================
+
+describe("buildInstantAlertDescription", () => {
+  it("describes price changes", () => {
+    const desc = buildInstantAlertDescription(makeInstantEvent());
+    expect(desc).toContain("Price changed from $89.00 to $8.90");
+  });
+
+  it("describes visibility changes", () => {
+    const desc = buildInstantAlertDescription(makeInstantEvent({
+      eventType: "visibility_change",
+      beforeValue: "active",
+      afterValue: "draft",
+    }));
+    expect(desc).toContain("Status changed from active to draft");
+  });
+
+  it("describes inventory zero", () => {
+    const desc = buildInstantAlertDescription(makeInstantEvent({
+      eventType: "inventory_zero",
+      beforeValue: "15",
+    }));
+    expect(desc).toContain("out of stock");
+    expect(desc).toContain("15 units");
+  });
+
+  it("describes inventory low", () => {
+    const desc = buildInstantAlertDescription(makeInstantEvent({
+      eventType: "inventory_low",
+      beforeValue: "20",
+      afterValue: "3",
+    }));
+    expect(desc).toContain("3 units total");
+    expect(desc).toContain("was 20");
+  });
+
+  it("appends velocity context", () => {
+    const desc = buildInstantAlertDescription(makeInstantEvent({
+      contextData: JSON.stringify({ velocityContext: "selling 8/day" }),
+    }));
+    expect(desc).toContain("selling 8/day");
+  });
+
+  it("appends location context", () => {
+    const desc = buildInstantAlertDescription(makeInstantEvent({
+      contextData: JSON.stringify({ locationContext: "Main Warehouse" }),
+    }));
+    expect(desc).toContain("Main Warehouse");
+  });
+
+  it("handles all V2 event types", () => {
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "collection_created" })))
+      .toContain("was created");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "collection_updated" })))
+      .toContain("was updated");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "collection_deleted" })))
+      .toContain("was deleted");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "discount_created" })))
+      .toContain("was created");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "discount_changed", beforeValue: "10%", afterValue: "20%" })))
+      .toContain("was modified");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "discount_deleted" })))
+      .toContain("was deleted");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "app_permissions_changed" })))
+      .toContain("permissions were changed");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "domain_changed" })))
+      .toContain("was added or changed");
+    expect(buildInstantAlertDescription(makeInstantEvent({ eventType: "domain_removed" })))
+      .toContain("was removed");
+  });
+});
+
+// ============================================
+// getAlertColor
+// ============================================
+
+describe("getAlertColor", () => {
+  it("returns correct colors for known event types", () => {
+    expect(getAlertColor("price_change")).toBe("#f59e0b");
+    expect(getAlertColor("inventory_zero")).toBe("#ef4444");
+    expect(getAlertColor("theme_publish")).toBe("#06b6d4");
+  });
+
+  it("returns fallback gray for unknown event types", () => {
+    expect(getAlertColor("unknown")).toBe("#6b7280");
+  });
+});
+
+// ============================================
+// EVENT_TYPE_CONFIG
+// ============================================
+
+describe("EVENT_TYPE_CONFIG", () => {
+  it("covers all V1 + V2 event types", () => {
+    const expectedTypes = [
+      "price_change", "visibility_change", "inventory_low", "inventory_zero",
+      "theme_publish", "collection_created", "collection_updated", "collection_deleted",
+      "discount_created", "discount_changed", "discount_deleted",
+      "app_permissions_changed", "domain_changed", "domain_removed",
+    ];
+    for (const type of expectedTypes) {
+      expect(EVENT_TYPE_CONFIG[type]).toBeDefined();
+      expect(EVENT_TYPE_CONFIG[type].title).toBeTruthy();
+      expect(EVENT_TYPE_CONFIG[type].color).toMatch(/^#[0-9a-f]{6}$/);
+      expect(typeof EVENT_TYPE_CONFIG[type].order).toBe("number");
+    }
+  });
+
+  it("has unique display orders", () => {
+    const orders = Object.values(EVENT_TYPE_CONFIG).map((c) => c.order);
+    expect(new Set(orders).size).toBe(orders.length);
+  });
+});
diff --git a/insightops/app/services/jobProcessor.server.ts b/insightops/app/services/jobProcessor.server.ts
index acc4c19..5aa2fa9 100644
--- a/insightops/app/services/jobProcessor.server.ts
+++ b/insightops/app/services/jobProcessor.server.ts
@@ -12,7 +12,21 @@ import {
   detectLowStock,
   deleteProductSnapshot,
   recordThemePublish,
+  recordCollectionCreated,
+  recordCollectionUpdated,
+  recordCollectionDeleted,
+  recordDiscountCreated,
+  recordDiscountUpdated,
+  recordDiscountDeleted,
+  recordAppPermissionsChanged,
+  recordDomainChanged,
+  recordDomainRemoved,
 } from "./changeDetection.server";
+import {
+  aggregateInventoryLevels,
+  type InventoryLevelNode,
+} from "./changeDetection.utils";
+import { normalizeTopic } from "./jobProcessor.utils";
 
 // Full product payload from Shopify webhook
 interface ProductPayload {
@@ -69,6 +83,23 @@ interface CollectionPayload {
   } | null;
 }
 
+interface DiscountPayload {
+  id: number;
+  title: string;
+  value: string;
+  value_type: string; // "percentage" | "fixed_amount"
+  code?: string;
+  starts_at: string | null;
+  ends_at: string | null;
+}
+
+interface DomainPayload {
+  id: number;
+  host: string;
+  ssl_enabled?: boolean;
+  localization?: { country: string | null; default_locale: string };
+}
+
 interface InventoryLevelPayload {
   inventory_item_id: number;
   location_id: number;
@@ -322,20 +353,19 @@ async function processProductUpdate(
     }
   }
 
-  // === Legacy EventLog (for activity timeline) ===
   // Create new snapshot
   const newSnapshot = createProductSnapshot(payload);
 
   // Get previous snapshot for diff comparison
   // Look for any event with a snapshot (baseline or previous update)
   let oldSnapshot: ProductSnapshot | null = null;
-  const previousEvents = await db.eventLog.findMany({
+  const previousEvents = await db.changeEvent.findMany({
     where: {
       shop,
-      shopifyId: String(payload.id),
+      entityId: String(payload.id),
       diff: { not: null },
     },
-    orderBy: { timestamp: "desc" },
+    orderBy: { detectedAt: "desc" },
     take: 5, // Check recent events for a valid snapshot
   });
 
@@ -382,16 +412,20 @@ async function processProductUpdate(
     update: { title: payload.title },
   });
 
-  // Create event log
-  await db.eventLog.create({
+  // Create activity log entry
+  await db.changeEvent.create({
     data: {
       shop,
-      shopifyId: String(payload.id),
+      entityType: "product",
+      entityId: String(payload.id),
+      eventType: "product_updated",
+      resourceName: payload.title,
+      source: "webhook",
+      importance: "low",
       topic: "products/update",
       author,
-      message,
       diff,
-      webhookId,
+      webhookId: webhookId ?? `activity-products-update-${payload.id}-${Date.now()}`,
     },
   });
 
@@ -438,15 +472,19 @@ async function processProductCreate(
     update: { title: payload.title },
   });
 
-  await db.eventLog.create({
+  await db.changeEvent.create({
     data: {
       shop,
-      shopifyId: String(payload.id),
+      entityType: "product",
+      entityId: String(payload.id),
+      eventType: "product_created",
+      resourceName: payload.title,
+      source: "webhook",
+      importance: "low",
       topic: "products/create",
       author,
-      message,
       diff,
-      webhookId,
+      webhookId: webhookId ?? `activity-products-create-${payload.id}-${Date.now()}`,
     },
   });
 
@@ -479,28 +517,33 @@ async function processProductDelete(
   // === StoreGuard: Clean up snapshot for deleted product ===
   await deleteProductSnapshot(shop, productId);
 
-  // Fallback to previous events
+  // Fallback to previous ChangeEvent records
   if (!productTitle) {
-    const previousEvent = await db.eventLog.findFirst({
-      where: { shop, shopifyId: productId },
-      orderBy: { timestamp: "desc" },
+    const previousEvent = await db.changeEvent.findFirst({
+      where: { shop, entityId: productId },
+      orderBy: { detectedAt: "desc" },
     });
-    const match = previousEvent?.message?.match(/"([^"]+)"/);
-    if (match) productTitle = match[1];
+    if (previousEvent) {
+      productTitle = previousEvent.resourceName;
+    }
   }
 
   const displayName = productTitle || `Product #${payload.id}`;
   const message = `Product deleted: "${displayName}"`;
 
-  await db.eventLog.create({
+  await db.changeEvent.create({
     data: {
       shop,
-      shopifyId: productId,
+      entityType: "product",
+      entityId: productId,
+      eventType: "product_deleted",
+      resourceName: displayName,
+      source: "webhook",
+      importance: "low",
       topic: "products/delete",
       author: "System/App",
-      message,
       diff: null,
-      webhookId,
+      webhookId: webhookId ?? `activity-products-delete-${payload.id}-${Date.now()}`,
     },
   });
 
@@ -520,61 +563,229 @@ async function processCollection(
   const verb = topic.includes("create") ? "create" : topic.includes("update") ? "update" : "delete";
 
   if (verb === "delete") {
-    // For deletes, try to get title from previous events
+    // For deletes, try to get title from previous events or ChangeEvents
     const collectionId = String((payload as { id: number }).id);
     let title: string | null = null;
 
-    const previousEvent = await db.eventLog.findFirst({
-      where: { shop, shopifyId: collectionId, topic: { contains: "collections" } },
-      orderBy: { timestamp: "desc" },
+    // Try ChangeEvent first for title lookup
+    const previousChange = await db.changeEvent.findFirst({
+      where: { shop, entityType: "collection", entityId: collectionId },
+      orderBy: { detectedAt: "desc" },
     });
-    const match = previousEvent?.message?.match(/"([^"]+)"/);
-    if (match) title = match[1];
+    if (previousChange) {
+      title = previousChange.resourceName;
+    }
 
     const displayName = title || `Collection #${collectionId}`;
-    const message = `Collection deleted: "${displayName}"`;
 
-    await db.eventLog.create({
-      data: {
-        shop,
-        shopifyId: collectionId,
-        topic,
-        author: "System/App",
-        message,
-        diff: null,
-        webhookId,
-      },
-    });
+    // === StoreGuard ChangeEvent ===
+    if (webhookId) {
+      await recordCollectionDeleted(shop, collectionId, displayName, webhookId);
+    }
 
-    console.log(`[StoreGuard] Logged: ${message}`);
+    console.log(`[StoreGuard] Collection deleted: "${displayName}"`);
     return;
   }
 
   const collection = payload as CollectionPayload;
   const author = (await fetchAuthor(shop, accessToken, "Collection", collection.id, verb)) || "System/App";
-  const message = `${author} ${verb}d collection "${collection.title}"`;
 
-  await db.eventLog.create({
-    data: {
-      shop,
-      shopifyId: String(collection.id),
-      topic,
-      author,
-      message,
-      diff: JSON.stringify({ title: collection.title, handle: collection.handle }),
-      webhookId,
-    },
-  });
+  // === StoreGuard ChangeEvent ===
+  if (webhookId) {
+    if (verb === "create") {
+      await recordCollectionCreated(shop, String(collection.id), collection.title, webhookId);
+    } else {
+      await recordCollectionUpdated(shop, String(collection.id), collection.title, webhookId);
+    }
+  }
 
-  console.log(`[StoreGuard] Logged: ${message}`);
+  console.log(`[StoreGuard] Collection ${verb}d: "${collection.title}"`);
+}
+
+/**
+ * Process a discount job
+ */
+async function processDiscount(
+  shop: string,
+  topic: string,
+  payload: DiscountPayload | { id: number },
+  webhookId: string | null
+): Promise<void> {
+  const verb = topic.includes("create") ? "create" : topic.includes("update") ? "update" : "delete";
+
+  if (verb === "delete") {
+    const discountId = String((payload as { id: number }).id);
+
+    // Try to find a title from previous ChangeEvents
+    let title: string | null = null;
+    const previousChange = await db.changeEvent.findFirst({
+      where: { shop, entityType: "discount", entityId: discountId },
+      orderBy: { detectedAt: "desc" },
+    });
+    if (previousChange) {
+      title = previousChange.resourceName;
+    }
+
+    const displayName = title || `Discount #${discountId}`;
+
+    if (webhookId) {
+      await recordDiscountDeleted(shop, discountId, displayName, webhookId);
+    }
+
+    console.log(`[StoreGuard] Discount deleted: "${displayName}"`);
+    return;
+  }
+
+  const discount = payload as DiscountPayload;
+  const discountTitle = discount.title || discount.code || `Discount #${discount.id}`;
+  const discountValue = discount.value_type === "percentage" ? discount.value : null;
+
+  if (webhookId) {
+    if (verb === "create") {
+      await recordDiscountCreated(shop, String(discount.id), discountTitle, discountValue, webhookId);
+    } else {
+      await recordDiscountUpdated(shop, String(discount.id), discountTitle, discountValue, webhookId);
+    }
+  }
+
+  console.log(`[StoreGuard] Discount ${verb}d: "${discountTitle}"`);
+}
+
+/**
+ * Process a domain job
+ */
+async function processDomain(
+  shop: string,
+  topic: string,
+  payload: DomainPayload | { id: number },
+  webhookId: string | null
+): Promise<void> {
+  const isDestroy = topic.includes("destroy");
+
+  if (isDestroy) {
+    const domainId = String((payload as { id: number }).id);
+
+    // Try to find a host from previous ChangeEvents
+    let host: string | null = null;
+    const previousChange = await db.changeEvent.findFirst({
+      where: { shop, entityType: "domain", entityId: domainId },
+      orderBy: { detectedAt: "desc" },
+    });
+    if (previousChange) {
+      host = previousChange.resourceName;
+    }
+
+    const displayName = host || `Domain #${domainId}`;
+
+    if (webhookId) {
+      await recordDomainRemoved(shop, domainId, displayName, webhookId);
+    }
+
+    console.log(`[StoreGuard] Domain removed: "${displayName}"`);
+    return;
+  }
+
+  const domain = payload as DomainPayload;
+  const domainHost = domain.host || `Domain #${domain.id}`;
+
+  if (webhookId) {
+    await recordDomainChanged(shop, String(domain.id), domainHost, webhookId);
+  }
+
+  console.log(`[StoreGuard] Domain changed: "${domainHost}"`);
+}
+
+/** Shape of the inventoryLevels connection from the GraphQL response */
+interface InventoryLevelsConnection {
+  nodes: InventoryLevelNode[];
+  pageInfo: { hasNextPage: boolean; endCursor: string | null };
+}
+
+/**
+ * Fetch total inventory across all locations for an inventory item.
+ * Uses cursor-based pagination to handle merchants with >50 locations.
+ * Returns { totalQuantity, locationName } where totalQuantity is the sum
+ * of available quantities across all locations, and locationName is the
+ * name of the location that triggered this webhook.
+ */
+async function fetchTotalInventory(
+  shop: string,
+  accessToken: string,
+  inventoryItemId: number,
+  triggerLocationId: number
+): Promise<{ totalQuantity: number; locationName: string | null }> {
+  const allNodes: InventoryLevelNode[] = [];
+  let cursor: string | null = null;
+  const MAX_PAGES = 20; // Safety limit to prevent infinite loops
+
+  try {
+    for (let page = 0; page < MAX_PAGES; page++) {
+      const gql = await fetch(`https://${shop}/admin/api/${apiVersion}/graphql.json`, {
+        method: "POST",
+        headers: {
+          "X-Shopify-Access-Token": accessToken,
+          "Content-Type": "application/json",
+        },
+        body: JSON.stringify({
+          query: `#graphql
+            query InventoryLevels($inventoryItemId: ID!, $cursor: String) {
+              inventoryItem(id: $inventoryItemId) {
+                inventoryLevels(first: 50, after: $cursor) {
+                  nodes {
+                    quantities(names: ["available"]) {
+                      quantity
+                    }
+                    location {
+                      id
+                      name
+                    }
+                  }
+                  pageInfo {
+                    hasNextPage
+                    endCursor
+                  }
+                }
+              }
+            }`,
+          variables: {
+            inventoryItemId: `gid://shopify/InventoryItem/${inventoryItemId}`,
+            cursor,
+          },
+        }),
+      });
+
+      const data = (await gql.json()) as {
+        data?: { inventoryItem?: { inventoryLevels?: InventoryLevelsConnection } };
+      };
+      const connection = data?.data?.inventoryItem?.inventoryLevels;
+      if (!connection?.nodes || connection.nodes.length === 0) {
+        break;
+      }
+
+      allNodes.push(...connection.nodes);
+
+      if (!connection.pageInfo.hasNextPage || !connection.pageInfo.endCursor) {
+        break;
+      }
+      cursor = connection.pageInfo.endCursor;
+    }
+
+    if (allNodes.length === 0) {
+      return { totalQuantity: 0, locationName: null };
+    }
+
+    return aggregateInventoryLevels(allNodes, triggerLocationId);
+  } catch (error) {
+    console.error(`[StoreGuard] Failed to fetch total inventory:`, error);
+    return { totalQuantity: 0, locationName: null };
+  }
 }
 
 /**
  * Process an inventory update job
  *
- * NOTE: Once the orders/paid webhook is enabled (requires Protected Customer Data approval),
- * the noise filter below will automatically hide inventory updates caused by orders.
- * Until then, we keep logging inventory updates so the app isn't blind to sales activity.
+ * Multi-location aware: aggregates inventory across all locations before alerting.
+ * The webhook fires per-location, so we query Shopify for the total across all locations.
  */
 async function processInventoryUpdate(
   shop: string,
@@ -643,142 +854,124 @@ async function processInventoryUpdate(
     return;
   }
 
-  // NOISE FILTER: Skip inventory updates caused by orders
-  // When orders webhook is enabled, this will hide the "symptom" when we already have the "cause"
-  if (productId) {
-    try {
-      const recentOrder = await db.eventLog.findFirst({
-        where: {
-          shop,
-          topic: "ORDERS_CREATE",
-          timestamp: {
-            gte: new Date(Date.now() - 30 * 1000), // Within last 30 seconds
-          },
-        },
-        orderBy: { timestamp: "desc" },
-      });
-
-      if (recentOrder?.diff) {
-        const orderDiff = JSON.parse(recentOrder.diff);
-        const orderProductIds = orderDiff.items?.map((item: { productId: number }) => String(item.productId)) || [];
-        if (orderProductIds.includes(productId)) {
-          console.log(`[StoreGuard] Skipping inventory update - caused by recent order ${orderDiff.orderName}`);
-          return;
-        }
-      }
-    } catch (filterError) {
-      console.error(`[StoreGuard] Noise filter check failed:`, filterError);
-    }
-  }
+  // === Multi-location: Fetch total inventory across all locations ===
+  const { totalQuantity, locationName } = await fetchTotalInventory(
+    shop,
+    accessToken,
+    payload.inventory_item_id,
+    payload.location_id
+  );
 
-  // Get previous inventory level for diff display AND for >0→0 detection
-  // Strategy: Check EventLog first (most recent), then fall back to ProductSnapshot
+  // Get previous TOTAL inventory for diff display AND for >0→0 detection
+  // Strategy: Check ChangeEvent first (most recent), then fall back to ProductSnapshot
   let oldAvailable: number | null = null;
   try {
-    // First, try EventLog (recent inventory updates)
-    const previousEvent = await db.eventLog.findFirst({
+    // First, try ChangeEvent (recent inventory updates) — stores totalQuantity
+    const previousEvent = await db.changeEvent.findFirst({
       where: {
         shop,
-        shopifyId: String(payload.inventory_item_id),
-        topic: "INVENTORY_LEVELS_UPDATE",
+        entityId: String(payload.inventory_item_id),
+        topic: "inventory/levels/update",
       },
-      orderBy: { timestamp: "desc" },
+      orderBy: { detectedAt: "desc" },
     });
 
     if (previousEvent?.diff) {
       const prevDiff = JSON.parse(previousEvent.diff);
-      oldAvailable = prevDiff.available;
+      // Prefer totalQuantity (multi-location) over legacy available (single-location)
+      oldAvailable = prevDiff.totalQuantity ?? prevDiff.available ?? null;
     }
 
-    // If no EventLog, fall back to ProductSnapshot
+    // If no ChangeEvent, fall back to ProductSnapshot
     if (oldAvailable === null && productId && variantId) {
-      const snapshot = await db.productSnapshot.findUnique({
-        where: { shop_id: { shop, id: productId } },
+      const matchingVariant = await db.variantSnapshot.findUnique({
+        where: {
+          productSnapshotId_shopifyVariantId: {
+            productSnapshotId: productId,
+            shopifyVariantId: variantId,
+          },
+        },
       });
-      if (snapshot?.variants) {
-        try {
-          const variants = JSON.parse(snapshot.variants) as Array<{ id: string; inventoryQuantity: number }>;
-          const matchingVariant = variants.find(v => v.id === variantId);
-          if (matchingVariant && matchingVariant.inventoryQuantity !== undefined) {
-            oldAvailable = matchingVariant.inventoryQuantity;
-            console.log(`[StoreGuard] Got previous inventory ${oldAvailable} from ProductSnapshot for ${productTitle}`);
-          }
-        } catch {
-          // Invalid JSON in snapshot
-        }
+      if (matchingVariant && matchingVariant.inventoryQuantity !== undefined) {
+        oldAvailable = matchingVariant.inventoryQuantity;
+        console.log(`[StoreGuard] Got previous inventory ${oldAvailable} from VariantSnapshot for ${productTitle}`);
       }
     }
   } catch (prevError) {
     console.error(`[StoreGuard] Failed to fetch previous inventory:`, prevError);
   }
 
-  // === StoreGuard: Detect inventory changes ===
+  // Build location context for alerts
+  const locationContext = locationName ? `Last change at ${locationName}` : null;
+
+  // === StoreGuard: Detect inventory changes using TOTAL quantity ===
   if (productId && webhookId) {
-    // Detect low stock (crossing below threshold)
+    // Detect low stock (crossing below threshold) — uses total across all locations
     const lowStockDetected = await detectLowStock(
       shop,
       String(payload.inventory_item_id),
       productId,
       productTitle,
       variantTitle,
-      payload.available,
+      totalQuantity,
       oldAvailable,
-      webhookId
+      webhookId,
+      locationContext
     );
 
     // Detect inventory hitting zero (only if not already low stock alert)
-    // Rule: Only triggers on >0 → 0 transition
-    if (payload.available === 0 && !lowStockDetected) {
+    // Rule: Only triggers on >0 → 0 transition — uses total across all locations
+    if (totalQuantity === 0 && !lowStockDetected) {
       await detectInventoryZero(
         shop,
         String(payload.inventory_item_id),
         productId,
         productTitle,
         variantTitle,
-        payload.available,
+        totalQuantity,
         oldAvailable,
-        webhookId
+        webhookId,
+        locationContext
       );
     }
   }
 
-  // Update or create ProductSnapshot with inventory (keeps snapshot current for future comparisons)
+  // Update or create ProductSnapshot with TOTAL inventory (keeps snapshot current for future comparisons)
   if (productId && variantId) {
     try {
-      const snapshot = await db.productSnapshot.findUnique({
+      // Ensure ProductSnapshot exists
+      await db.productSnapshot.upsert({
         where: { shop_id: { shop, id: productId } },
+        create: {
+          id: productId,
+          shop,
+          title: productTitle,
+          status: "active",
+        },
+        update: {},
       });
-      if (snapshot?.variants) {
-        // Update existing snapshot
-        const variants = JSON.parse(snapshot.variants) as Array<{ id: string; title: string; price: string; inventoryQuantity: number }>;
-        const variantIndex = variants.findIndex(v => v.id === variantId);
-        if (variantIndex >= 0) {
-          variants[variantIndex].inventoryQuantity = payload.available;
-          await db.productSnapshot.update({
-            where: { shop_id: { shop, id: productId } },
-            data: { variants: JSON.stringify(variants) },
-          });
-          console.log(`[StoreGuard] Updated ProductSnapshot inventory for ${productTitle}: ${payload.available}`);
-        }
-      } else if (!snapshot) {
-        // No snapshot exists - create a minimal one for future tracking
-        // This ensures the NEXT inventory change can be detected
-        await db.productSnapshot.create({
-          data: {
-            id: productId,
-            shop,
-            title: productTitle,
-            status: "active", // Default assumption
-            variants: JSON.stringify([{
-              id: variantId,
-              title: variantTitle || "Default Title",
-              price: "0.00",
-              inventoryQuantity: payload.available,
-            }]),
+
+      // Upsert the specific variant — atomic, no read-modify-write
+      await db.variantSnapshot.upsert({
+        where: {
+          productSnapshotId_shopifyVariantId: {
+            productSnapshotId: productId,
+            shopifyVariantId: variantId,
           },
-        });
-        console.log(`[StoreGuard] Created ProductSnapshot from inventory webhook for ${productTitle}`);
-      }
+        },
+        create: {
+          productSnapshotId: productId,
+          shop,
+          shopifyVariantId: variantId,
+          title: variantTitle || "Default Title",
+          price: "0.00",
+          inventoryQuantity: totalQuantity,
+        },
+        update: {
+          inventoryQuantity: totalQuantity,
+        },
+      });
+      console.log(`[StoreGuard] Updated VariantSnapshot inventory for ${productTitle}: ${totalQuantity} (total across locations)`);
     } catch (snapshotError) {
       console.error(`[StoreGuard] Failed to update ProductSnapshot inventory:`, snapshotError);
     }
@@ -789,40 +982,49 @@ async function processInventoryUpdate(
       ? `${productTitle} - ${variantTitle}`
       : productTitle;
 
-  // Create a clear message showing stock change
+  // Create a clear message showing stock change (total across all locations)
   let message: string;
-  if (oldAvailable !== null && oldAvailable !== payload.available) {
-    const change = payload.available - oldAvailable;
+  if (oldAvailable !== null && oldAvailable !== totalQuantity) {
+    const change = totalQuantity - oldAvailable;
     const arrow = change > 0 ? "↑" : "↓";
-    message = `Stock ${arrow} "${displayName}" (${oldAvailable} → ${payload.available})`;
+    message = `Stock ${arrow} "${displayName}" (${oldAvailable} → ${totalQuantity} total)`;
   } else {
-    message = `Stock updated: "${displayName}" (${payload.available} units)`;
+    message = `Stock updated: "${displayName}" (${totalQuantity} units total)`;
+  }
+  if (locationName) {
+    message += ` [${locationName}]`;
   }
 
   const diff = JSON.stringify({
     available: payload.available,
+    totalQuantity,
     inventoryChange:
-      oldAvailable !== null && oldAvailable !== payload.available
-        ? { old: oldAvailable, new: payload.available }
+      oldAvailable !== null && oldAvailable !== totalQuantity
+        ? { old: oldAvailable, new: totalQuantity }
         : null,
     locationId: payload.location_id,
+    locationName,
   });
 
-  await db.eventLog.create({
+  await db.changeEvent.create({
     data: {
       shop,
+      entityType: "variant",
       // Use inventory_item_id consistently for inventory events
       // This matches the lookup in getPreviousInventory above
-      shopifyId: String(payload.inventory_item_id),
-      topic: "INVENTORY_LEVELS_UPDATE",
+      entityId: String(payload.inventory_item_id),
+      eventType: "inventory_update",
+      resourceName: displayName,
+      source: "webhook",
+      importance: "low",
+      topic: "inventory/levels/update",
       author: "System/App",
-      message,
       diff,
-      webhookId,
+      webhookId: webhookId ?? `activity-inventory-update-${payload.inventory_item_id}-${Date.now()}`,
     },
   });
 
-  console.log(`[StoreGuard] ✅ Logged: ${message}`);
+  console.log(`[StoreGuard] Logged: ${message}`);
 }
 
 /**
@@ -845,86 +1047,38 @@ async function processThemePublish(
 }
 
 /**
- * Process an order paid job
+ * Process an app scopes update job
+ * Diffs previous vs current scopes and creates ChangeEvent for permission changes
  */
-async function processOrderPaid(
+async function processScopesUpdate(
   shop: string,
-  payload: {
-    id: number;
-    name: string;
-    total_price: string;
-    subtotal_price: string;
-    currency: string;
-    financial_status: string;
-    line_items: Array<{
-      title: string;
-      quantity: number;
-      price: string;
-      variant_title: string | null;
-      product_id: number | null;
-    }>;
-    discount_codes: Array<{ code: string; amount: string }>;
-  },
+  sessionId: string,
+  payload: { current: string[] },
   webhookId: string | null
 ): Promise<void> {
-  const itemCount = payload.line_items.reduce((sum, item) => sum + item.quantity, 0);
-  const firstItem = payload.line_items[0]?.title || "items";
-  const itemSummary = itemCount === 1 ? firstItem : `${itemCount} items`;
-
-  const amount = parseFloat(payload.total_price);
-  const formattedAmount = amount.toLocaleString("en-US", {
-    style: "currency",
-    currency: payload.currency || "USD",
-  });
-
-  const message = `Order ${payload.name} - ${formattedAmount}`;
-
-  const diff = JSON.stringify({
-    orderId: payload.id,
-    orderName: payload.name,
-    total: payload.total_price,
-    subtotal: payload.subtotal_price,
-    currency: payload.currency,
-    status: payload.financial_status,
-    itemCount,
-    itemSummary,
-    items: payload.line_items.map((item) => ({
-      title: item.title,
-      variant: item.variant_title,
-      quantity: item.quantity,
-      price: item.price,
-      productId: item.product_id,
-    })),
-    discounts: payload.discount_codes,
+  // Get the previous scopes from the session before updating
+  const currentSession = await db.session.findUnique({
+    where: { id: sessionId },
+    select: { scope: true },
   });
 
-  await db.eventLog.create({
-    data: {
-      shop,
-      shopifyId: String(payload.id),
-      topic: "ORDERS_CREATE",
-      author: "Customer",
-      message,
-      diff,
-      webhookId,
-    },
-  });
+  const previousScopes = currentSession?.scope
+    ? currentSession.scope.split(",").map(s => s.trim()).filter(Boolean)
+    : [];
 
-  console.log(`[StoreGuard] Logged: ${message}`);
-}
+  const currentScopes = payload.current;
 
-/**
- * Process an app scopes update job
- */
-async function processScopesUpdate(
-  shop: string,
-  sessionId: string,
-  payload: { current: string[] }
-): Promise<void> {
+  // Update the session with new scopes
   await db.session.update({
     where: { id: sessionId },
-    data: { scope: payload.current.toString() },
+    data: { scope: currentScopes.toString() },
   });
+
+  // === StoreGuard: Create ChangeEvent for permission diff ===
+  if (webhookId) {
+    await recordAppPermissionsChanged(shop, previousScopes, currentScopes, webhookId);
+  }
+
   console.log(`[StoreGuard] Updated scopes for ${shop}`);
 }
 
@@ -951,7 +1105,7 @@ async function processJob(job: {
   const payload = JSON.parse(job.payload);
 
   // Normalize topic format: PRODUCTS_UPDATE -> products/update
-  const normalizedTopic = job.topic.toLowerCase().replace(/_/g, "/");
+  const normalizedTopic = normalizeTopic(job.topic);
 
   switch (normalizedTopic) {
     case "products/update":
@@ -974,11 +1128,18 @@ async function processJob(job: {
     case "themes/publish":
       await processThemePublish(job.shop, payload, job.webhookId);
       break;
-    case "orders/paid":
-      await processOrderPaid(job.shop, payload, job.webhookId);
+    case "discounts/create":
+    case "discounts/update":
+    case "discounts/delete":
+      await processDiscount(job.shop, normalizedTopic, payload, job.webhookId);
+      break;
+    case "domains/create":
+    case "domains/update":
+    case "domains/destroy":
+      await processDomain(job.shop, normalizedTopic, payload, job.webhookId);
       break;
     case "app/scopes/update":
-      await processScopesUpdate(job.shop, session.id, payload);
+      await processScopesUpdate(job.shop, session.id, payload, job.webhookId);
       break;
     default:
       console.log(`[StoreGuard] Unknown topic: ${job.topic} (normalized: ${normalizedTopic})`);
diff --git a/insightops/app/services/jobProcessor.test.ts b/insightops/app/services/jobProcessor.test.ts
new file mode 100644
index 0000000..3ed08ff
--- /dev/null
+++ b/insightops/app/services/jobProcessor.test.ts
@@ -0,0 +1,93 @@
+import { describe, it, expect } from "vitest";
+import {
+  aggregateInventoryLevels,
+  type InventoryLevelNode,
+} from "./changeDetection.utils";
+
+describe("aggregateInventoryLevels", () => {
+  it("should sum quantities across all locations", () => {
+    const nodes: InventoryLevelNode[] = [
+      { quantities: [{ quantity: 10 }], location: { id: "gid://shopify/Location/1", name: "Warehouse A" } },
+      { quantities: [{ quantity: 20 }], location: { id: "gid://shopify/Location/2", name: "Warehouse B" } },
+      { quantities: [{ quantity: 5 }], location: { id: "gid://shopify/Location/3", name: "Retail Store" } },
+    ];
+
+    const result = aggregateInventoryLevels(nodes, 2);
+    expect(result.totalQuantity).toBe(35);
+    expect(result.locationName).toBe("Warehouse B");
+  });
+
+  it("should return zero for empty nodes array", () => {
+    const result = aggregateInventoryLevels([], 1);
+    expect(result.totalQuantity).toBe(0);
+    expect(result.locationName).toBeNull();
+  });
+
+  it("should handle null location gracefully", () => {
+    const nodes: InventoryLevelNode[] = [
+      { quantities: [{ quantity: 7 }], location: null },
+      { quantities: [{ quantity: 3 }], location: { id: "gid://shopify/Location/5", name: "Main" } },
+    ];
+
+    const result = aggregateInventoryLevels(nodes, 5);
+    expect(result.totalQuantity).toBe(10);
+    expect(result.locationName).toBe("Main");
+  });
+
+  it("should return null locationName when trigger location not found", () => {
+    const nodes: InventoryLevelNode[] = [
+      { quantities: [{ quantity: 10 }], location: { id: "gid://shopify/Location/1", name: "Warehouse A" } },
+    ];
+
+    const result = aggregateInventoryLevels(nodes, 999);
+    expect(result.totalQuantity).toBe(10);
+    expect(result.locationName).toBeNull();
+  });
+
+  it("should handle missing quantities array", () => {
+    const nodes: InventoryLevelNode[] = [
+      { quantities: [], location: { id: "gid://shopify/Location/1", name: "W1" } },
+      { quantities: [{ quantity: 15 }], location: { id: "gid://shopify/Location/2", name: "W2" } },
+    ];
+
+    const result = aggregateInventoryLevels(nodes, 1);
+    expect(result.totalQuantity).toBe(15);
+    expect(result.locationName).toBe("W1");
+  });
+
+  it("should handle many locations (>50 simulating paginated results)", () => {
+    const nodes: InventoryLevelNode[] = [];
+    for (let i = 1; i <= 120; i++) {
+      nodes.push({
+        quantities: [{ quantity: 1 }],
+        location: { id: `gid://shopify/Location/${i}`, name: `Location ${i}` },
+      });
+    }
+
+    const result = aggregateInventoryLevels(nodes, 75);
+    expect(result.totalQuantity).toBe(120);
+    expect(result.locationName).toBe("Location 75");
+  });
+
+  it("should handle negative quantities", () => {
+    const nodes: InventoryLevelNode[] = [
+      { quantities: [{ quantity: -2 }], location: { id: "gid://shopify/Location/1", name: "Returns" } },
+      { quantities: [{ quantity: 10 }], location: { id: "gid://shopify/Location/2", name: "Warehouse" } },
+    ];
+
+    const result = aggregateInventoryLevels(nodes, 1);
+    expect(result.totalQuantity).toBe(8);
+    expect(result.locationName).toBe("Returns");
+  });
+
+  it("should handle zero quantities at all locations", () => {
+    const nodes: InventoryLevelNode[] = [
+      { quantities: [{ quantity: 0 }], location: { id: "gid://shopify/Location/1", name: "W1" } },
+      { quantities: [{ quantity: 0 }], location: { id: "gid://shopify/Location/2", name: "W2" } },
+    ];
+
+    const result = aggregateInventoryLevels(nodes, 1);
+    expect(result.totalQuantity).toBe(0);
+    expect(result.locationName).toBe("W1");
+  });
+});
diff --git a/insightops/app/services/jobProcessor.utils.test.ts b/insightops/app/services/jobProcessor.utils.test.ts
new file mode 100644
index 0000000..1cd7261
--- /dev/null
+++ b/insightops/app/services/jobProcessor.utils.test.ts
@@ -0,0 +1,245 @@
+import { describe, it, expect } from "vitest";
+import {
+  normalizeTopic,
+  isHandledTopic,
+  getTopicCategory,
+  diffScopes,
+  getTopicVerb,
+  HANDLED_TOPICS,
+} from "./jobProcessor.utils";
+
+describe("normalizeTopic", () => {
+  it("should lowercase and replace underscores with slashes", () => {
+    expect(normalizeTopic("PRODUCTS_UPDATE")).toBe("products/update");
+    expect(normalizeTopic("PRODUCTS_CREATE")).toBe("products/create");
+    expect(normalizeTopic("PRODUCTS_DELETE")).toBe("products/delete");
+  });
+
+  it("should handle inventory_levels topic", () => {
+    expect(normalizeTopic("inventory_levels/update")).toBe("inventory/levels/update");
+    expect(normalizeTopic("INVENTORY_LEVELS_UPDATE")).toBe("inventory/levels/update");
+  });
+
+  it("should handle themes/publish", () => {
+    expect(normalizeTopic("themes/publish")).toBe("themes/publish");
+    expect(normalizeTopic("THEMES_PUBLISH")).toBe("themes/publish");
+  });
+
+  it("should handle domain topics", () => {
+    expect(normalizeTopic("domains/create")).toBe("domains/create");
+    expect(normalizeTopic("domains/update")).toBe("domains/update");
+    expect(normalizeTopic("domains/destroy")).toBe("domains/destroy");
+    expect(normalizeTopic("DOMAINS_CREATE")).toBe("domains/create");
+    expect(normalizeTopic("DOMAINS_UPDATE")).toBe("domains/update");
+    expect(normalizeTopic("DOMAINS_DESTROY")).toBe("domains/destroy");
+  });
+
+  it("should handle app/scopes_update", () => {
+    expect(normalizeTopic("app/scopes_update")).toBe("app/scopes/update");
+    expect(normalizeTopic("APP_SCOPES_UPDATE")).toBe("app/scopes/update");
+  });
+
+  it("should handle discount topics", () => {
+    expect(normalizeTopic("discounts/create")).toBe("discounts/create");
+    expect(normalizeTopic("discounts/update")).toBe("discounts/update");
+    expect(normalizeTopic("discounts/delete")).toBe("discounts/delete");
+    expect(normalizeTopic("DISCOUNTS_CREATE")).toBe("discounts/create");
+  });
+
+  it("should handle collection topics", () => {
+    expect(normalizeTopic("collections/create")).toBe("collections/create");
+    expect(normalizeTopic("collections/update")).toBe("collections/update");
+    expect(normalizeTopic("collections/delete")).toBe("collections/delete");
+    expect(normalizeTopic("COLLECTIONS_DELETE")).toBe("collections/delete");
+  });
+
+  it("should be idempotent on already-normalized topics", () => {
+    for (const topic of HANDLED_TOPICS) {
+      expect(normalizeTopic(topic)).toBe(topic);
+    }
+  });
+});
+
+describe("isHandledTopic", () => {
+  it("should return true for all handled topics", () => {
+    for (const topic of HANDLED_TOPICS) {
+      expect(isHandledTopic(topic)).toBe(true);
+    }
+  });
+
+  it("should return false for unknown topics", () => {
+    expect(isHandledTopic("orders/create")).toBe(false);
+    expect(isHandledTopic("customers/update")).toBe(false);
+    expect(isHandledTopic("app/uninstalled")).toBe(false);
+    expect(isHandledTopic("")).toBe(false);
+    expect(isHandledTopic("foo/bar")).toBe(false);
+  });
+
+  it("should return false for unnormalized topics", () => {
+    expect(isHandledTopic("PRODUCTS_UPDATE")).toBe(false);
+    expect(isHandledTopic("THEMES_PUBLISH")).toBe(false);
+  });
+});
+
+describe("getTopicCategory", () => {
+  it("should categorize product topics", () => {
+    expect(getTopicCategory("products/update")).toBe("product");
+    expect(getTopicCategory("products/create")).toBe("product");
+    expect(getTopicCategory("products/delete")).toBe("product");
+  });
+
+  it("should categorize collection topics", () => {
+    expect(getTopicCategory("collections/create")).toBe("collection");
+    expect(getTopicCategory("collections/update")).toBe("collection");
+    expect(getTopicCategory("collections/delete")).toBe("collection");
+  });
+
+  it("should categorize inventory topics", () => {
+    expect(getTopicCategory("inventory/levels/update")).toBe("inventory");
+  });
+
+  it("should categorize theme topics", () => {
+    expect(getTopicCategory("themes/publish")).toBe("theme");
+  });
+
+  it("should categorize discount topics", () => {
+    expect(getTopicCategory("discounts/create")).toBe("discount");
+    expect(getTopicCategory("discounts/update")).toBe("discount");
+    expect(getTopicCategory("discounts/delete")).toBe("discount");
+  });
+
+  it("should categorize domain topics", () => {
+    expect(getTopicCategory("domains/create")).toBe("domain");
+    expect(getTopicCategory("domains/update")).toBe("domain");
+    expect(getTopicCategory("domains/destroy")).toBe("domain");
+  });
+
+  it("should categorize app scopes topic", () => {
+    expect(getTopicCategory("app/scopes/update")).toBe("app_scopes");
+  });
+
+  it("should return unknown for unrecognized topics", () => {
+    expect(getTopicCategory("orders/create")).toBe("unknown");
+    expect(getTopicCategory("customers/update")).toBe("unknown");
+    expect(getTopicCategory("")).toBe("unknown");
+  });
+});
+
+describe("diffScopes", () => {
+  it("should detect added scopes", () => {
+    const result = diffScopes(
+      ["read_products", "read_orders"],
+      ["read_products", "read_orders", "read_customers"]
+    );
+    expect(result.added).toEqual(["read_customers"]);
+    expect(result.removed).toEqual([]);
+  });
+
+  it("should detect removed scopes", () => {
+    const result = diffScopes(
+      ["read_products", "read_orders", "read_customers"],
+      ["read_products", "read_orders"]
+    );
+    expect(result.added).toEqual([]);
+    expect(result.removed).toEqual(["read_customers"]);
+  });
+
+  it("should detect both added and removed scopes", () => {
+    const result = diffScopes(
+      ["read_products", "read_orders"],
+      ["read_products", "read_customers", "write_products"]
+    );
+    expect(result.added).toEqual(["read_customers", "write_products"]);
+    expect(result.removed).toEqual(["read_orders"]);
+  });
+
+  it("should return empty arrays when scopes are identical", () => {
+    const result = diffScopes(
+      ["read_products", "read_orders"],
+      ["read_products", "read_orders"]
+    );
+    expect(result.added).toEqual([]);
+    expect(result.removed).toEqual([]);
+  });
+
+  it("should handle empty previous scopes (fresh install)", () => {
+    const result = diffScopes(
+      [],
+      ["read_products", "read_orders"]
+    );
+    expect(result.added).toEqual(["read_products", "read_orders"]);
+    expect(result.removed).toEqual([]);
+  });
+
+  it("should handle empty current scopes (all removed)", () => {
+    const result = diffScopes(
+      ["read_products", "read_orders"],
+      []
+    );
+    expect(result.added).toEqual([]);
+    expect(result.removed).toEqual(["read_products", "read_orders"]);
+  });
+
+  it("should handle both empty", () => {
+    const result = diffScopes([], []);
+    expect(result.added).toEqual([]);
+    expect(result.removed).toEqual([]);
+  });
+});
+
+describe("getTopicVerb", () => {
+  it("should extract verb from topic", () => {
+    expect(getTopicVerb("domains/create")).toBe("create");
+    expect(getTopicVerb("domains/update")).toBe("update");
+    expect(getTopicVerb("domains/destroy")).toBe("destroy");
+    expect(getTopicVerb("discounts/create")).toBe("create");
+    expect(getTopicVerb("discounts/delete")).toBe("delete");
+    expect(getTopicVerb("collections/update")).toBe("update");
+  });
+
+  it("should handle multi-segment topics", () => {
+    expect(getTopicVerb("inventory/levels/update")).toBe("update");
+    expect(getTopicVerb("app/scopes/update")).toBe("update");
+  });
+
+  it("should handle single-segment topics", () => {
+    expect(getTopicVerb("publish")).toBe("publish");
+  });
+});
+
+describe("HANDLED_TOPICS completeness", () => {
+  it("should include all V2 webhook topics that get queued", () => {
+    // These are all topics from CLAUDE.md V2 section that go through the job processor
+    // (app/uninstalled is handled directly, not queued)
+    const expectedTopics = [
+      "products/create",
+      "products/update",
+      "products/delete",
+      "collections/create",
+      "collections/update",
+      "collections/delete",
+      "inventory/levels/update",
+      "themes/publish",
+      "discounts/create",
+      "discounts/update",
+      "discounts/delete",
+      "domains/create",
+      "domains/update",
+      "domains/destroy",
+      "app/scopes/update",
+    ];
+
+    for (const topic of expectedTopics) {
+      expect(
+        HANDLED_TOPICS.includes(topic as typeof HANDLED_TOPICS[number]),
+        `Missing topic: ${topic}`
+      ).toBe(true);
+    }
+  });
+
+  it("should not include app/uninstalled (handled directly)", () => {
+    expect(
+      (HANDLED_TOPICS as readonly string[]).includes("app/uninstalled")
+    ).toBe(false);
+  });
+});
diff --git a/insightops/app/services/jobProcessor.utils.ts b/insightops/app/services/jobProcessor.utils.ts
new file mode 100644
index 0000000..6cf56df
--- /dev/null
+++ b/insightops/app/services/jobProcessor.utils.ts
@@ -0,0 +1,92 @@
+/**
+ * Pure utility functions for the job processor.
+ * Extracted from jobProcessor.server.ts for testability.
+ */
+
+/**
+ * All webhook topics handled by the job processor.
+ * This is the single source of truth for topic routing.
+ */
+export const HANDLED_TOPICS = [
+  "products/update",
+  "products/create",
+  "products/delete",
+  "collections/create",
+  "collections/update",
+  "collections/delete",
+  "inventory/levels/update",
+  "themes/publish",
+  "discounts/create",
+  "discounts/update",
+  "discounts/delete",
+  "domains/create",
+  "domains/update",
+  "domains/destroy",
+  "app/scopes/update",
+] as const;
+
+export type HandledTopic = (typeof HANDLED_TOPICS)[number];
+
+/**
+ * Normalize a Shopify webhook topic to the format used in the job processor switch.
+ * Shopify sends topics as either "products/update" or "PRODUCTS_UPDATE".
+ *
+ * Examples:
+ *   "PRODUCTS_UPDATE" -> "products/update"
+ *   "inventory_levels/update" -> "inventory/levels/update"
+ *   "APP_SCOPES_UPDATE" -> "app/scopes/update"
+ *   "themes/publish" -> "themes/publish"
+ */
+export function normalizeTopic(topic: string): string {
+  return topic.toLowerCase().replace(/_/g, "/");
+}
+
+/**
+ * Check if a normalized topic is handled by the job processor.
+ */
+export function isHandledTopic(normalizedTopic: string): normalizedTopic is HandledTopic {
+  return (HANDLED_TOPICS as readonly string[]).includes(normalizedTopic);
+}
+
+/**
+ * Get the handler category for a topic. Used for logging and routing.
+ */
+export function getTopicCategory(
+  normalizedTopic: string
+): "product" | "collection" | "inventory" | "theme" | "discount" | "domain" | "app_scopes" | "unknown" {
+  if (normalizedTopic.startsWith("products/")) return "product";
+  if (normalizedTopic.startsWith("collections/")) return "collection";
+  if (normalizedTopic.startsWith("inventory/")) return "inventory";
+  if (normalizedTopic.startsWith("themes/")) return "theme";
+  if (normalizedTopic.startsWith("discounts/")) return "discount";
+  if (normalizedTopic.startsWith("domains/")) return "domain";
+  if (normalizedTopic === "app/scopes/update") return "app_scopes";
+  return "unknown";
+}
+
+/**
+ * Diff two sets of OAuth scopes.
+ * Returns added and removed scopes.
+ */
+export function diffScopes(
+  previousScopes: string[],
+  currentScopes: string[]
+): { added: string[]; removed: string[] } {
+  const added = currentScopes.filter((s) => !previousScopes.includes(s));
+  const removed = previousScopes.filter((s) => !currentScopes.includes(s));
+  return { added, removed };
+}
+
+/**
+ * Determine the verb (action) from a webhook topic.
+ * Used by domain and discount processors to decide behavior.
+ *
+ * Examples:
+ *   "domains/create" -> "create"
+ *   "domains/destroy" -> "destroy"
+ *   "discounts/update" -> "update"
+ */
+export function getTopicVerb(topic: string): string {
+  const parts = topic.split("/");
+  return parts[parts.length - 1];
+}
diff --git a/insightops/app/services/moneySaved.test.ts b/insightops/app/services/moneySaved.test.ts
new file mode 100644
index 0000000..760e487
--- /dev/null
+++ b/insightops/app/services/moneySaved.test.ts
@@ -0,0 +1,289 @@
+import { describe, it, expect } from "vitest";
+import { estimateMoneySaved } from "./moneySaved.utils";
+import type { ProductVelocity } from "./salesVelocity.utils";
+
+function makeVelocity(overrides: Partial<ProductVelocity> = {}): ProductVelocity {
+  return {
+    productId: "123",
+    totalUnitsSold: 240,
+    totalRevenue: 7200, // avg price $30
+    orderCount: 200,
+    dailySalesRate: 8, // 8 units/day
+    dailyRevenue: 240,
+    periodDays: 30,
+    ...overrides,
+  };
+}
+
+describe("estimateMoneySaved", () => {
+  // ===================
+  // Price change events
+  // ===================
+  describe("price_change", () => {
+    it("should estimate savings for a price drop", () => {
+      // $89 -> $8.90 = $80.10 delta
+      // 8 units/day * $80.10 * 3 days * 0.5 = $961.20
+      const result = estimateMoneySaved({
+        eventType: "price_change",
+        velocity: makeVelocity(),
+        beforeValue: "$89.00",
+        afterValue: "$8.90",
+      });
+
+      expect(result).not.toBeNull();
+      expect(result).toBeCloseTo(961.2, 1);
+    });
+
+    it("should return null for price increases (no loss)", () => {
+      const result = estimateMoneySaved({
+        eventType: "price_change",
+        velocity: makeVelocity(),
+        beforeValue: "$50.00",
+        afterValue: "$75.00",
+      });
+
+      expect(result).toBeNull();
+    });
+
+    it("should handle prices without dollar signs", () => {
+      const result = estimateMoneySaved({
+        eventType: "price_change",
+        velocity: makeVelocity({ dailySalesRate: 10 }),
+        beforeValue: "100.00",
+        afterValue: "80.00",
+      });
+
+      // $20 delta * 10/day * 3 days * 0.5 = $300
+      expect(result).toBeCloseTo(300, 1);
+    });
+
+    it("should return null when no velocity data", () => {
+      const result = estimateMoneySaved({
+        eventType: "price_change",
+        velocity: null,
+        beforeValue: "$100.00",
+        afterValue: "$50.00",
+      });
+
+      expect(result).toBeNull();
+    });
+
+    it("should return null when velocity is zero", () => {
+      const result = estimateMoneySaved({
+        eventType: "price_change",
+        velocity: makeVelocity({ dailySalesRate: 0 }),
+        beforeValue: "$100.00",
+        afterValue: "$50.00",
+      });
+
+      expect(result).toBeNull();
+    });
+
+    it("should return null for unparseable prices", () => {
+      const result = estimateMoneySaved({
+        eventType: "price_change",
+        velocity: makeVelocity(),
+        beforeValue: "free",
+        afterValue: "$50.00",
+      });
+
+      expect(result).toBeNull();
+    });
+
+    it("should return null when beforeValue is null", () => {
+      const result = estimateMoneySaved({
+        eventType: "price_change",
+        velocity: makeVelocity(),
+        beforeValue: null,
+        afterValue: "$50.00",
+      });
+
+      expect(result).toBeNull();
+    });
+  });
+
+  // ========================
+  // Inventory zero events
+  // ========================
+  describe("inventory_zero", () => {
+    it("should estimate savings for out-of-stock", () => {
+      // 8 units/day * $30 avg price * 3 days * 0.5 = $360
+      const result = estimateMoneySaved({
+        eventType: "inventory_zero",
+        velocity: makeVelocity(),
+        beforeValue: "10",
+        afterValue: "0",
+      });
+
+      expect(result).not.toBeNull();
+      expect(result).toBeCloseTo(360, 1);
+    });
+
+    it("should return null when no velocity data", () => {
+      const result = estimateMoneySaved({
+        eventType: "inventory_zero",
+        velocity: null,
+        beforeValue: "10",
+        afterValue: "0",
+      });
+
+      expect(result).toBeNull();
+    });
+
+    it("should return null when no sales", () => {
+      const result = estimateMoneySaved({
+        eventType: "inventory_zero",
+        velocity: makeVelocity({ dailySalesRate: 0, totalUnitsSold: 0, totalRevenue: 0 }),
+        beforeValue: "10",
+        afterValue: "0",
+      });
+
+      expect(result).toBeNull();
+    });
+  });
+
+  // ========================
+  // Inventory low events
+  // ========================
+  describe("inventory_low", () => {
+    it("should estimate savings (same formula as stockout)", () => {
+      // 8 units/day * $30 avg * 3 days * 0.5 = $360
+      const result = estimateMoneySaved({
+        eventType: "inventory_low",
+        velocity: makeVelocity(),
+        beforeValue: "10",
+        afterValue: "3",
+      });
+
+      expect(result).not.toBeNull();
+      expect(result).toBeCloseTo(360, 1);
+    });
+  });
+
+  // ========================
+  // Visibility change events
+  // ========================
+  describe("visibility_change", () => {
+    it("should estimate savings when product is hidden (draft)", () => {
+      // 8 units/day * $30 avg * 3 days * 0.5 = $360
+      const result = estimateMoneySaved({
+        eventType: "visibility_change",
+        velocity: makeVelocity(),
+        beforeValue: "active",
+        afterValue: "draft",
+      });
+
+      expect(result).not.toBeNull();
+      expect(result).toBeCloseTo(360, 1);
+    });
+
+    it("should estimate savings when product is archived", () => {
+      const result = estimateMoneySaved({
+        eventType: "visibility_change",
+        velocity: makeVelocity(),
+        beforeValue: "active",
+        afterValue: "archived",
+      });
+
+      expect(result).not.toBeNull();
+      expect(result).toBeCloseTo(360, 1);
+    });
+
+    it("should return null when product becomes visible (no loss)", () => {
+      const result = estimateMoneySaved({
+        eventType: "visibility_change",
+        velocity: makeVelocity(),
+        beforeValue: "draft",
+        afterValue: "active",
+      });
+
+      expect(result).toBeNull();
+    });
+  });
+
+  // ========================
+  // Non-applicable event types
+  // ========================
+  describe("non-applicable events", () => {
+    it("should return null for theme_publish", () => {
+      const result = estimateMoneySaved({
+        eventType: "theme_publish",
+        velocity: makeVelocity(),
+        beforeValue: null,
+        afterValue: "main",
+      });
+
+      expect(result).toBeNull();
+    });
+
+    it("should return null for collection events", () => {
+      const result = estimateMoneySaved({
+        eventType: "collection_deleted",
+        velocity: makeVelocity(),
+        beforeValue: "Featured",
+        afterValue: null,
+      });
+
+      expect(result).toBeNull();
+    });
+
+    it("should return null for discount events", () => {
+      const result = estimateMoneySaved({
+        eventType: "discount_deleted",
+        velocity: makeVelocity(),
+        beforeValue: "SALE50",
+        afterValue: null,
+      });
+
+      expect(result).toBeNull();
+    });
+  });
+
+  // ========================
+  // Edge cases
+  // ========================
+  describe("edge cases", () => {
+    it("should round to 2 decimal places", () => {
+      // velocity 3/day, price delta $7.33
+      // 3 * 7.33 * 3 * 0.5 = 32.985 -> 32.98 or 32.99 (floating point)
+      const result = estimateMoneySaved({
+        eventType: "price_change",
+        velocity: makeVelocity({ dailySalesRate: 3 }),
+        beforeValue: "$17.33",
+        afterValue: "$10.00",
+      });
+
+      expect(result).not.toBeNull();
+      // Floating point: Math.round(32.985 * 100) / 100 = 32.98
+      expect(result).toBe(32.98);
+    });
+
+    it("should handle very high velocity products", () => {
+      // 100 units/day * $50 delta * 3 days * 0.5 = $7500
+      const result = estimateMoneySaved({
+        eventType: "price_change",
+        velocity: makeVelocity({ dailySalesRate: 100 }),
+        beforeValue: "$100.00",
+        afterValue: "$50.00",
+      });
+
+      expect(result).toBeCloseTo(7500, 1);
+    });
+
+    it("should handle very low velocity products", () => {
+      // 0.1 units/day * $30 avg * 3 days * 0.5 = $4.50
+      const result = estimateMoneySaved({
+        eventType: "inventory_zero",
+        velocity: makeVelocity({
+          dailySalesRate: 0.1,
+          totalUnitsSold: 3,
+          totalRevenue: 90,
+        }),
+        beforeValue: "5",
+        afterValue: "0",
+      });
+
+      expect(result).toBeCloseTo(4.5, 1);
+    });
+  });
+});
diff --git a/insightops/app/services/moneySaved.utils.ts b/insightops/app/services/moneySaved.utils.ts
new file mode 100644
index 0000000..a7313e2
--- /dev/null
+++ b/insightops/app/services/moneySaved.utils.ts
@@ -0,0 +1,127 @@
+/**
+ * Money Saved Estimation Utilities for StoreGuard
+ *
+ * Estimates how much revenue a merchant saves by catching a change early.
+ * Pure functions — no database or API calls, fully testable.
+ *
+ * Formulas:
+ *   Price drop:    |priceDelta| × dailySalesRate × DISCOVERY_DAYS × CONSERVATIVE_FACTOR
+ *   Out of stock:  dailySalesRate × avgPrice × DISCOVERY_DAYS × CONSERVATIVE_FACTOR
+ *   Visibility:    dailySalesRate × avgPrice × DISCOVERY_DAYS × CONSERVATIVE_FACTOR
+ *
+ * All estimates apply a 50% conservative factor to avoid overpromising.
+ */
+
+import type { ProductVelocity } from "./salesVelocity.utils";
+
+/** How many days the issue would go unnoticed without StoreGuard */
+const DISCOVERY_DAYS = 3;
+
+/** Conservative multiplier to avoid overpromising */
+const CONSERVATIVE_FACTOR = 0.5;
+
+export interface MoneySavedInput {
+  eventType: string;
+  velocity: ProductVelocity | null;
+  beforeValue: string | null;
+  afterValue: string | null;
+}
+
+/**
+ * Parse a price string like "$89.00" or "89.00" to a number.
+ * Returns null if unparseable.
+ */
+function parsePrice(value: string | null): number | null {
+  if (!value) return null;
+  const num = parseFloat(value.replace(/^\$/, ""));
+  return isNaN(num) ? null : num;
+}
+
+/**
+ * Estimate money saved for a price change event.
+ * Only applies to price drops (where merchant would lose money per sale).
+ */
+function estimatePriceDropSavings(
+  velocity: ProductVelocity,
+  beforeValue: string | null,
+  afterValue: string | null
+): number | null {
+  const oldPrice = parsePrice(beforeValue);
+  const newPrice = parsePrice(afterValue);
+
+  if (oldPrice === null || newPrice === null) return null;
+
+  // Only price drops cost money (price increases are fine)
+  if (newPrice >= oldPrice) return null;
+
+  const priceDelta = oldPrice - newPrice;
+  return priceDelta * velocity.dailySalesRate * DISCOVERY_DAYS * CONSERVATIVE_FACTOR;
+}
+
+/**
+ * Estimate money saved for an out-of-stock event.
+ * Lost sales = velocity × avg price × days unnoticed.
+ */
+function estimateStockoutSavings(velocity: ProductVelocity): number | null {
+  if (velocity.dailySalesRate === 0) return null;
+
+  const avgPrice = velocity.totalRevenue / velocity.totalUnitsSold;
+  return velocity.dailySalesRate * avgPrice * DISCOVERY_DAYS * CONSERVATIVE_FACTOR;
+}
+
+/**
+ * Estimate money saved for a visibility change that hides a product.
+ * Same as stockout — product invisible means zero sales.
+ */
+function estimateVisibilitySavings(
+  velocity: ProductVelocity,
+  afterValue: string | null
+): number | null {
+  // Only hidden products cost money (draft/archived)
+  if (afterValue === "active") return null;
+
+  if (velocity.dailySalesRate === 0) return null;
+
+  const avgPrice = velocity.totalRevenue / velocity.totalUnitsSold;
+  return velocity.dailySalesRate * avgPrice * DISCOVERY_DAYS * CONSERVATIVE_FACTOR;
+}
+
+/**
+ * Estimate money saved by catching a change event.
+ * Returns null when estimation isn't applicable (no velocity data, no impact).
+ * Returns a positive dollar amount rounded to 2 decimal places.
+ */
+export function estimateMoneySaved(input: MoneySavedInput): number | null {
+  const { eventType, velocity, beforeValue, afterValue } = input;
+
+  if (!velocity || velocity.dailySalesRate === 0) {
+    return null;
+  }
+
+  let estimate: number | null = null;
+
+  switch (eventType) {
+    case "price_change":
+      estimate = estimatePriceDropSavings(velocity, beforeValue, afterValue);
+      break;
+    case "inventory_zero":
+      estimate = estimateStockoutSavings(velocity);
+      break;
+    case "inventory_low":
+      // Low stock is a warning — estimate savings if it would eventually hit zero
+      estimate = estimateStockoutSavings(velocity);
+      break;
+    case "visibility_change":
+      estimate = estimateVisibilitySavings(velocity, afterValue);
+      break;
+    default:
+      // Other event types (theme_publish, collection, discount, etc.) don't have
+      // quantifiable revenue impact
+      return null;
+  }
+
+  if (estimate === null || estimate <= 0) return null;
+
+  // Round to 2 decimal places
+  return Math.round(estimate * 100) / 100;
+}
diff --git a/insightops/app/services/onboarding.test.ts b/insightops/app/services/onboarding.test.ts
new file mode 100644
index 0000000..d744338
--- /dev/null
+++ b/insightops/app/services/onboarding.test.ts
@@ -0,0 +1,132 @@
+import { describe, it, expect } from "vitest";
+import {
+  ONBOARDING_STEPS,
+  getStepIndex,
+  isValidStep,
+  getNextStep,
+  getPreviousStep,
+  isValidEmail,
+  validateEmailStep,
+  validateMonitorStep,
+  DEFAULT_MONITORS,
+  type MonitorSelections,
+} from "./onboarding.utils";
+
+describe("ONBOARDING_STEPS", () => {
+  it("has exactly 5 steps in correct order", () => {
+    expect(ONBOARDING_STEPS).toEqual(["welcome", "email", "monitors", "sync", "done"]);
+    expect(ONBOARDING_STEPS).toHaveLength(5);
+  });
+});
+
+describe("getStepIndex", () => {
+  it("returns correct index for each step", () => {
+    expect(getStepIndex("welcome")).toBe(0);
+    expect(getStepIndex("email")).toBe(1);
+    expect(getStepIndex("monitors")).toBe(2);
+    expect(getStepIndex("sync")).toBe(3);
+    expect(getStepIndex("done")).toBe(4);
+  });
+});
+
+describe("isValidStep", () => {
+  it("returns true for valid steps", () => {
+    expect(isValidStep("welcome")).toBe(true);
+    expect(isValidStep("email")).toBe(true);
+    expect(isValidStep("monitors")).toBe(true);
+    expect(isValidStep("sync")).toBe(true);
+    expect(isValidStep("done")).toBe(true);
+  });
+
+  it("returns false for invalid steps", () => {
+    expect(isValidStep("invalid")).toBe(false);
+    expect(isValidStep("")).toBe(false);
+    expect(isValidStep("setup")).toBe(false);
+  });
+});
+
+describe("getNextStep", () => {
+  it("returns the next step", () => {
+    expect(getNextStep("welcome")).toBe("email");
+    expect(getNextStep("email")).toBe("monitors");
+    expect(getNextStep("monitors")).toBe("sync");
+    expect(getNextStep("sync")).toBe("done");
+  });
+
+  it("returns null for the last step", () => {
+    expect(getNextStep("done")).toBeNull();
+  });
+});
+
+describe("getPreviousStep", () => {
+  it("returns the previous step", () => {
+    expect(getPreviousStep("email")).toBe("welcome");
+    expect(getPreviousStep("monitors")).toBe("email");
+    expect(getPreviousStep("sync")).toBe("monitors");
+    expect(getPreviousStep("done")).toBe("sync");
+  });
+
+  it("returns null for the first step", () => {
+    expect(getPreviousStep("welcome")).toBeNull();
+  });
+});
+
+describe("isValidEmail", () => {
+  it("accepts valid emails", () => {
+    expect(isValidEmail("user@example.com")).toBe(true);
+    expect(isValidEmail("user+tag@domain.co.uk")).toBe(true);
+    expect(isValidEmail("a@b.c")).toBe(true);
+  });
+
+  it("rejects invalid emails", () => {
+    expect(isValidEmail("")).toBe(false);
+    expect(isValidEmail("noatsign")).toBe(false);
+    expect(isValidEmail("no@domain")).toBe(false);
+    expect(isValidEmail("@no-user.com")).toBe(false);
+    expect(isValidEmail("spaces in@email.com")).toBe(false);
+  });
+});
+
+describe("validateEmailStep", () => {
+  it("returns error for empty email", () => {
+    expect(validateEmailStep("")).toBe("Please enter an email address to receive alerts.");
+    expect(validateEmailStep("   ")).toBe("Please enter an email address to receive alerts.");
+  });
+
+  it("returns error for invalid email", () => {
+    expect(validateEmailStep("notanemail")).toBe("Please enter a valid email address.");
+  });
+
+  it("returns null for valid email", () => {
+    expect(validateEmailStep("user@example.com")).toBeNull();
+    expect(validateEmailStep("  user@example.com  ")).toBeNull();
+  });
+});
+
+describe("validateMonitorStep", () => {
+  it("returns error when no monitors selected", () => {
+    const noMonitors: MonitorSelections = {
+      trackPrices: false,
+      trackVisibility: false,
+      trackInventory: false,
+      trackCollections: false,
+    };
+    expect(validateMonitorStep(noMonitors)).toBe("Please select at least one monitor.");
+  });
+
+  it("returns null when at least one monitor is selected", () => {
+    expect(validateMonitorStep({ ...DEFAULT_MONITORS, trackPrices: true, trackVisibility: false, trackInventory: false, trackCollections: false })).toBeNull();
+    expect(validateMonitorStep(DEFAULT_MONITORS)).toBeNull();
+  });
+});
+
+describe("DEFAULT_MONITORS", () => {
+  it("has all monitors enabled by default", () => {
+    expect(DEFAULT_MONITORS).toEqual({
+      trackPrices: true,
+      trackVisibility: true,
+      trackInventory: true,
+      trackCollections: true,
+    });
+  });
+});
diff --git a/insightops/app/services/onboarding.utils.ts b/insightops/app/services/onboarding.utils.ts
new file mode 100644
index 0000000..c77cda6
--- /dev/null
+++ b/insightops/app/services/onboarding.utils.ts
@@ -0,0 +1,59 @@
+/**
+ * Onboarding step definitions and validation logic.
+ * Pure functions — no database or server dependencies.
+ */
+
+export const ONBOARDING_STEPS = ["welcome", "email", "monitors", "sync", "done"] as const;
+export type OnboardingStep = (typeof ONBOARDING_STEPS)[number];
+
+export function getStepIndex(step: OnboardingStep): number {
+  return ONBOARDING_STEPS.indexOf(step);
+}
+
+export function isValidStep(step: string): step is OnboardingStep {
+  return ONBOARDING_STEPS.includes(step as OnboardingStep);
+}
+
+export function getNextStep(current: OnboardingStep): OnboardingStep | null {
+  const idx = getStepIndex(current);
+  if (idx < 0 || idx >= ONBOARDING_STEPS.length - 1) return null;
+  return ONBOARDING_STEPS[idx + 1];
+}
+
+export function getPreviousStep(current: OnboardingStep): OnboardingStep | null {
+  const idx = getStepIndex(current);
+  if (idx <= 0) return null;
+  return ONBOARDING_STEPS[idx - 1];
+}
+
+export function isValidEmail(email: string): boolean {
+  return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
+}
+
+export interface MonitorSelections {
+  trackPrices: boolean;
+  trackVisibility: boolean;
+  trackInventory: boolean;
+  trackCollections: boolean;
+}
+
+export const DEFAULT_MONITORS: MonitorSelections = {
+  trackPrices: true,
+  trackVisibility: true,
+  trackInventory: true,
+  trackCollections: true,
+};
+
+export function validateEmailStep(email: string): string | null {
+  const trimmed = email.trim();
+  if (!trimmed) return "Please enter an email address to receive alerts.";
+  if (!isValidEmail(trimmed)) return "Please enter a valid email address.";
+  return null;
+}
+
+export function validateMonitorStep(monitors: MonitorSelections): string | null {
+  const hasAny = monitors.trackPrices || monitors.trackVisibility ||
+    monitors.trackInventory || monitors.trackCollections;
+  if (!hasAny) return "Please select at least one monitor.";
+  return null;
+}
diff --git a/insightops/app/services/productSync.server.ts b/insightops/app/services/productSync.server.ts
index 6e95349..8606c1d 100644
--- a/insightops/app/services/productSync.server.ts
+++ b/insightops/app/services/productSync.server.ts
@@ -98,6 +98,12 @@ export const VARIANTS_PER_PAGE = 100;
  */
 const THROTTLE_THRESHOLD = 200;
 
+/**
+ * Maximum number of consecutive throttle retries before aborting.
+ * Prevents infinite loops under persistent rate limiting.
+ */
+export const MAX_THROTTLE_RETRIES = 10;
+
 /**
  * Wait for Shopify's rate limit bucket to refill enough for the next query.
  * Returns immediately if sufficient budget is available.
@@ -208,8 +214,8 @@ export async function getSyncStatus(shop: string): Promise<{
   if (!syncRecord) {
     // Legacy installs may have ProductCache entries from webhooks without ever creating baseline snapshots.
     // Baselines are what make the *first* product update show a diff.
-    const baselineCount = await db.eventLog.count({
-      where: { shop, topic: "products/snapshot" },
+    const baselineCount = await db.changeEvent.count({
+      where: { shop, eventType: "product_snapshot" },
     });
 
     if (baselineCount > 0) {
@@ -252,6 +258,7 @@ async function fetchAllVariants(
   // Paginate remaining variants
   let variantCursor = product.variants.pageInfo.endCursor;
   let hasMore = true;
+  let variantThrottleRetries = 0;
 
   while (hasMore) {
     const response = await admin.graphql(
@@ -285,11 +292,21 @@ async function fetchAllVariants(
     // Handle throttling on variant fetches
     const retryMs = getThrottleRetryMs(data);
     if (retryMs > 0) {
-      console.log(`[StoreGuard] Throttled on variant fetch, waiting ${retryMs}ms`);
+      variantThrottleRetries++;
+      if (variantThrottleRetries >= MAX_THROTTLE_RETRIES) {
+        console.warn(
+          `[StoreGuard] Variant fetch for product ${product.id} hit max throttle retries (${MAX_THROTTLE_RETRIES}), returning partial variants`
+        );
+        break;
+      }
+      console.log(`[StoreGuard] Throttled on variant fetch (attempt ${variantThrottleRetries}/${MAX_THROTTLE_RETRIES}), waiting ${retryMs}ms`);
       await new Promise((resolve) => setTimeout(resolve, retryMs));
       continue; // Retry the same cursor
     }
 
+    // Reset counter on successful request
+    variantThrottleRetries = 0;
+
     const variantPage = data.data?.product?.variants;
     if (!variantPage) break;
 
@@ -342,6 +359,8 @@ export async function syncProducts(
     update: { status: "syncing", startedAt: new Date(), error: null },
   });
 
+  let throttleRetries = 0;
+
   try {
     while (hasNextPage) {
       const response = await admin.graphql(
@@ -403,11 +422,21 @@ export async function syncProducts(
       // Handle THROTTLED errors — wait and retry the same cursor
       const retryMs = getThrottleRetryMs(data);
       if (retryMs > 0) {
-        console.log(`[StoreGuard] Throttled by Shopify, waiting ${retryMs}ms before retry...`);
+        throttleRetries++;
+        if (throttleRetries >= MAX_THROTTLE_RETRIES) {
+          console.warn(
+            `[StoreGuard] Product sync hit max throttle retries (${MAX_THROTTLE_RETRIES}) for ${shop}, returning partial result (${synced} products synced)`
+          );
+          break;
+        }
+        console.log(`[StoreGuard] Throttled by Shopify (attempt ${throttleRetries}/${MAX_THROTTLE_RETRIES}), waiting ${retryMs}ms before retry...`);
         await new Promise((resolve) => setTimeout(resolve, retryMs));
         continue; // Retry with the same cursor
       }
 
+      // Reset counter on successful request
+      throttleRetries = 0;
+
       const products = data.data?.products;
 
       if (!products) {
@@ -421,7 +450,7 @@ export async function syncProducts(
         data.extensions?.cost?.actualQueryCost ?? 50
       );
 
-      // Upsert products into cache and create baseline EventLog entries
+      // Upsert products into cache and create baseline ChangeEvent entries
       for (const edge of products.edges) {
         const product = edge.node;
         // Extract numeric ID from GID (gid://shopify/Product/123)
@@ -457,20 +486,44 @@ export async function syncProducts(
           inventoryQuantity: v.inventoryQuantity ?? 0,
         }));
 
-        await db.productSnapshot.upsert({
-          where: { shop_id: { shop, id: numericId } },
-          create: {
-            id: numericId,
-            shop,
-            title: product.title,
-            status: product.status.toLowerCase(),
-            variants: JSON.stringify(productSnapshotVariants),
-          },
-          update: {
-            title: product.title,
-            status: product.status.toLowerCase(),
-            variants: JSON.stringify(productSnapshotVariants),
-          },
+        await db.$transaction(async (tx) => {
+          await tx.productSnapshot.upsert({
+            where: { shop_id: { shop, id: numericId } },
+            create: {
+              id: numericId,
+              shop,
+              title: product.title,
+              status: product.status.toLowerCase(),
+            },
+            update: {
+              title: product.title,
+              status: product.status.toLowerCase(),
+            },
+          });
+
+          for (const v of productSnapshotVariants) {
+            await tx.variantSnapshot.upsert({
+              where: {
+                productSnapshotId_shopifyVariantId: {
+                  productSnapshotId: numericId,
+                  shopifyVariantId: String(v.id),
+                },
+              },
+              create: {
+                productSnapshotId: numericId,
+                shop,
+                shopifyVariantId: String(v.id),
+                title: v.title,
+                price: String(v.price),
+                inventoryQuantity: v.inventoryQuantity,
+              },
+              update: {
+                title: v.title,
+                price: String(v.price),
+                inventoryQuantity: v.inventoryQuantity,
+              },
+            });
+          }
         });
 
         // Build a synthetic ProductNode with all variants for snapshot creation
@@ -482,11 +535,11 @@ export async function syncProducts(
           },
         };
 
-        // Ensure we have a baseline snapshot for this product (legacy EventLog).
+        // Ensure we have a baseline snapshot for this product.
         // IMPORTANT: ProductCache can exist from webhooks, but that doesn't mean a baseline snapshot exists.
-        // Only `products/snapshot` events count as baselines.
-        const existingBaseline = await db.eventLog.findFirst({
-          where: { shop, shopifyId: numericId, topic: "products/snapshot" },
+        // Only `product_snapshot` events count as baselines.
+        const existingBaseline = await db.changeEvent.findFirst({
+          where: { shop, entityId: numericId, eventType: "product_snapshot" },
         });
 
         if (!existingBaseline || force) {
@@ -497,31 +550,37 @@ export async function syncProducts(
             changes: [], // No changes for baseline
           });
 
-          // Don't spam multiple baselines unless explicitly forced; even on force, keep it idempotent by upserting a single baseline.
-          // Prisma doesn't support "upsert" without a unique key, so we just create a new baseline when forcing.
-          // (For normal runs, we only create if missing.)
+          // Don't spam multiple baselines unless explicitly forced; even on force, keep it idempotent.
           if (!existingBaseline) {
-            await db.eventLog.create({
+            await db.changeEvent.create({
               data: {
                 shop,
-                shopifyId: numericId,
+                entityType: "product",
+                entityId: numericId,
+                eventType: "product_snapshot",
+                resourceName: product.title,
+                source: "sync_job",
+                importance: "low",
                 topic: "products/snapshot",
                 author: "StoreGuard",
-                message: `Baseline snapshot for "${product.title}"`,
                 diff,
-                webhookId: null,
+                webhookId: `baseline-${numericId}-${Date.now()}`,
               },
             });
           } else if (force) {
-            await db.eventLog.create({
+            await db.changeEvent.create({
               data: {
                 shop,
-                shopifyId: numericId,
+                entityType: "product",
+                entityId: numericId,
+                eventType: "product_snapshot",
+                resourceName: product.title,
+                source: "sync_job",
+                importance: "low",
                 topic: "products/snapshot",
                 author: "StoreGuard",
-                message: `Refreshed baseline snapshot for "${product.title}"`,
                 diff,
-                webhookId: null,
+                webhookId: `baseline-${numericId}-${Date.now()}`,
               },
             });
           }
@@ -588,7 +647,7 @@ export async function needsProductSync(shop: string): Promise<boolean> {
   const syncRecord = await db.shopSync.findUnique({ where: { shop } });
   const snapshotCount = await db.productSnapshot.count({ where: { shop } });
   const cacheCount = await db.productCache.count({ where: { shop } });
-  const baselineCount = await db.eventLog.count({ where: { shop, topic: "products/snapshot" } });
+  const baselineCount = await db.changeEvent.count({ where: { shop, eventType: "product_snapshot" } });
   const expectedCount = Math.max(syncRecord?.syncedProducts ?? 0, cacheCount, baselineCount);
 
   if (syncRecord) {
diff --git a/insightops/app/services/productSync.test.ts b/insightops/app/services/productSync.test.ts
index 00f9c75..bf40eb8 100644
--- a/insightops/app/services/productSync.test.ts
+++ b/insightops/app/services/productSync.test.ts
@@ -1,11 +1,42 @@
-import { describe, it, expect, vi } from "vitest";
+import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
 import {
   waitForRateLimit,
   getThrottleRetryMs,
   PRODUCTS_PER_PAGE,
   VARIANTS_PER_PAGE,
+  MAX_THROTTLE_RETRIES,
+  syncProducts,
 } from "./productSync.server";
 
+vi.mock("../db.server", () => {
+  const mockDb = {
+    shopSync: {
+      upsert: vi.fn().mockResolvedValue({}),
+      update: vi.fn().mockResolvedValue({}),
+    },
+    productCache: {
+      upsert: vi.fn().mockResolvedValue({}),
+    },
+    productSnapshot: {
+      upsert: vi.fn().mockResolvedValue({}),
+    },
+    variantSnapshot: {
+      upsert: vi.fn().mockResolvedValue({}),
+    },
+    changeEvent: {
+      findFirst: vi.fn().mockResolvedValue(null),
+      create: vi.fn().mockResolvedValue({}),
+    },
+    $transaction: vi.fn(async (fn: (tx: unknown) => Promise<void>) => {
+      await fn({
+        productSnapshot: { upsert: vi.fn().mockResolvedValue({}) },
+        variantSnapshot: { upsert: vi.fn().mockResolvedValue({}) },
+      });
+    }),
+  };
+  return { default: mockDb };
+});
+
 describe("PRODUCTS_PER_PAGE", () => {
   it("should be 250 (Shopify max)", () => {
     expect(PRODUCTS_PER_PAGE).toBe(250);
@@ -163,3 +194,163 @@ describe("waitForRateLimit", () => {
     vi.useRealTimers();
   });
 });
+
+describe("MAX_THROTTLE_RETRIES", () => {
+  it("should be 10", () => {
+    expect(MAX_THROTTLE_RETRIES).toBe(10);
+  });
+});
+
+describe("syncProducts throttle retry cap", () => {
+  beforeEach(() => {
+    vi.useFakeTimers();
+    vi.spyOn(console, "log").mockImplementation(() => {});
+    vi.spyOn(console, "warn").mockImplementation(() => {});
+    vi.spyOn(console, "error").mockImplementation(() => {});
+  });
+
+  afterEach(() => {
+    vi.useRealTimers();
+    vi.restoreAllMocks();
+  });
+
+  function makeThrottledResponse() {
+    return {
+      json: () =>
+        Promise.resolve({
+          data: undefined,
+          errors: [{ message: "Throttled", extensions: { code: "THROTTLED" } }],
+          extensions: {
+            cost: {
+              requestedQueryCost: 500,
+              actualQueryCost: 0,
+              throttleStatus: {
+                maximumAvailable: 1000,
+                currentlyAvailable: 0,
+                restoreRate: 50,
+              },
+            },
+          },
+        }),
+    };
+  }
+
+  it("should abort product sync after MAX_THROTTLE_RETRIES consecutive throttles", async () => {
+    const graphqlMock = vi.fn().mockResolvedValue(makeThrottledResponse());
+    const admin = { graphql: graphqlMock };
+
+    const syncPromise = syncProducts("test-shop.myshopify.com", admin);
+
+    // Each throttle retry waits (500/50)*1000 + 1000 = 11000ms
+    // We need to advance through MAX_THROTTLE_RETRIES iterations
+    for (let i = 0; i < MAX_THROTTLE_RETRIES; i++) {
+      await vi.advanceTimersByTimeAsync(11000);
+    }
+
+    const result = await syncPromise;
+
+    expect(result.synced).toBe(0);
+    expect(graphqlMock).toHaveBeenCalledTimes(MAX_THROTTLE_RETRIES);
+    expect(console.warn).toHaveBeenCalledWith(
+      expect.stringContaining("hit max throttle retries")
+    );
+  });
+
+  it("should reset retry counter after a successful request", async () => {
+    let callCount = 0;
+
+    const graphqlMock = vi.fn().mockImplementation(() => {
+      callCount++;
+      // First call: throttled
+      // Second call: success with no more pages
+      if (callCount === 1) {
+        return Promise.resolve(makeThrottledResponse());
+      }
+      return Promise.resolve({
+        json: () =>
+          Promise.resolve({
+            data: {
+              products: {
+                edges: [],
+                pageInfo: { hasNextPage: false, endCursor: null },
+              },
+            },
+            extensions: {
+              cost: {
+                requestedQueryCost: 50,
+                actualQueryCost: 50,
+                throttleStatus: {
+                  maximumAvailable: 1000,
+                  currentlyAvailable: 800,
+                  restoreRate: 50,
+                },
+              },
+            },
+          }),
+      });
+    });
+
+    const admin = { graphql: graphqlMock };
+    const syncPromise = syncProducts("test-shop.myshopify.com", admin);
+
+    // Advance past the throttle wait
+    await vi.advanceTimersByTimeAsync(11000);
+
+    const result = await syncPromise;
+
+    // Should have succeeded after one throttle + one successful request
+    expect(result.synced).toBe(0);
+    expect(result.error).toBeUndefined();
+    expect(graphqlMock).toHaveBeenCalledTimes(2);
+    expect(console.warn).not.toHaveBeenCalled();
+  });
+
+  it("should not abort if throttles are non-consecutive (interspersed with successes)", async () => {
+    let callCount = 0;
+
+    const graphqlMock = vi.fn().mockImplementation(() => {
+      callCount++;
+      // Alternate: throttle, success with products + next page, throttle, success with no next page
+      if (callCount % 2 === 1 && callCount < 8) {
+        return Promise.resolve(makeThrottledResponse());
+      }
+      const hasNextPage = callCount < 7;
+      return Promise.resolve({
+        json: () =>
+          Promise.resolve({
+            data: {
+              products: {
+                edges: [],
+                pageInfo: { hasNextPage, endCursor: hasNextPage ? "cursor" : null },
+              },
+            },
+            extensions: {
+              cost: {
+                requestedQueryCost: 50,
+                actualQueryCost: 50,
+                throttleStatus: {
+                  maximumAvailable: 1000,
+                  currentlyAvailable: 800,
+                  restoreRate: 50,
+                },
+              },
+            },
+          }),
+      });
+    });
+
+    const admin = { graphql: graphqlMock };
+    const syncPromise = syncProducts("test-shop.myshopify.com", admin);
+
+    // Advance through multiple throttle waits
+    for (let i = 0; i < 10; i++) {
+      await vi.advanceTimersByTimeAsync(11000);
+    }
+
+    const result = await syncPromise;
+
+    // Should complete without hitting max retries
+    expect(result.error).toBeUndefined();
+    expect(console.warn).not.toHaveBeenCalled();
+  });
+});
diff --git a/insightops/app/services/salesVelocity.server.test.ts b/insightops/app/services/salesVelocity.server.test.ts
new file mode 100644
index 0000000..1831773
--- /dev/null
+++ b/insightops/app/services/salesVelocity.server.test.ts
@@ -0,0 +1,473 @@
+import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
+import type { LineItemNode } from "./salesVelocity.server";
+
+// Mock db.server before importing the module under test
+vi.mock("../db.server", () => ({
+  default: {
+    session: {
+      findFirst: vi.fn(),
+    },
+  },
+}));
+
+// Mock shopify.server
+vi.mock("../shopify.server", () => ({
+  apiVersion: "2025-10",
+}));
+
+import db from "../db.server";
+import {
+  getShopSalesVelocity,
+  clearVelocityCache,
+  extractId,
+  parseLineItemNodes,
+} from "./salesVelocity.server";
+
+const SHOP = "test-shop.myshopify.com";
+
+function makeLineItemNode(
+  productId: string,
+  variantId: string,
+  quantity: number,
+  amount: string
+): { node: LineItemNode } {
+  return {
+    node: {
+      product: { id: `gid://shopify/Product/${productId}` },
+      variant: { id: `gid://shopify/ProductVariant/${variantId}` },
+      quantity,
+      originalUnitPriceSet: { shopMoney: { amount } },
+    },
+  };
+}
+
+function makeOrdersResponse(
+  orders: Array<{
+    id: string;
+    lineItems: Array<{ node: LineItemNode }>;
+    hasMoreLineItems?: boolean;
+    lineItemEndCursor?: string;
+  }>,
+  hasNextPage = false,
+  endCursor: string | null = null
+) {
+  return {
+    data: {
+      orders: {
+        edges: orders.map((o) => ({
+          node: {
+            id: o.id,
+            createdAt: "2026-02-15T10:00:00Z",
+            lineItems: {
+              edges: o.lineItems,
+              pageInfo: {
+                hasNextPage: o.hasMoreLineItems ?? false,
+                endCursor: o.lineItemEndCursor ?? null,
+              },
+            },
+          },
+        })),
+        pageInfo: { hasNextPage, endCursor },
+      },
+    },
+  };
+}
+
+function makeOrderLineItemsResponse(
+  lineItems: Array<{ node: LineItemNode }>,
+  hasNextPage = false,
+  endCursor: string | null = null
+) {
+  return {
+    data: {
+      order: {
+        lineItems: {
+          edges: lineItems,
+          pageInfo: { hasNextPage, endCursor },
+        },
+      },
+    },
+  };
+}
+
+describe("fetchOrders line item pagination", () => {
+  let fetchSpy: ReturnType<typeof vi.spyOn>;
+  let consoleWarnSpy: ReturnType<typeof vi.spyOn>;
+  let consoleLogSpy: ReturnType<typeof vi.spyOn>;
+  let consoleErrorSpy: ReturnType<typeof vi.spyOn>;
+
+  beforeEach(() => {
+    clearVelocityCache();
+    vi.mocked(db.session.findFirst).mockResolvedValue({
+      id: "session-1",
+      shop: SHOP,
+      state: "active",
+      isOnline: false,
+      scope: "read_products",
+      expires: null,
+      accessToken: "test-token",
+      userId: null,
+      firstName: null,
+      lastName: null,
+      email: null,
+      accountOwner: false,
+      locale: null,
+      collaborator: null,
+      emailVerified: null,
+    });
+    fetchSpy = vi.spyOn(globalThis, "fetch");
+    consoleWarnSpy = vi.spyOn(console, "warn").mockImplementation(() => {});
+    consoleLogSpy = vi.spyOn(console, "log").mockImplementation(() => {});
+    consoleErrorSpy = vi.spyOn(console, "error").mockImplementation(() => {});
+  });
+
+  afterEach(() => {
+    vi.restoreAllMocks();
+  });
+
+  it("should fetch all line items when under 50 per order", async () => {
+    fetchSpy.mockResolvedValueOnce(
+      new Response(
+        JSON.stringify(
+          makeOrdersResponse([
+            {
+              id: "gid://shopify/Order/1",
+              lineItems: [
+                makeLineItemNode("100", "200", 2, "50.00"),
+                makeLineItemNode("101", "201", 1, "25.00"),
+              ],
+            },
+          ])
+        ),
+        { status: 200 }
+      )
+    );
+
+    const result = await getShopSalesVelocity(SHOP, 30);
+
+    expect(result.size).toBe(2);
+    expect(result.get("100")?.totalUnitsSold).toBe(2);
+    expect(result.get("101")?.totalUnitsSold).toBe(1);
+    // Only one fetch call needed (no line item pagination)
+    expect(fetchSpy).toHaveBeenCalledTimes(1);
+  });
+
+  it("should paginate line items when order has more than 50", async () => {
+    // First call: orders query with truncated line items
+    fetchSpy.mockResolvedValueOnce(
+      new Response(
+        JSON.stringify(
+          makeOrdersResponse([
+            {
+              id: "gid://shopify/Order/1",
+              lineItems: [makeLineItemNode("100", "200", 2, "50.00")],
+              hasMoreLineItems: true,
+              lineItemEndCursor: "li-cursor-1",
+            },
+          ])
+        ),
+        { status: 200 }
+      )
+    );
+
+    // Second call: additional line items for the order
+    fetchSpy.mockResolvedValueOnce(
+      new Response(
+        JSON.stringify(
+          makeOrderLineItemsResponse([
+            makeLineItemNode("101", "201", 3, "30.00"),
+          ])
+        ),
+        { status: 200 }
+      )
+    );
+
+    const result = await getShopSalesVelocity(SHOP, 30);
+
+    expect(result.size).toBe(2);
+    expect(result.get("100")?.totalUnitsSold).toBe(2);
+    expect(result.get("101")?.totalUnitsSold).toBe(3);
+    // Two fetch calls: orders + additional line items
+    expect(fetchSpy).toHaveBeenCalledTimes(2);
+  });
+
+  it("should log warning when line items are paginated", async () => {
+    fetchSpy.mockResolvedValueOnce(
+      new Response(
+        JSON.stringify(
+          makeOrdersResponse([
+            {
+              id: "gid://shopify/Order/1",
+              lineItems: [makeLineItemNode("100", "200", 1, "10.00")],
+              hasMoreLineItems: true,
+              lineItemEndCursor: "li-cursor-1",
+            },
+          ])
+        ),
+        { status: 200 }
+      )
+    );
+
+    fetchSpy.mockResolvedValueOnce(
+      new Response(
+        JSON.stringify(
+          makeOrderLineItemsResponse([
+            makeLineItemNode("101", "201", 1, "10.00"),
+          ])
+        ),
+        { status: 200 }
+      )
+    );
+
+    await getShopSalesVelocity(SHOP, 30);
+
+    expect(consoleWarnSpy).toHaveBeenCalledWith(
+      expect.stringContaining("more than 50 line items")
+    );
+  });
+
+  it("should paginate through multiple pages of line items", async () => {
+    // Orders response with truncated line items
+    fetchSpy.mockResolvedValueOnce(
+      new Response(
+        JSON.stringify(
+          makeOrdersResponse([
+            {
+              id: "gid://shopify/Order/1",
+              lineItems: [makeLineItemNode("100", "200", 1, "10.00")],
+              hasMoreLineItems: true,
+              lineItemEndCursor: "li-cursor-1",
+            },
+          ])
+        ),
+        { status: 200 }
+      )
+    );
+
+    // First line items page - has another page
+    fetchSpy.mockResolvedValueOnce(
+      new Response(
+        JSON.stringify(
+          makeOrderLineItemsResponse(
+            [makeLineItemNode("101", "201", 2, "20.00")],
+            true,
+            "li-cursor-2"
+          )
+        ),
+        { status: 200 }
+      )
+    );
+
+    // Second line items page - last page
+    fetchSpy.mockResolvedValueOnce(
+      new Response(
+        JSON.stringify(
+          makeOrderLineItemsResponse([
+            makeLineItemNode("102", "202", 3, "30.00"),
+          ])
+        ),
+        { status: 200 }
+      )
+    );
+
+    const result = await getShopSalesVelocity(SHOP, 30);
+
+    expect(result.size).toBe(3);
+    expect(result.get("100")?.totalUnitsSold).toBe(1);
+    expect(result.get("101")?.totalUnitsSold).toBe(2);
+    expect(result.get("102")?.totalUnitsSold).toBe(3);
+    expect(fetchSpy).toHaveBeenCalledTimes(3);
+  });
+
+  it("should handle line item fetch errors gracefully", async () => {
+    // Orders response with truncated line items
+    fetchSpy.mockResolvedValueOnce(
+      new Response(
+        JSON.stringify(
+          makeOrdersResponse([
+            {
+              id: "gid://shopify/Order/1",
+              lineItems: [makeLineItemNode("100", "200", 1, "10.00")],
+              hasMoreLineItems: true,
+              lineItemEndCursor: "li-cursor-1",
+            },
+          ])
+        ),
+        { status: 200 }
+      )
+    );
+
+    // Line items fetch fails
+    fetchSpy.mockResolvedValueOnce(
+      new Response("Internal Server Error", { status: 500 })
+    );
+
+    const result = await getShopSalesVelocity(SHOP, 30);
+
+    // Should still have the first page of line items
+    expect(result.size).toBe(1);
+    expect(result.get("100")?.totalUnitsSold).toBe(1);
+  });
+
+  it("should pass correct orderId GID in line items pagination query", async () => {
+    const orderId = "gid://shopify/Order/12345";
+
+    fetchSpy.mockResolvedValueOnce(
+      new Response(
+        JSON.stringify(
+          makeOrdersResponse([
+            {
+              id: orderId,
+              lineItems: [makeLineItemNode("100", "200", 1, "10.00")],
+              hasMoreLineItems: true,
+              lineItemEndCursor: "li-cursor-1",
+            },
+          ])
+        ),
+        { status: 200 }
+      )
+    );
+
+    fetchSpy.mockResolvedValueOnce(
+      new Response(
+        JSON.stringify(
+          makeOrderLineItemsResponse([
+            makeLineItemNode("101", "201", 1, "10.00"),
+          ])
+        ),
+        { status: 200 }
+      )
+    );
+
+    await getShopSalesVelocity(SHOP, 30);
+
+    // Second call should be the line items query with the correct order GID
+    const secondCallBody = JSON.parse(
+      fetchSpy.mock.calls[1][1]?.body as string
+    );
+    expect(secondCallBody.variables.orderId).toBe(orderId);
+    expect(secondCallBody.variables.cursor).toBe("li-cursor-1");
+  });
+
+  it("should handle orders with no additional line item pages needed", async () => {
+    fetchSpy.mockResolvedValueOnce(
+      new Response(
+        JSON.stringify(
+          makeOrdersResponse([
+            {
+              id: "gid://shopify/Order/1",
+              lineItems: [
+                makeLineItemNode("100", "200", 1, "10.00"),
+                makeLineItemNode("101", "201", 2, "20.00"),
+              ],
+              hasMoreLineItems: false,
+              lineItemEndCursor: undefined,
+            },
+          ])
+        ),
+        { status: 200 }
+      )
+    );
+
+    const result = await getShopSalesVelocity(SHOP, 30);
+
+    expect(result.size).toBe(2);
+    expect(fetchSpy).toHaveBeenCalledTimes(1);
+    expect(consoleWarnSpy).not.toHaveBeenCalledWith(
+      expect.stringContaining("more than 50 line items")
+    );
+  });
+});
+
+describe("extractId", () => {
+  it("should extract numeric ID from Shopify GID", () => {
+    expect(extractId("gid://shopify/Product/12345")).toBe("12345");
+    expect(extractId("gid://shopify/Order/67890")).toBe("67890");
+    expect(extractId("gid://shopify/ProductVariant/111")).toBe("111");
+  });
+
+  it("should return empty string for null/undefined", () => {
+    expect(extractId(null)).toBe("");
+    expect(extractId(undefined)).toBe("");
+  });
+
+  it("should return empty string for malformed GIDs", () => {
+    expect(extractId("")).toBe("");
+    expect(extractId("not-a-gid")).toBe("");
+    expect(extractId("gid://shopify/Product/")).toBe("");
+  });
+});
+
+describe("parseLineItemNodes", () => {
+  const makeNode = (
+    productId: string,
+    variantId: string,
+    quantity: number,
+    amount: string
+  ): LineItemNode => ({
+    product: { id: `gid://shopify/Product/${productId}` },
+    variant: { id: `gid://shopify/ProductVariant/${variantId}` },
+    quantity,
+    originalUnitPriceSet: { shopMoney: { amount } },
+  });
+
+  it("should parse valid line item nodes", () => {
+    const nodes: LineItemNode[] = [
+      makeNode("100", "200", 2, "50.00"),
+      makeNode("101", "201", 1, "25.50"),
+    ];
+
+    const result = parseLineItemNodes(nodes);
+
+    expect(result).toHaveLength(2);
+    expect(result[0]).toEqual({
+      productId: "100",
+      variantId: "200",
+      quantity: 2,
+      price: 50,
+    });
+    expect(result[1]).toEqual({
+      productId: "101",
+      variantId: "201",
+      quantity: 1,
+      price: 25.5,
+    });
+  });
+
+  it("should filter out nodes with null product", () => {
+    const nodes: LineItemNode[] = [
+      { product: null, variant: { id: "gid://shopify/ProductVariant/200" }, quantity: 1, originalUnitPriceSet: { shopMoney: { amount: "10.00" } } },
+      makeNode("100", "200", 1, "50.00"),
+    ];
+
+    const result = parseLineItemNodes(nodes);
+    expect(result).toHaveLength(1);
+    expect(result[0].productId).toBe("100");
+  });
+
+  it("should handle null price gracefully", () => {
+    const node: LineItemNode = {
+      product: { id: "gid://shopify/Product/100" },
+      variant: { id: "gid://shopify/ProductVariant/200" },
+      quantity: 3,
+      originalUnitPriceSet: null,
+    };
+
+    const result = parseLineItemNodes([node]);
+    expect(result).toHaveLength(1);
+    expect(result[0].price).toBe(0);
+  });
+
+  it("should return empty array for empty input", () => {
+    expect(parseLineItemNodes([])).toEqual([]);
+  });
+
+  it("should handle large batches of nodes", () => {
+    const nodes: LineItemNode[] = Array.from({ length: 100 }, (_, i) =>
+      makeNode(String(i), String(i + 1000), 1, "10.00")
+    );
+
+    const result = parseLineItemNodes(nodes);
+    expect(result).toHaveLength(100);
+  });
+});
diff --git a/insightops/app/services/salesVelocity.server.ts b/insightops/app/services/salesVelocity.server.ts
index 397dba5..cc1e030 100644
--- a/insightops/app/services/salesVelocity.server.ts
+++ b/insightops/app/services/salesVelocity.server.ts
@@ -17,6 +17,7 @@ import db from "../db.server";
 import {
   calculateProductVelocity,
   type OrderData,
+  type OrderLineItem,
   type ProductVelocity,
 } from "./salesVelocity.utils";
 
@@ -44,6 +45,10 @@ const ORDERS_QUERY = `#graphql
                 }
               }
             }
+            pageInfo {
+              hasNextPage
+              endCursor
+            }
           }
         }
       }
@@ -55,8 +60,38 @@ const ORDERS_QUERY = `#graphql
   }
 `;
 
+const ORDER_LINE_ITEMS_QUERY = `#graphql
+  query GetOrderLineItems($orderId: ID!, $cursor: String) {
+    order(id: $orderId) {
+      lineItems(first: 50, after: $cursor) {
+        edges {
+          node {
+            product {
+              id
+            }
+            variant {
+              id
+            }
+            quantity
+            originalUnitPriceSet {
+              shopMoney {
+                amount
+              }
+            }
+          }
+        }
+        pageInfo {
+          hasNextPage
+          endCursor
+        }
+      }
+    }
+  }
+`;
+
 // Max pages to fetch to prevent runaway pagination
 const MAX_PAGES = 20; // 20 pages * 50 orders = 1000 orders max
+const MAX_LINE_ITEM_PAGES = 10; // 10 pages * 50 items = 500 line items per order
 
 // In-memory cache (lives for the lifetime of a single request/job batch)
 // Key: `${shop}:${periodDays}`, Value: velocity map
@@ -67,14 +102,123 @@ const CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes
  * Extract numeric ID from Shopify GID.
  * "gid://shopify/Product/12345" -> "12345"
  */
-function extractId(gid: string | null | undefined): string {
+export function extractId(gid: string | null | undefined): string {
   if (!gid) return "";
   const match = gid.match(/\/(\d+)$/);
   return match?.[1] ?? "";
 }
 
+export interface LineItemNode {
+  product: { id: string } | null;
+  variant: { id: string } | null;
+  quantity: number;
+  originalUnitPriceSet: {
+    shopMoney: { amount: string };
+  } | null;
+}
+
+interface LineItemsConnection {
+  edges: Array<{ node: LineItemNode }>;
+  pageInfo: {
+    hasNextPage: boolean;
+    endCursor: string | null;
+  };
+}
+
+export function parseLineItemNodes(nodes: LineItemNode[]): OrderLineItem[] {
+  return nodes
+    .map((node) => ({
+      productId: extractId(node.product?.id),
+      variantId: extractId(node.variant?.id),
+      quantity: node.quantity,
+      price: parseFloat(
+        node.originalUnitPriceSet?.shopMoney?.amount ?? "0"
+      ),
+    }))
+    .filter((li) => li.productId !== "");
+}
+
+/**
+ * Fetch remaining line items for an order using cursor-based pagination.
+ * Called when the initial lineItems(first: 50) response indicates more pages.
+ */
+async function fetchRemainingLineItems(
+  shop: string,
+  accessToken: string,
+  orderId: string,
+  initialCursor: string
+): Promise<LineItemNode[]> {
+  const additionalNodes: LineItemNode[] = [];
+  let cursor: string | null = initialCursor;
+  let page = 0;
+
+  while (page < MAX_LINE_ITEM_PAGES) {
+    const response = await fetch(
+      `https://${shop}/admin/api/${apiVersion}/graphql.json`,
+      {
+        method: "POST",
+        headers: {
+          "X-Shopify-Access-Token": accessToken,
+          "Content-Type": "application/json",
+        },
+        body: JSON.stringify({
+          query: ORDER_LINE_ITEMS_QUERY,
+          variables: { orderId, cursor },
+        }),
+      }
+    );
+
+    if (!response.ok) {
+      console.error(
+        `[StoreGuard] Order line items API returned ${response.status} for ${shop} order ${orderId}`
+      );
+      break;
+    }
+
+    const data = (await response.json()) as {
+      data?: {
+        order?: {
+          lineItems: LineItemsConnection;
+        };
+      };
+      errors?: Array<{ message: string }>;
+    };
+
+    if (data.errors?.length) {
+      console.error(
+        `[StoreGuard] Order line items GraphQL errors:`,
+        data.errors.map((e) => e.message).join(", ")
+      );
+      break;
+    }
+
+    const lineItems = data.data?.order?.lineItems;
+    if (!lineItems) break;
+
+    for (const edge of lineItems.edges) {
+      additionalNodes.push(edge.node);
+    }
+
+    if (!lineItems.pageInfo.hasNextPage || !lineItems.pageInfo.endCursor) {
+      break;
+    }
+
+    cursor = lineItems.pageInfo.endCursor;
+    page++;
+  }
+
+  if (page >= MAX_LINE_ITEM_PAGES) {
+    console.warn(
+      `[StoreGuard] Hit max line item page limit (${MAX_LINE_ITEM_PAGES}) for ${shop} order ${orderId}, some line items may be missing`
+    );
+  }
+
+  return additionalNodes;
+}
+
 /**
  * Fetch orders from Shopify using cursor-based pagination with date-range filtering.
+ * Line items within each order are also paginated if they exceed 50 items.
  * Returns normalized OrderData array.
  */
 async function fetchOrders(
@@ -119,18 +263,7 @@ async function fetchOrders(
             node: {
               id: string;
               createdAt: string;
-              lineItems: {
-                edges: Array<{
-                  node: {
-                    product: { id: string } | null;
-                    variant: { id: string } | null;
-                    quantity: number;
-                    originalUnitPriceSet: {
-                      shopMoney: { amount: string };
-                    } | null;
-                  };
-                }>;
-              };
+              lineItems: LineItemsConnection;
             };
           }>;
           pageInfo: {
@@ -153,16 +286,25 @@ async function fetchOrders(
     const edges = data.data?.orders?.edges ?? [];
 
     for (const edge of edges) {
-      const lineItems = edge.node.lineItems.edges
-        .map((li) => ({
-          productId: extractId(li.node.product?.id),
-          variantId: extractId(li.node.variant?.id),
-          quantity: li.node.quantity,
-          price: parseFloat(
-            li.node.originalUnitPriceSet?.shopMoney?.amount ?? "0"
-          ),
-        }))
-        .filter((li) => li.productId !== "");
+      const allNodes: LineItemNode[] = edge.node.lineItems.edges.map((e) => e.node);
+
+      // Paginate remaining line items if the first page was truncated
+      const liPageInfo = edge.node.lineItems.pageInfo;
+      if (liPageInfo.hasNextPage && liPageInfo.endCursor) {
+        console.warn(
+          `[StoreGuard] Order ${edge.node.id} has more than 50 line items for ${shop}, fetching additional pages`
+        );
+
+        const remaining = await fetchRemainingLineItems(
+          shop,
+          accessToken,
+          edge.node.id,
+          liPageInfo.endCursor
+        );
+        allNodes.push(...remaining);
+      }
+
+      const lineItems = parseLineItemNodes(allNodes);
 
       if (lineItems.length > 0) {
         orders.push({
diff --git a/insightops/app/services/shopService.server.ts b/insightops/app/services/shopService.server.ts
index a11cccd..431c9f6 100644
--- a/insightops/app/services/shopService.server.ts
+++ b/insightops/app/services/shopService.server.ts
@@ -7,6 +7,10 @@ export interface ShopSettings {
   trackVisibility: boolean;
   trackInventory: boolean;
   trackThemes: boolean;
+  trackCollections: boolean;
+  trackDiscounts: boolean;
+  trackAppPermissions: boolean;
+  trackDomains: boolean;
   lowStockThreshold: number;
   instantAlerts: boolean;
 }
@@ -27,6 +31,8 @@ export async function getOrCreateShop(shopDomain: string): Promise<ShopSettings>
       trackVisibility: true,
       trackInventory: true,
       trackThemes: false, // Pro only by default
+      trackCollections: true,
+      trackDiscounts: false, // Pro only
       installedAt: new Date(),
     },
     update: {
@@ -44,6 +50,10 @@ export async function getOrCreateShop(shopDomain: string): Promise<ShopSettings>
     trackVisibility: shop.trackVisibility,
     trackInventory: shop.trackInventory,
     trackThemes: shop.trackThemes,
+    trackCollections: shop.trackCollections,
+    trackDiscounts: shop.trackDiscounts,
+    trackAppPermissions: shop.trackAppPermissions,
+    trackDomains: shop.trackDomains,
     lowStockThreshold: shop.lowStockThreshold,
     instantAlerts: shop.instantAlerts,
   };
@@ -67,6 +77,10 @@ export async function getShopSettings(shopDomain: string): Promise<ShopSettings
     trackVisibility: shop.trackVisibility,
     trackInventory: shop.trackInventory,
     trackThemes: shop.trackThemes,
+    trackCollections: shop.trackCollections,
+    trackDiscounts: shop.trackDiscounts,
+    trackAppPermissions: shop.trackAppPermissions,
+    trackDomains: shop.trackDomains,
     lowStockThreshold: shop.lowStockThreshold,
     instantAlerts: shop.instantAlerts,
   };
@@ -95,6 +109,27 @@ export async function updateShopSettings(
     trackThemes = false;
   }
 
+  // Discounts are Pro-only
+  let trackDiscounts = settings.trackDiscounts ?? shop.trackDiscounts;
+  if (shop.plan !== "pro" && trackDiscounts) {
+    console.log(`[StoreGuard] Blocking trackDiscounts for free plan: ${shopDomain}`);
+    trackDiscounts = false;
+  }
+
+  // App permissions are Pro-only
+  let trackAppPermissions = settings.trackAppPermissions ?? shop.trackAppPermissions;
+  if (shop.plan !== "pro" && trackAppPermissions) {
+    console.log(`[StoreGuard] Blocking trackAppPermissions for free plan: ${shopDomain}`);
+    trackAppPermissions = false;
+  }
+
+  // Domains are Pro-only
+  let trackDomains = settings.trackDomains ?? shop.trackDomains;
+  if (shop.plan !== "pro" && trackDomains) {
+    console.log(`[StoreGuard] Blocking trackDomains for free plan: ${shopDomain}`);
+    trackDomains = false;
+  }
+
   // Instant alerts are Pro-only
   let instantAlerts = settings.instantAlerts ?? shop.instantAlerts;
   if (shop.plan !== "pro" && instantAlerts) {
@@ -115,6 +150,10 @@ export async function updateShopSettings(
       trackVisibility: settings.trackVisibility ?? shop.trackVisibility,
       trackInventory: settings.trackInventory ?? shop.trackInventory,
       trackThemes,
+      trackCollections: settings.trackCollections ?? shop.trackCollections,
+      trackDiscounts,
+      trackAppPermissions,
+      trackDomains,
       lowStockThreshold,
       instantAlerts,
     },
@@ -129,6 +168,10 @@ export async function updateShopSettings(
     trackVisibility: updated.trackVisibility,
     trackInventory: updated.trackInventory,
     trackThemes: updated.trackThemes,
+    trackCollections: updated.trackCollections,
+    trackDiscounts: updated.trackDiscounts,
+    trackAppPermissions: updated.trackAppPermissions,
+    trackDomains: updated.trackDomains,
     lowStockThreshold: updated.lowStockThreshold,
     instantAlerts: updated.instantAlerts,
   };
@@ -173,6 +216,9 @@ export async function downgradeShopToFree(shopDomain: string): Promise<void> {
     data: {
       plan: "free",
       trackThemes: false, // Disable Pro-only features
+      trackDiscounts: false, // Disable Pro-only features
+      trackAppPermissions: false, // Disable Pro-only features
+      trackDomains: false, // Disable Pro-only features
       instantAlerts: false, // Disable Pro-only features
     },
   });
@@ -195,7 +241,7 @@ export async function isProPlan(shopDomain: string): Promise<boolean> {
  */
 export async function canTrackFeature(
   shopDomain: string,
-  feature: "prices" | "visibility" | "inventory" | "themes"
+  feature: "prices" | "visibility" | "inventory" | "themes" | "collections" | "discounts" | "app_permissions" | "domains"
 ): Promise<boolean> {
   const shop = await db.shop.findUnique({
     where: { shopifyDomain: shopDomain },
@@ -212,6 +258,14 @@ export async function canTrackFeature(
       return shop.trackInventory;
     case "themes":
       return shop.plan === "pro" && shop.trackThemes;
+    case "collections":
+      return shop.trackCollections;
+    case "discounts":
+      return shop.plan === "pro" && shop.trackDiscounts;
+    case "app_permissions":
+      return shop.plan === "pro" && shop.trackAppPermissions;
+    case "domains":
+      return shop.plan === "pro" && shop.trackDomains;
     default:
       return false;
   }
@@ -255,3 +309,41 @@ export async function getShopAlertEmail(shopDomain: string): Promise<string | nu
 
   return shop?.alertEmail ?? null;
 }
+
+/**
+ * Check if a shop has completed onboarding.
+ */
+export async function isOnboarded(shopDomain: string): Promise<boolean> {
+  const shop = await db.shop.findUnique({
+    where: { shopifyDomain: shopDomain },
+    select: { onboardedAt: true },
+  });
+  return shop?.onboardedAt !== null && shop?.onboardedAt !== undefined;
+}
+
+/**
+ * Mark a shop as onboarded and save initial settings from the onboarding flow.
+ */
+export async function completeOnboarding(
+  shopDomain: string,
+  settings: {
+    alertEmail: string | null;
+    trackPrices: boolean;
+    trackVisibility: boolean;
+    trackInventory: boolean;
+    trackCollections: boolean;
+  }
+): Promise<void> {
+  await db.shop.update({
+    where: { shopifyDomain: shopDomain },
+    data: {
+      alertEmail: settings.alertEmail,
+      trackPrices: settings.trackPrices,
+      trackVisibility: settings.trackVisibility,
+      trackInventory: settings.trackInventory,
+      trackCollections: settings.trackCollections,
+      onboardedAt: new Date(),
+    },
+  });
+  console.log(`[StoreGuard] Onboarding completed for ${shopDomain}`);
+}
diff --git a/insightops/app/services/webhookCompleteness.test.ts b/insightops/app/services/webhookCompleteness.test.ts
new file mode 100644
index 0000000..1e8c764
--- /dev/null
+++ b/insightops/app/services/webhookCompleteness.test.ts
@@ -0,0 +1,220 @@
+import { describe, it, expect } from "vitest";
+import * as fs from "fs";
+import * as path from "path";
+
+/**
+ * Webhook completeness test
+ *
+ * Verifies that every webhook subscription in shopify.app.toml has a
+ * corresponding route handler, and vice versa. Also checks that required
+ * scopes are declared and the job processor handles all queued topics.
+ */
+
+const ROOT = path.resolve(__dirname, "../..");
+const TOML_PATH = path.join(ROOT, "shopify.app.toml");
+const ROUTES_DIR = path.join(ROOT, "app/routes");
+const JOB_PROCESSOR_PATH = path.join(ROOT, "app/services/jobProcessor.server.ts");
+
+/** Parse webhook topics and URIs from shopify.app.toml (simple regex, no TOML lib needed) */
+function parseTomlWebhooks(): { topics: string[]; uris: Map<string, string>; complianceTopics: string[] } {
+  const content = fs.readFileSync(TOML_PATH, "utf-8");
+  const topics: string[] = [];
+  const complianceTopics: string[] = [];
+  const uris = new Map<string, string>();
+
+  // Match [[webhooks.subscriptions]] blocks
+  const blocks = content.split("[[webhooks.subscriptions]]").slice(1);
+
+  for (const block of blocks) {
+    const uriMatch = block.match(/uri\s*=\s*"([^"]+)"/);
+    const topicsMatch = block.match(/topics\s*=\s*\[\s*"([^"]+)"\s*\]/);
+    const complianceMatch = block.match(/compliance_topics\s*=\s*\[([^\]]+)\]/);
+
+    if (complianceMatch) {
+      const matches = complianceMatch[1].matchAll(/"([^"]+)"/g);
+      for (const m of matches) {
+        complianceTopics.push(m[1]);
+      }
+    }
+
+    if (topicsMatch && uriMatch) {
+      topics.push(topicsMatch[1]);
+      uris.set(topicsMatch[1], uriMatch[1]);
+    }
+  }
+
+  return { topics, uris, complianceTopics };
+}
+
+/** Convert a webhook URI to the expected route file name */
+function uriToRouteFile(uri: string): string {
+  // "/webhooks/products/delete" -> "webhooks.products.delete.tsx"
+  return uri.replace(/^\//, "").replace(/\//g, ".") + ".tsx";
+}
+
+/** Convert a webhook topic to the normalized form used in jobProcessor switch */
+function topicToNormalized(topic: string): string {
+  // "inventory_levels/update" -> "inventory/levels/update"
+  return topic.toLowerCase().replace(/_/g, "/");
+}
+
+/** Get all webhook route handler files */
+function getWebhookRouteFiles(): string[] {
+  return fs.readdirSync(ROUTES_DIR).filter((f) => f.startsWith("webhooks.") && f.endsWith(".tsx"));
+}
+
+/** Parse job processor switch cases */
+function getJobProcessorTopics(): string[] {
+  const content = fs.readFileSync(JOB_PROCESSOR_PATH, "utf-8");
+  const cases: string[] = [];
+  const caseRegex = /case\s+"([^"]+)":/g;
+  let match;
+  while ((match = caseRegex.exec(content)) !== null) {
+    cases.push(match[1]);
+  }
+  return cases;
+}
+
+/** Parse scopes from shopify.app.toml */
+function parseTomlScopes(): string[] {
+  const content = fs.readFileSync(TOML_PATH, "utf-8");
+  const scopesMatch = content.match(/scopes\s*=\s*"([^"]+)"/);
+  return scopesMatch ? scopesMatch[1].split(",").map((s) => s.trim()) : [];
+}
+
+describe("webhook completeness", () => {
+  const { topics, uris, complianceTopics } = parseTomlWebhooks();
+  const routeFiles = getWebhookRouteFiles();
+  const processorTopics = getJobProcessorTopics();
+  const scopes = parseTomlScopes();
+
+  it("every webhook topic in shopify.app.toml has a route handler", () => {
+    const missing: string[] = [];
+
+    for (const topic of topics) {
+      const uri = uris.get(topic)!;
+      const expectedFile = uriToRouteFile(uri);
+      if (!routeFiles.includes(expectedFile)) {
+        missing.push(`${topic} -> expected ${expectedFile}`);
+      }
+    }
+
+    expect(missing, `Missing route handlers:\n${missing.join("\n")}`).toEqual([]);
+  });
+
+  it("compliance topics have a shared route handler", () => {
+    expect(complianceTopics.length).toBeGreaterThan(0);
+    expect(routeFiles).toContain("webhooks.compliance.tsx");
+  });
+
+  it("every webhook route handler has a subscription in shopify.app.toml", () => {
+    const expectedUris = new Set(uris.values());
+    // Compliance handler uses a different format
+    expectedUris.add("/webhooks/compliance");
+    // app/uninstalled is a mandatory webhook that Shopify manages
+    expectedUris.add("/webhooks/app/uninstalled");
+
+    const orphaned: string[] = [];
+    for (const file of routeFiles) {
+      const uri = "/" + file.replace(/\.tsx$/, "").replace(/\./g, "/");
+      if (!expectedUris.has(uri)) {
+        orphaned.push(`${file} -> ${uri} has no subscription`);
+      }
+    }
+
+    expect(orphaned, `Orphaned handlers (no subscription):\n${orphaned.join("\n")}`).toEqual([]);
+  });
+
+  // Topics that are handled directly in the webhook handler (not queued to job processor)
+  const DIRECT_HANDLED_TOPICS = new Set([
+    "app/uninstalled", // Handles cleanup directly (Stripe cancel, session delete)
+  ]);
+
+  it("every queued webhook topic is handled in jobProcessor switch", () => {
+    const missing: string[] = [];
+
+    for (const topic of topics) {
+      if (DIRECT_HANDLED_TOPICS.has(topic)) continue;
+
+      const normalized = topicToNormalized(topic);
+      if (!processorTopics.includes(normalized)) {
+        missing.push(`${topic} (normalized: ${normalized})`);
+      }
+    }
+
+    expect(missing, `Topics not handled in jobProcessor:\n${missing.join("\n")}`).toEqual([]);
+  });
+
+  it("required scopes are declared for subscribed webhook topics", () => {
+    // Map webhook topics to required scopes
+    // See: https://shopify.dev/docs/api/admin-rest/2025-10/resources/webhook
+    const TOPIC_SCOPE_MAP: Record<string, string> = {
+      "products/create": "read_products",
+      "products/update": "read_products",
+      "products/delete": "read_products",
+      "collections/create": "read_products",
+      "collections/update": "read_products",
+      "collections/delete": "read_products",
+      "inventory_levels/update": "read_inventory",
+      "themes/publish": "read_themes",
+      "discounts/create": "read_discounts",
+      "discounts/update": "read_discounts",
+      "discounts/delete": "read_discounts",
+      // These don't require explicit scopes:
+      // "app/uninstalled", "app/scopes_update", "domains/*"
+    };
+
+    const missing: string[] = [];
+    for (const topic of topics) {
+      const requiredScope = TOPIC_SCOPE_MAP[topic];
+      if (requiredScope && !scopes.includes(requiredScope)) {
+        missing.push(`${topic} requires scope "${requiredScope}"`);
+      }
+    }
+
+    expect(missing, `Missing scopes:\n${missing.join("\n")}`).toEqual([]);
+  });
+
+  it("has all V2 webhook topics subscribed", () => {
+    // From PRD_V2.md and CLAUDE.md V2 section
+    const requiredTopics = [
+      // V1 core
+      "products/create",
+      "products/update",
+      "products/delete",
+      "inventory_levels/update",
+      "themes/publish",
+      "app/uninstalled",
+      // V2 additions
+      "collections/create",
+      "collections/update",
+      "collections/delete",
+      "discounts/create",
+      "discounts/update",
+      "discounts/delete",
+      "domains/create",
+      "domains/update",
+      "domains/destroy",
+      "app/scopes_update",
+    ];
+
+    const allTopics = new Set([...topics, "app/uninstalled"]);
+    const missing = requiredTopics.filter((t) => !allTopics.has(t));
+
+    expect(missing, `Missing V2 webhook topics:\n${missing.join("\n")}`).toEqual([]);
+  });
+
+  it("has no duplicate webhook subscriptions", () => {
+    const seen = new Set<string>();
+    const duplicates: string[] = [];
+
+    for (const topic of topics) {
+      if (seen.has(topic)) {
+        duplicates.push(topic);
+      }
+      seen.add(topic);
+    }
+
+    expect(duplicates, `Duplicate subscriptions:\n${duplicates.join("\n")}`).toEqual([]);
+  });
+});
diff --git a/insightops/prisma/migrations/20260218120000_unify_event_pipeline_drop_eventlog/migration.sql b/insightops/prisma/migrations/20260218120000_unify_event_pipeline_drop_eventlog/migration.sql
new file mode 100644
index 0000000..d2a8e22
--- /dev/null
+++ b/insightops/prisma/migrations/20260218120000_unify_event_pipeline_drop_eventlog/migration.sql
@@ -0,0 +1,9 @@
+-- Unify EventLog + ChangeEvent into single event pipeline
+-- EventLog is no longer referenced anywhere in the codebase.
+-- All audit/activity logging already uses ChangeEvent with topic, diff, author fields.
+
+-- Step 1: Make webhookId nullable on ChangeEvent (activity-only events don't need dedup)
+ALTER TABLE "ChangeEvent" ALTER COLUMN "webhookId" DROP NOT NULL;
+
+-- Step 2: Drop EventLog table and its indexes
+DROP TABLE IF EXISTS "EventLog";
diff --git a/insightops/prisma/migrations/20260218130000_normalize_variant_snapshots/migration.sql b/insightops/prisma/migrations/20260218130000_normalize_variant_snapshots/migration.sql
new file mode 100644
index 0000000..a72c59f
--- /dev/null
+++ b/insightops/prisma/migrations/20260218130000_normalize_variant_snapshots/migration.sql
@@ -0,0 +1,37 @@
+-- CreateTable
+CREATE TABLE "VariantSnapshot" (
+    "id" TEXT NOT NULL,
+    "shopifyVariantId" TEXT NOT NULL,
+    "productSnapshotId" TEXT NOT NULL,
+    "shop" TEXT NOT NULL,
+    "title" TEXT NOT NULL,
+    "price" TEXT NOT NULL,
+    "inventoryQuantity" INTEGER NOT NULL DEFAULT 0,
+
+    CONSTRAINT "VariantSnapshot_pkey" PRIMARY KEY ("id")
+);
+
+-- Migrate existing JSON data to rows
+INSERT INTO "VariantSnapshot" ("id", "shopifyVariantId", "productSnapshotId", "shop", "title", "price", "inventoryQuantity")
+SELECT
+    gen_random_uuid()::text,
+    elem->>'id',
+    "ProductSnapshot"."id",
+    "ProductSnapshot"."shop",
+    COALESCE(elem->>'title', 'Default Title'),
+    COALESCE(elem->>'price', '0.00'),
+    COALESCE((elem->>'inventoryQuantity')::integer, 0)
+FROM "ProductSnapshot",
+     json_array_elements("ProductSnapshot"."variants"::json) AS elem
+WHERE "ProductSnapshot"."variants" IS NOT NULL
+  AND "ProductSnapshot"."variants" != '';
+
+-- Drop old column
+ALTER TABLE "ProductSnapshot" DROP COLUMN IF EXISTS "variants";
+
+-- CreateIndex
+CREATE UNIQUE INDEX "VariantSnapshot_productSnapshotId_shopifyVariantId_key" ON "VariantSnapshot"("productSnapshotId", "shopifyVariantId");
+CREATE INDEX "VariantSnapshot_shop_shopifyVariantId_idx" ON "VariantSnapshot"("shop", "shopifyVariantId");
+
+-- AddForeignKey
+ALTER TABLE "VariantSnapshot" ADD CONSTRAINT "VariantSnapshot_productSnapshotId_fkey" FOREIGN KEY ("productSnapshotId") REFERENCES "ProductSnapshot"("id") ON DELETE CASCADE ON UPDATE CASCADE;
diff --git a/insightops/prisma/migrations/20260218140000_add_shop_onboarded_at/migration.sql b/insightops/prisma/migrations/20260218140000_add_shop_onboarded_at/migration.sql
new file mode 100644
index 0000000..91e58de
--- /dev/null
+++ b/insightops/prisma/migrations/20260218140000_add_shop_onboarded_at/migration.sql
@@ -0,0 +1,2 @@
+-- AlterTable
+ALTER TABLE "Shop" ADD COLUMN "onboardedAt" TIMESTAMP(3);
diff --git a/insightops/prisma/migrations/20260218150000_add_money_saved_to_change_event/migration.sql b/insightops/prisma/migrations/20260218150000_add_money_saved_to_change_event/migration.sql
new file mode 100644
index 0000000..5794be6
--- /dev/null
+++ b/insightops/prisma/migrations/20260218150000_add_money_saved_to_change_event/migration.sql
@@ -0,0 +1,2 @@
+-- AlterTable
+ALTER TABLE "ChangeEvent" ADD COLUMN "moneySaved" DOUBLE PRECISION;
diff --git a/insightops/prisma/schema.prisma b/insightops/prisma/schema.prisma
index ba5f87d..3b6b759 100644
--- a/insightops/prisma/schema.prisma
+++ b/insightops/prisma/schema.prisma
@@ -41,9 +41,14 @@ model Shop {
   trackVisibility Boolean   @default(true)
   trackInventory  Boolean   @default(true)
   trackThemes     Boolean   @default(false) // Pro only
+  trackCollections Boolean  @default(true) // Collection monitoring (free plan)
+  trackDiscounts  Boolean   @default(false) // Pro only
+  trackAppPermissions Boolean @default(false) // Pro only
+  trackDomains    Boolean   @default(false) // Pro only
   lowStockThreshold Int     @default(5) // Alert when inventory drops below this
   instantAlerts   Boolean   @default(false) // Send alerts immediately (Pro only)
   installedAt     DateTime  @default(now())
+  onboardedAt     DateTime? // When onboarding was completed (null = not onboarded)
   uninstalledAt   DateTime?
   // Stripe billing
   stripeCustomerId     String?  @unique // Stripe customer ID (cus_xxx)
@@ -65,14 +70,20 @@ model ChangeEvent {
   source       String    @default("webhook") // "webhook" | "sync_job" | "manual"
   importance   String    @default("medium") // "high" | "medium" | "low"
   groupId      String?   // For grouping related changes (e.g. bulk edit session)
-  webhookId    String    @unique // Deduplication
+  webhookId    String?   @unique // Deduplication (nullable for activity-only events)
   contextData  String?   // JSON: sales velocity, revenue impact, business context
+  topic        String?   // Webhook topic e.g. "products/update" (unified from EventLog)
+  diff         String?   // JSON snapshot/change data (unified from EventLog)
+  author       String?   // Who made the change (from Shopify Events API)
+  instantAlertSentAt DateTime? // When instant alert email was sent (null = not sent)
+  moneySaved         Float?    // Estimated revenue saved by catching this change (USD)
 
   @@index([shop])
   @@index([shop, detectedAt])
   @@index([shop, eventType])
   @@index([digestedAt])
   @@index([shop, entityType, entityId])
+  @@index([shop, instantAlertSentAt])
 }
 
 // Product state snapshot for change detection
@@ -81,27 +92,26 @@ model ProductSnapshot {
   shop      String
   title     String
   status    String   // "active" | "draft" | "archived"
-  variants  String   // JSON: [{id, title, price, inventoryQuantity}]
   updatedAt DateTime @updatedAt
+  variants  VariantSnapshot[]
 
   @@unique([shop, id])
   @@index([shop])
 }
 
-model EventLog {
-  id          String   @id @default(uuid())
-  shop        String   // The store URL
-  shopifyId   String   // The Resource ID (e.g., Product ID)
-  topic       String   // e.g., "products/update"
-  author      String?  // The "Blame" retrieved via Events API
-  message     String   // Description of change
-  diff        String?  // JSON string: { old: value, new: value }
-  timestamp   DateTime @default(now())
-  webhookId   String?  @unique // Shopify webhook delivery ID for deduplication
-
-  @@index([shop])
-  @@index([shop, timestamp])
-  @@index([shop, shopifyId, topic])
+// Individual variant snapshot for change detection (normalized from JSON blob)
+model VariantSnapshot {
+  id                 String          @id @default(uuid())
+  shopifyVariantId   String          // Shopify variant ID (numeric string)
+  productSnapshotId  String          // FK to ProductSnapshot
+  shop               String          // Denormalized for efficient queries
+  title              String
+  price              String
+  inventoryQuantity  Int             @default(0)
+  productSnapshot    ProductSnapshot @relation(fields: [productSnapshotId], references: [id], onDelete: Cascade)
+
+  @@unique([productSnapshotId, shopifyVariantId])
+  @@index([shop, shopifyVariantId])
 }
 
 // Lightweight product cache for resolving names on delete
